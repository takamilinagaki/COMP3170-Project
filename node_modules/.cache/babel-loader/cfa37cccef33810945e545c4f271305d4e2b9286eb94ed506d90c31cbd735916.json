{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, KeyCodes } from '../../Utilities';\nimport { ButtonGrid } from '../../utilities/ButtonGrid/ButtonGrid';\nimport { ColorPickerGridCell } from './ColorPickerGridCell';\nimport { useId, useConst, useSetTimeout, useControllableValue, useWarnings } from '@fluentui/react-hooks';\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'SwatchColorPicker';\nfunction useDebugWarnings(props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props: props,\n      mutuallyExclusive: {\n        focusOnHover: 'onHover',\n        selectedId: 'defaultSelectedId'\n      },\n      deprecations: {\n        isControlled: \"selectedId' or 'defaultSelectedId\",\n        onColorChanged: 'onChange'\n      }\n    });\n  }\n}\nexport var SwatchColorPickerBase = React.forwardRef(function (props, ref) {\n  var defaultId = useId('swatchColorPicker');\n  var id = props.id || defaultId;\n  var internalState = useConst({\n    isNavigationIdle: true,\n    cellFocused: false,\n    navigationIdleTimeoutId: undefined,\n    navigationIdleDelay: 250\n  });\n  var _a = useSetTimeout(),\n    setTimeout = _a.setTimeout,\n    clearTimeout = _a.clearTimeout;\n  useDebugWarnings(props);\n  var colorCells = props.colorCells,\n    _b = props.cellShape,\n    cellShape = _b === void 0 ? 'circle' : _b,\n    columnCount = props.columnCount,\n    _c = props.shouldFocusCircularNavigate,\n    shouldFocusCircularNavigate = _c === void 0 ? true : _c,\n    className = props.className,\n    _d = props.disabled,\n    disabled = _d === void 0 ? false : _d,\n    doNotContainWithinFocusZone = props.doNotContainWithinFocusZone,\n    styles = props.styles,\n    _e = props.cellMargin,\n    cellMargin = _e === void 0 ? 10 : _e,\n    defaultSelectedId = props.defaultSelectedId,\n    focusOnHover = props.focusOnHover,\n    mouseLeaveParentSelector = props.mouseLeaveParentSelector,\n    onChange = props.onChange,\n    // eslint-disable-next-line deprecation/deprecation\n    onColorChanged = props.onColorChanged,\n    onCellHovered = props.onCellHovered,\n    onCellFocused = props.onCellFocused,\n    getColorGridCellStyles = props.getColorGridCellStyles,\n    cellHeight = props.cellHeight,\n    cellWidth = props.cellWidth,\n    cellBorderWidth = props.cellBorderWidth,\n    onRenderColorCellContent = props.onRenderColorCellContent;\n  /**\n   *  Add an index to each color cells. Memoizes this so that color cells do not re-render on every update.\n   */\n  var itemsWithIndex = React.useMemo(function () {\n    return colorCells.map(function (item, index) {\n      return __assign(__assign({}, item), {\n        index: index\n      });\n    });\n  }, [colorCells]);\n  var mergedOnChange = React.useCallback(function (ev, newSelectedId) {\n    var _a;\n    // Call both new and old change handlers, and add the extra `color` parameter\n    var newColor = (_a = colorCells.filter(function (c) {\n      return c.id === newSelectedId;\n    })[0]) === null || _a === void 0 ? void 0 : _a.color;\n    onChange === null || onChange === void 0 ? void 0 : onChange(ev, newSelectedId, newColor);\n    onColorChanged === null || onColorChanged === void 0 ? void 0 : onColorChanged(newSelectedId, newColor);\n  }, [onChange, onColorChanged, colorCells]);\n  var _f = useControllableValue(props.selectedId, defaultSelectedId, mergedOnChange),\n    selectedId = _f[0],\n    setSelectedId = _f[1];\n  var classNames = getClassNames(styles, {\n    theme: props.theme,\n    className: className,\n    cellMargin: cellMargin\n  });\n  var gridStyles = {\n    root: classNames.root,\n    tableCell: classNames.tableCell,\n    focusedContainer: classNames.focusedContainer\n  };\n  /**\n   * If there is only one row of cells, they should use radio semantics,\n   * multi-row swatch cells should use grid semantics.\n   * There are two reasons for this:\n   *   1. Radios are a more simple and understandable control, and a better fit for a single-dimensional picker.\n   *   2. Multiple browsers use heuristics to strip table and grid roles from single-row tables with no column headers.\n   */\n  var isSemanticRadio = colorCells.length <= columnCount;\n  /**\n   * When the whole swatchColorPicker is blurred,\n   * make sure to clear the pending focused stated\n   */\n  var onSwatchColorPickerBlur = React.useCallback(function (event) {\n    if (onCellFocused) {\n      internalState.cellFocused = false;\n      onCellFocused(undefined, undefined, event);\n    }\n  }, [internalState, onCellFocused]);\n  /**\n   * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter\n   */\n  var onMouseEnter = React.useCallback(function (ev) {\n    if (!focusOnHover) {\n      return !internalState.isNavigationIdle || !!disabled;\n    }\n    if (internalState.isNavigationIdle && !disabled) {\n      ev.currentTarget.focus();\n    }\n    return true;\n  }, [focusOnHover, internalState, disabled]);\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  var onMouseMove = React.useCallback(function (ev) {\n    if (!focusOnHover) {\n      return !internalState.isNavigationIdle || !!disabled;\n    }\n    var targetElement = ev.currentTarget;\n    // If navigation is idle and the targetElement is the focused element bail out\n    if (internalState.isNavigationIdle && !(document && targetElement === document.activeElement)) {\n      targetElement.focus();\n    }\n    return true;\n  }, [focusOnHover, internalState, disabled]);\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  var onMouseLeave = React.useCallback(function (ev) {\n    var parentSelector = mouseLeaveParentSelector;\n    if (!focusOnHover || !parentSelector || !internalState.isNavigationIdle || disabled) {\n      return;\n    }\n    // Get the elements that math the given selector\n    var elements = document.querySelectorAll(parentSelector);\n    // iterate over the elements return to make sure it is a parent of the target and focus it\n    for (var index = 0; index < elements.length; index += 1) {\n      if (elements[index].contains(ev.currentTarget)) {\n        /**\n         * IE11 focus() method forces parents to scroll to top of element.\n         * Edge and IE expose a setActive() function for focusable divs that\n         * sets the page focus but does not scroll the parent element.\n         */\n        if (elements[index].setActive) {\n          try {\n            elements[index].setActive();\n          } catch (e) {\n            /* no-op */\n          }\n        } else {\n          elements[index].focus();\n        }\n        break;\n      }\n    }\n  }, [disabled, focusOnHover, internalState, mouseLeaveParentSelector]);\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker\n   * NOTE: This will not be triggered if shouldFocusOnHover === true\n   */\n  var onGridCellHovered = React.useCallback(function (item, event) {\n    if (onCellHovered) {\n      item ? onCellHovered(item.id, item.color, event) : onCellHovered(undefined, undefined, event);\n    }\n  }, [onCellHovered]);\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker\n   */\n  var onGridCellFocused = React.useCallback(function (item, event) {\n    if (onCellFocused) {\n      if (item) {\n        internalState.cellFocused = true;\n        return onCellFocused(item.id, item.color, event);\n      } else {\n        internalState.cellFocused = false;\n        return onCellFocused(undefined, undefined, event);\n      }\n    }\n  }, [internalState, onCellFocused]);\n  /**\n   * Handle the click on a cell\n   */\n  var onCellClick = React.useCallback(function (item, event) {\n    if (disabled || item.disabled) {\n      return;\n    }\n    if (item.id !== selectedId) {\n      if (onCellFocused && internalState.cellFocused) {\n        internalState.cellFocused = false;\n        onCellFocused(undefined, undefined, event);\n      }\n      setSelectedId(item.id, event);\n    }\n  }, [disabled, internalState, onCellFocused, selectedId, setSelectedId]);\n  /**\n   * Sets a timeout so we won't process any mouse \"hover\" events\n   * while navigating (via mouseWheel or arrowKeys)\n   */\n  var setNavigationTimeout = React.useCallback(function () {\n    if (!internalState.isNavigationIdle && internalState.navigationIdleTimeoutId !== undefined) {\n      clearTimeout(internalState.navigationIdleTimeoutId);\n      internalState.navigationIdleTimeoutId = undefined;\n    } else {\n      internalState.isNavigationIdle = false;\n    }\n    internalState.navigationIdleTimeoutId = setTimeout(function () {\n      internalState.isNavigationIdle = true;\n    }, internalState.navigationIdleDelay);\n  }, [clearTimeout, internalState, setTimeout]);\n  /**\n   * Callback used to handle KeyCode events\n   */\n  var onKeyDown = React.useCallback(function (ev) {\n    if (\n    // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.up ||\n    // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.down ||\n    // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.left ||\n    // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.right) {\n      setNavigationTimeout();\n    }\n  }, [setNavigationTimeout]);\n  /**\n   * Render a color cell\n   * @param item - The item to render\n   * @returns - Element representing the item\n   */\n  var renderOption = function (item) {\n    return React.createElement(ColorPickerGridCell, {\n      item: item,\n      idPrefix: id,\n      color: item.color,\n      styles: getColorGridCellStyles,\n      disabled: disabled || item.disabled,\n      onClick: onCellClick,\n      onHover: onGridCellHovered,\n      onFocus: onGridCellFocused,\n      selected: selectedId === item.id,\n      circle: cellShape === 'circle',\n      label: item.label,\n      onMouseEnter: onMouseEnter,\n      onMouseMove: onMouseMove,\n      onMouseLeave: onMouseLeave,\n      onWheel: setNavigationTimeout,\n      onKeyDown: onKeyDown,\n      onRenderColorCellContent: onRenderColorCellContent,\n      height: cellHeight,\n      width: cellWidth,\n      borderWidth: cellBorderWidth,\n      isRadio: isSemanticRadio\n    });\n  };\n  if (colorCells.length < 1 || columnCount < 1) {\n    return null;\n  }\n  var onRenderItem = function (item, index) {\n    var _a = props.onRenderColorCell,\n      onRenderColorCell = _a === void 0 ? renderOption : _a;\n    return onRenderColorCell(item, renderOption);\n  };\n  return React.createElement(ButtonGrid, __assign({}, props, {\n    ref: ref,\n    id: id,\n    items: itemsWithIndex,\n    columnCount: columnCount,\n    isSemanticRadio: isSemanticRadio,\n    // eslint-disable-next-line react/jsx-no-bind\n    onRenderItem: onRenderItem,\n    shouldFocusCircularNavigate: shouldFocusCircularNavigate,\n    doNotContainWithinFocusZone: doNotContainWithinFocusZone,\n    onBlur: onSwatchColorPickerBlur,\n    theme: props.theme,\n    styles: gridStyles\n  }));\n});\nSwatchColorPickerBase.displayName = COMPONENT_NAME;","map":{"version":3,"names":["React","classNamesFunction","KeyCodes","ButtonGrid","ColorPickerGridCell","useId","useConst","useSetTimeout","useControllableValue","useWarnings","getClassNames","COMPONENT_NAME","useDebugWarnings","props","process","env","NODE_ENV","name","mutuallyExclusive","focusOnHover","selectedId","deprecations","isControlled","onColorChanged","SwatchColorPickerBase","forwardRef","ref","defaultId","id","internalState","isNavigationIdle","cellFocused","navigationIdleTimeoutId","undefined","navigationIdleDelay","_a","setTimeout","clearTimeout","colorCells","_b","cellShape","columnCount","_c","shouldFocusCircularNavigate","className","_d","disabled","doNotContainWithinFocusZone","styles","_e","cellMargin","defaultSelectedId","mouseLeaveParentSelector","onChange","onCellHovered","onCellFocused","getColorGridCellStyles","cellHeight","cellWidth","cellBorderWidth","onRenderColorCellContent","itemsWithIndex","useMemo","map","item","index","__assign","mergedOnChange","useCallback","ev","newSelectedId","newColor","filter","c","color","_f","setSelectedId","classNames","theme","gridStyles","root","tableCell","focusedContainer","isSemanticRadio","length","onSwatchColorPickerBlur","event","onMouseEnter","currentTarget","focus","onMouseMove","targetElement","document","activeElement","onMouseLeave","parentSelector","elements","querySelectorAll","contains","setActive","e","onGridCellHovered","onGridCellFocused","onCellClick","setNavigationTimeout","onKeyDown","which","up","down","left","right","renderOption","createElement","idPrefix","onClick","onHover","onFocus","selected","circle","label","onWheel","height","width","borderWidth","isRadio","onRenderItem","onRenderColorCell","items","onBlur","displayName"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/components/src/components/SwatchColorPicker/SwatchColorPicker.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNamesFunction, KeyCodes } from '../../Utilities';\nimport { ButtonGrid } from '../../utilities/ButtonGrid/ButtonGrid';\nimport { ColorPickerGridCell } from './ColorPickerGridCell';\nimport { useId, useConst, useSetTimeout, useControllableValue, useWarnings } from '@fluentui/react-hooks';\nimport type {\n  ISwatchColorPickerProps,\n  ISwatchColorPickerStyleProps,\n  ISwatchColorPickerStyles,\n} from './SwatchColorPicker.types';\nimport type { IColorCellProps } from './ColorPickerGridCell.types';\nimport type { IButtonGridProps } from '../../utilities/ButtonGrid/ButtonGrid.types';\n\ninterface ISwatchColorPickerInternalState {\n  isNavigationIdle: boolean;\n  cellFocused: boolean;\n  navigationIdleTimeoutId: number | undefined;\n  navigationIdleDelay: number;\n}\n\nconst getClassNames = classNamesFunction<ISwatchColorPickerStyleProps, ISwatchColorPickerStyles>();\n\nconst COMPONENT_NAME = 'SwatchColorPicker';\n\nfunction useDebugWarnings(props: ISwatchColorPickerProps) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      mutuallyExclusive: { focusOnHover: 'onHover', selectedId: 'defaultSelectedId' },\n      deprecations: { isControlled: \"selectedId' or 'defaultSelectedId\", onColorChanged: 'onChange' },\n    });\n  }\n}\n\nexport const SwatchColorPickerBase: React.FunctionComponent<ISwatchColorPickerProps> = React.forwardRef<\n  HTMLElement,\n  ISwatchColorPickerProps\n>((props, ref) => {\n  const defaultId = useId('swatchColorPicker');\n  const id = props.id || defaultId;\n\n  const internalState = useConst<ISwatchColorPickerInternalState>({\n    isNavigationIdle: true,\n    cellFocused: false,\n    navigationIdleTimeoutId: undefined,\n    navigationIdleDelay: 250,\n  });\n\n  const { setTimeout, clearTimeout } = useSetTimeout();\n\n  useDebugWarnings(props);\n\n  const {\n    colorCells,\n    cellShape = 'circle',\n    columnCount,\n    shouldFocusCircularNavigate = true,\n    className,\n    disabled = false,\n    doNotContainWithinFocusZone,\n    styles,\n    cellMargin = 10,\n    defaultSelectedId,\n    focusOnHover,\n    mouseLeaveParentSelector,\n    onChange,\n    // eslint-disable-next-line deprecation/deprecation\n    onColorChanged,\n    onCellHovered,\n    onCellFocused,\n    getColorGridCellStyles,\n    cellHeight,\n    cellWidth,\n    cellBorderWidth,\n    onRenderColorCellContent,\n  } = props;\n\n  /**\n   *  Add an index to each color cells. Memoizes this so that color cells do not re-render on every update.\n   */\n  const itemsWithIndex = React.useMemo(() => {\n    return colorCells.map((item, index) => {\n      return { ...item, index };\n    });\n  }, [colorCells]);\n\n  const mergedOnChange = React.useCallback(\n    (ev: React.FormEvent<HTMLElement>, newSelectedId: string | undefined) => {\n      // Call both new and old change handlers, and add the extra `color` parameter\n      const newColor = colorCells.filter(c => c.id === newSelectedId)[0]?.color;\n      onChange?.(ev, newSelectedId, newColor);\n      onColorChanged?.(newSelectedId, newColor);\n    },\n    [onChange, onColorChanged, colorCells],\n  );\n\n  const [selectedId, setSelectedId] = useControllableValue(props.selectedId, defaultSelectedId, mergedOnChange);\n\n  const classNames = getClassNames(styles!, {\n    theme: props.theme!,\n    className,\n    cellMargin,\n  });\n\n  const gridStyles = {\n    root: classNames.root,\n    tableCell: classNames.tableCell,\n    focusedContainer: classNames.focusedContainer,\n  };\n\n  /**\n   * If there is only one row of cells, they should use radio semantics,\n   * multi-row swatch cells should use grid semantics.\n   * There are two reasons for this:\n   *   1. Radios are a more simple and understandable control, and a better fit for a single-dimensional picker.\n   *   2. Multiple browsers use heuristics to strip table and grid roles from single-row tables with no column headers.\n   */\n  const isSemanticRadio = colorCells.length <= columnCount;\n\n  /**\n   * When the whole swatchColorPicker is blurred,\n   * make sure to clear the pending focused stated\n   */\n  const onSwatchColorPickerBlur = React.useCallback(\n    (event?: React.FocusEvent<HTMLButtonElement>): void => {\n      if (onCellFocused) {\n        internalState.cellFocused = false;\n        onCellFocused(undefined, undefined, event);\n      }\n    },\n    [internalState, onCellFocused],\n  );\n\n  /**\n   * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter\n   */\n  const onMouseEnter = React.useCallback(\n    (ev: React.MouseEvent<HTMLButtonElement>): boolean => {\n      if (!focusOnHover) {\n        return !internalState.isNavigationIdle || !!disabled;\n      }\n      if (internalState.isNavigationIdle && !disabled) {\n        ev.currentTarget.focus();\n      }\n      return true;\n    },\n    [focusOnHover, internalState, disabled],\n  );\n\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  const onMouseMove = React.useCallback(\n    (ev: React.MouseEvent<HTMLButtonElement>): boolean => {\n      if (!focusOnHover) {\n        return !internalState.isNavigationIdle || !!disabled;\n      }\n\n      const targetElement = ev.currentTarget as HTMLElement;\n\n      // If navigation is idle and the targetElement is the focused element bail out\n      if (internalState.isNavigationIdle && !(document && targetElement === (document.activeElement as HTMLElement))) {\n        targetElement.focus();\n      }\n\n      return true;\n    },\n    [focusOnHover, internalState, disabled],\n  );\n\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  const onMouseLeave = React.useCallback(\n    (ev: React.MouseEvent<HTMLButtonElement>): void => {\n      const parentSelector = mouseLeaveParentSelector;\n\n      if (!focusOnHover || !parentSelector || !internalState.isNavigationIdle || disabled) {\n        return;\n      }\n\n      // Get the elements that math the given selector\n      const elements = document.querySelectorAll(parentSelector);\n\n      // iterate over the elements return to make sure it is a parent of the target and focus it\n      for (let index = 0; index < elements.length; index += 1) {\n        if (elements[index].contains(ev.currentTarget)) {\n          /**\n           * IE11 focus() method forces parents to scroll to top of element.\n           * Edge and IE expose a setActive() function for focusable divs that\n           * sets the page focus but does not scroll the parent element.\n           */\n          if ((elements[index] as any).setActive) {\n            try {\n              (elements[index] as any).setActive();\n            } catch (e) {\n              /* no-op */\n            }\n          } else {\n            (elements[index] as HTMLElement).focus();\n          }\n\n          break;\n        }\n      }\n    },\n    [disabled, focusOnHover, internalState, mouseLeaveParentSelector],\n  );\n\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker\n   * NOTE: This will not be triggered if shouldFocusOnHover === true\n   */\n  const onGridCellHovered = React.useCallback(\n    (item?: IColorCellProps, event?: React.MouseEvent<HTMLButtonElement>): void => {\n      if (onCellHovered) {\n        item ? onCellHovered(item.id, item.color, event) : onCellHovered(undefined, undefined, event);\n      }\n    },\n    [onCellHovered],\n  );\n\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker\n   */\n  const onGridCellFocused = React.useCallback(\n    (item?: IColorCellProps, event?: React.FormEvent<HTMLButtonElement>): void => {\n      if (onCellFocused) {\n        if (item) {\n          internalState.cellFocused = true;\n          return onCellFocused(item.id, item.color, event);\n        } else {\n          internalState.cellFocused = false;\n          return onCellFocused(undefined, undefined, event);\n        }\n      }\n    },\n    [internalState, onCellFocused],\n  );\n\n  /**\n   * Handle the click on a cell\n   */\n  const onCellClick = React.useCallback(\n    (item: IColorCellProps, event?: React.MouseEvent<HTMLButtonElement>): void => {\n      if (disabled || item.disabled) {\n        return;\n      }\n\n      if (item.id !== selectedId) {\n        if (onCellFocused && internalState.cellFocused) {\n          internalState.cellFocused = false;\n          onCellFocused(undefined, undefined, event);\n        }\n        setSelectedId(item.id, event);\n      }\n    },\n    [disabled, internalState, onCellFocused, selectedId, setSelectedId],\n  );\n\n  /**\n   * Sets a timeout so we won't process any mouse \"hover\" events\n   * while navigating (via mouseWheel or arrowKeys)\n   */\n  const setNavigationTimeout = React.useCallback(() => {\n    if (!internalState.isNavigationIdle && internalState.navigationIdleTimeoutId !== undefined) {\n      clearTimeout(internalState.navigationIdleTimeoutId);\n      internalState.navigationIdleTimeoutId = undefined;\n    } else {\n      internalState.isNavigationIdle = false;\n    }\n\n    internalState.navigationIdleTimeoutId = setTimeout(() => {\n      internalState.isNavigationIdle = true;\n    }, internalState.navigationIdleDelay);\n  }, [clearTimeout, internalState, setTimeout]);\n\n  /**\n   * Callback used to handle KeyCode events\n   */\n  const onKeyDown = React.useCallback(\n    (ev: React.KeyboardEvent<HTMLButtonElement>): void => {\n      if (\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.up ||\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.down ||\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.left ||\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.right\n      ) {\n        setNavigationTimeout();\n      }\n    },\n    [setNavigationTimeout],\n  );\n\n  /**\n   * Render a color cell\n   * @param item - The item to render\n   * @returns - Element representing the item\n   */\n  const renderOption = (item: IColorCellProps): JSX.Element => {\n    return (\n      <ColorPickerGridCell\n        item={item}\n        idPrefix={id}\n        color={item.color}\n        styles={getColorGridCellStyles}\n        disabled={disabled || item.disabled}\n        onClick={onCellClick}\n        onHover={onGridCellHovered}\n        onFocus={onGridCellFocused}\n        selected={selectedId === item.id}\n        circle={cellShape === 'circle'}\n        label={item.label}\n        onMouseEnter={onMouseEnter}\n        onMouseMove={onMouseMove}\n        onMouseLeave={onMouseLeave}\n        onWheel={setNavigationTimeout}\n        onKeyDown={onKeyDown}\n        onRenderColorCellContent={onRenderColorCellContent}\n        height={cellHeight}\n        width={cellWidth}\n        borderWidth={cellBorderWidth}\n        isRadio={isSemanticRadio}\n      />\n    );\n  };\n\n  if (colorCells.length < 1 || columnCount < 1) {\n    return null;\n  }\n\n  const onRenderItem = (item: IColorCellProps, index: number): JSX.Element => {\n    const { onRenderColorCell = renderOption } = props;\n    return onRenderColorCell(item, renderOption) as JSX.Element;\n  };\n  return (\n    <ButtonGrid\n      {...(props as unknown as IButtonGridProps)}\n      ref={ref}\n      id={id}\n      items={itemsWithIndex}\n      columnCount={columnCount}\n      isSemanticRadio={isSemanticRadio}\n      // eslint-disable-next-line react/jsx-no-bind\n      onRenderItem={onRenderItem}\n      shouldFocusCircularNavigate={shouldFocusCircularNavigate}\n      doNotContainWithinFocusZone={doNotContainWithinFocusZone}\n      onBlur={onSwatchColorPickerBlur}\n      theme={props.theme!}\n      styles={gridStyles}\n    />\n  );\n});\n\nSwatchColorPickerBase.displayName = COMPONENT_NAME;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}