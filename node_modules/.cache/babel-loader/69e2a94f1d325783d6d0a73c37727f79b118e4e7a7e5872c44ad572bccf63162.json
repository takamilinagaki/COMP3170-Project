{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { KeyCodes } from '../../Utilities';\nimport { TimeConstants, addMinutes, formatTimeString, ceilMinuteToIncrement, getDateFromTimeSelection } from '@fluentui/date-time-utilities';\nimport { ComboBox } from '../../ComboBox';\nimport { format } from '../../Utilities';\nimport { useControllableValue, useConst } from '@fluentui/react-hooks';\nvar REGEX_SHOW_SECONDS_HOUR_12 = /^((1[0-2]|0?[1-9]):([0-5][0-9]):([0-5][0-9])\\s([AaPp][Mm]))$/;\nvar REGEX_HIDE_SECONDS_HOUR_12 = /^((1[0-2]|0?[1-9]):[0-5][0-9]\\s([AaPp][Mm]))$/;\nvar REGEX_SHOW_SECONDS_HOUR_24 = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/;\nvar REGEX_HIDE_SECONDS_HOUR_24 = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;\nvar TIME_LOWER_BOUND = 0;\nvar TIME_UPPER_BOUND = 23;\nvar getDefaultStrings = function (useHour12, showSeconds) {\n  var hourUnits = useHour12 ? '12-hour' : '24-hour';\n  var timeFormat = \"hh:mm\".concat(showSeconds ? ':ss' : '').concat(useHour12 ? ' AP' : '');\n  var invalidInputErrorMessage = \"Enter a valid time in the \".concat(hourUnits, \" format: \").concat(timeFormat);\n  var timeOutOfBoundsErrorMessage = \"Please enter a time within the range of {0} and {1}\";\n  return {\n    invalidInputErrorMessage: invalidInputErrorMessage,\n    timeOutOfBoundsErrorMessage: timeOutOfBoundsErrorMessage\n  };\n};\n/**\n * {@docCategory TimePicker}\n */\nexport var TimePicker = function (_a) {\n  var label = _a.label,\n    _b = _a.increments,\n    increments = _b === void 0 ? 30 : _b,\n    _c = _a.showSeconds,\n    showSeconds = _c === void 0 ? false : _c,\n    _d = _a.allowFreeform,\n    allowFreeform = _d === void 0 ? true : _d,\n    _e = _a.useHour12,\n    useHour12 = _e === void 0 ? false : _e,\n    timeRange = _a.timeRange,\n    _f = _a.strings,\n    strings = _f === void 0 ? getDefaultStrings(useHour12, showSeconds) : _f,\n    defaultValue = _a.defaultValue,\n    value = _a.value,\n    dateAnchor = _a.dateAnchor,\n    onChange = _a.onChange,\n    onFormatDate = _a.onFormatDate,\n    onValidateUserInput = _a.onValidateUserInput,\n    onValidationResult = _a.onValidationResult,\n    rest = __rest(_a, [\"label\", \"increments\", \"showSeconds\", \"allowFreeform\", \"useHour12\", \"timeRange\", \"strings\", \"defaultValue\", \"value\", \"dateAnchor\", \"onChange\", \"onFormatDate\", \"onValidateUserInput\", \"onValidationResult\"]);\n  var _g = React.useState(''),\n    comboBoxText = _g[0],\n    setComboBoxText = _g[1];\n  var _h = React.useState(),\n    selectedKey = _h[0],\n    setSelectedKey = _h[1];\n  var _j = React.useState(''),\n    errorMessage = _j[0],\n    setErrorMessage = _j[1];\n  var fallbackDateAnchor = useConst(new Date());\n  var _k = useControllableValue(value, defaultValue),\n    selectedTime = _k[0],\n    setSelectedTime = _k[1];\n  var optionsCount = getDropdownOptionsCount(increments, timeRange);\n  var internalDateAnchor = dateAnchor || value || defaultValue || fallbackDateAnchor;\n  var dateStartAnchor = React.useMemo(function () {\n    return getDateAnchor(internalDateAnchor, 'start', increments, timeRange);\n  }, [internalDateAnchor, increments, timeRange]);\n  var dateEndAnchor = React.useMemo(function () {\n    return getDateAnchor(internalDateAnchor, 'end', increments, timeRange);\n  }, [internalDateAnchor, increments, timeRange]);\n  var timePickerOptions = React.useMemo(function () {\n    var optionsList = Array(optionsCount);\n    for (var i = 0; i < optionsCount; i++) {\n      optionsList[i] = 0;\n    }\n    return optionsList.map(function (_, index) {\n      var option = addMinutes(dateStartAnchor, increments * index);\n      option.setSeconds(0);\n      var formattedTimeString = formatTimeString(option, showSeconds, useHour12);\n      var optionText = onFormatDate ? onFormatDate(option) : formattedTimeString;\n      return {\n        key: formattedTimeString,\n        text: optionText,\n        data: option\n      };\n    });\n  }, [dateStartAnchor, increments, optionsCount, showSeconds, onFormatDate, useHour12]);\n  React.useEffect(function () {\n    if (selectedTime && !isNaN(selectedTime.valueOf())) {\n      var formattedTimeString_1 = formatTimeString(selectedTime, showSeconds, useHour12);\n      var comboboxOption = timePickerOptions.find(function (option) {\n        return option.key === formattedTimeString_1;\n      });\n      setSelectedKey(comboboxOption === null || comboboxOption === void 0 ? void 0 : comboboxOption.key);\n      setComboBoxText(comboboxOption ? comboboxOption.text : formattedTimeString_1);\n    } else {\n      setSelectedKey(null);\n    }\n  }, [selectedTime, timePickerOptions, onFormatDate, showSeconds, useHour12]);\n  var onInputChange = React.useCallback(function (ev, option, _index, input) {\n    var validateUserInput = function (userInput) {\n      var errorMessageToDisplay = '';\n      var regex;\n      if (useHour12) {\n        regex = showSeconds ? REGEX_SHOW_SECONDS_HOUR_12 : REGEX_HIDE_SECONDS_HOUR_12;\n      } else {\n        regex = showSeconds ? REGEX_SHOW_SECONDS_HOUR_24 : REGEX_HIDE_SECONDS_HOUR_24;\n      }\n      if (!regex.test(userInput)) {\n        errorMessageToDisplay = strings.invalidInputErrorMessage;\n      } else if (timeRange && strings.timeOutOfBoundsErrorMessage) {\n        var optionDate = getDateFromTimeSelection(useHour12, dateStartAnchor, userInput);\n        if (optionDate < dateStartAnchor || optionDate > dateEndAnchor) {\n          errorMessageToDisplay = format(strings.timeOutOfBoundsErrorMessage, dateStartAnchor.toString(), dateEndAnchor.toString());\n        }\n      }\n      return errorMessageToDisplay;\n    };\n    var errorMessageToDisplay = '';\n    if (input) {\n      if (allowFreeform && !option) {\n        if (!onFormatDate) {\n          // Validate only if user did not add onFormatDate\n          errorMessageToDisplay = validateUserInput(input);\n        } else {\n          // Use user provided validation if onFormatDate is provided\n          if (onValidateUserInput) {\n            errorMessageToDisplay = onValidateUserInput(input);\n          }\n        }\n      }\n    }\n    if (onValidationResult && errorMessage !== errorMessageToDisplay) {\n      // only call onValidationResult if stored errorMessage state value is different from latest error message\n      onValidationResult(ev, {\n        errorMessage: errorMessageToDisplay\n      });\n    }\n    var changedTime;\n    if (errorMessageToDisplay || input !== undefined && !input.length) {\n      var timeSelection = input || (option === null || option === void 0 ? void 0 : option.text) || '';\n      setComboBoxText(timeSelection);\n      setSelectedTime(errorMessageToDisplay ? new Date('invalid') : undefined);\n      changedTime = new Date('invalid');\n    } else {\n      var updatedTime = void 0;\n      if ((option === null || option === void 0 ? void 0 : option.data) instanceof Date) {\n        updatedTime = option.data;\n      } else {\n        var timeSelection = (option === null || option === void 0 ? void 0 : option.key) || input || '';\n        updatedTime = getDateFromTimeSelection(useHour12, dateStartAnchor, timeSelection);\n      }\n      setSelectedTime(updatedTime);\n      changedTime = updatedTime;\n    }\n    onChange === null || onChange === void 0 ? void 0 : onChange(ev, changedTime);\n    setErrorMessage(errorMessageToDisplay);\n  }, [timeRange, dateStartAnchor, dateEndAnchor, allowFreeform, onFormatDate, onValidateUserInput, showSeconds, useHour12, strings.invalidInputErrorMessage, strings.timeOutOfBoundsErrorMessage, setSelectedTime, onValidationResult, onChange, errorMessage]);\n  var evaluatePressedKey = function (event) {\n    // eslint-disable-next-line deprecation/deprecation\n    var charCode = event.charCode;\n    if (!onFormatDate &&\n    // Only permit input of digits, space, colon, A/P/M characters\n    !(charCode >= KeyCodes.zero && charCode <= KeyCodes.colon || charCode === KeyCodes.space || charCode === KeyCodes.a || charCode === KeyCodes.m || charCode === KeyCodes.p)) {\n      event.preventDefault();\n    }\n  };\n  return React.createElement(ComboBox, __assign({}, rest, {\n    allowFreeform: allowFreeform,\n    selectedKey: selectedKey,\n    label: label,\n    errorMessage: errorMessage,\n    options: timePickerOptions,\n    onChange: onInputChange,\n    text: comboBoxText,\n    //eslint-disable-next-line\n    onKeyPress: evaluatePressedKey,\n    useComboBoxAsMenuWidth: true\n  }));\n};\nTimePicker.displayName = 'TimePicker';\nvar getDateAnchor = function (internalDateAnchor, startEnd, increments, timeRange) {\n  var clampedDateAnchor = new Date(internalDateAnchor.getTime());\n  if (timeRange) {\n    var clampedTimeRange = clampTimeRange(timeRange);\n    var timeRangeHours = startEnd === 'start' ? clampedTimeRange.start : clampedTimeRange.end;\n    if (clampedDateAnchor.getHours() !== timeRangeHours) {\n      clampedDateAnchor.setHours(timeRangeHours);\n    }\n  } else if (startEnd === 'end') {\n    clampedDateAnchor.setDate(clampedDateAnchor.getDate() + 1);\n  }\n  clampedDateAnchor.setMinutes(0);\n  clampedDateAnchor.setSeconds(0);\n  clampedDateAnchor.setMilliseconds(0);\n  return ceilMinuteToIncrement(clampedDateAnchor, increments);\n};\nvar clampTimeRange = function (timeRange) {\n  return {\n    start: Math.min(Math.max(timeRange.start, TIME_LOWER_BOUND), TIME_UPPER_BOUND),\n    end: Math.min(Math.max(timeRange.end, TIME_LOWER_BOUND), TIME_UPPER_BOUND)\n  };\n};\nvar getHoursInRange = function (timeRange) {\n  var hoursInRange = TimeConstants.HoursInOneDay;\n  if (timeRange) {\n    var clampedTimeRange = clampTimeRange(timeRange);\n    if (clampedTimeRange.start > clampedTimeRange.end) {\n      hoursInRange = TimeConstants.HoursInOneDay - timeRange.start - timeRange.end;\n    } else if (timeRange.end > timeRange.start) {\n      hoursInRange = timeRange.end - timeRange.start;\n    }\n  }\n  return hoursInRange;\n};\nvar getDropdownOptionsCount = function (increments, timeRange) {\n  var hoursInRange = getHoursInRange(timeRange);\n  return Math.floor(TimeConstants.MinutesInOneHour * hoursInRange / increments);\n};","map":{"version":3,"names":["React","KeyCodes","TimeConstants","addMinutes","formatTimeString","ceilMinuteToIncrement","getDateFromTimeSelection","ComboBox","format","useControllableValue","useConst","REGEX_SHOW_SECONDS_HOUR_12","REGEX_HIDE_SECONDS_HOUR_12","REGEX_SHOW_SECONDS_HOUR_24","REGEX_HIDE_SECONDS_HOUR_24","TIME_LOWER_BOUND","TIME_UPPER_BOUND","getDefaultStrings","useHour12","showSeconds","hourUnits","timeFormat","concat","invalidInputErrorMessage","timeOutOfBoundsErrorMessage","TimePicker","_a","label","_b","increments","_c","_d","allowFreeform","_e","timeRange","_f","strings","defaultValue","value","dateAnchor","onChange","onFormatDate","onValidateUserInput","onValidationResult","rest","__rest","_g","useState","comboBoxText","setComboBoxText","_h","selectedKey","setSelectedKey","_j","errorMessage","setErrorMessage","fallbackDateAnchor","Date","_k","selectedTime","setSelectedTime","optionsCount","getDropdownOptionsCount","internalDateAnchor","dateStartAnchor","useMemo","getDateAnchor","dateEndAnchor","timePickerOptions","optionsList","Array","i","map","_","index","option","setSeconds","formattedTimeString","optionText","key","text","data","useEffect","isNaN","valueOf","formattedTimeString_1","comboboxOption","find","onInputChange","useCallback","ev","_index","input","validateUserInput","userInput","errorMessageToDisplay","regex","test","optionDate","toString","changedTime","undefined","length","timeSelection","updatedTime","evaluatePressedKey","event","charCode","zero","colon","space","a","m","p","preventDefault","createElement","__assign","options","onKeyPress","useComboBoxAsMenuWidth","displayName","startEnd","clampedDateAnchor","getTime","clampedTimeRange","clampTimeRange","timeRangeHours","start","end","getHours","setHours","setDate","getDate","setMinutes","setMilliseconds","Math","min","max","getHoursInRange","hoursInRange","HoursInOneDay","floor","MinutesInOneHour"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/components/src/components/TimePicker/TimePicker.tsx"],"sourcesContent":["import * as React from 'react';\nimport { KeyCodes } from '../../Utilities';\nimport {\n  TimeConstants,\n  addMinutes,\n  formatTimeString,\n  ceilMinuteToIncrement,\n  getDateFromTimeSelection,\n} from '@fluentui/date-time-utilities';\nimport { ComboBox } from '../../ComboBox';\nimport { format } from '../../Utilities';\nimport type { IComboBox, IComboBoxOption } from '../../ComboBox';\nimport type { ITimePickerProps, ITimeRange, ITimePickerStrings } from './TimePicker.types';\nimport { useControllableValue, useConst } from '@fluentui/react-hooks';\n\nconst REGEX_SHOW_SECONDS_HOUR_12 = /^((1[0-2]|0?[1-9]):([0-5][0-9]):([0-5][0-9])\\s([AaPp][Mm]))$/;\nconst REGEX_HIDE_SECONDS_HOUR_12 = /^((1[0-2]|0?[1-9]):[0-5][0-9]\\s([AaPp][Mm]))$/;\nconst REGEX_SHOW_SECONDS_HOUR_24 = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/;\nconst REGEX_HIDE_SECONDS_HOUR_24 = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;\n\nconst TIME_LOWER_BOUND = 0;\nconst TIME_UPPER_BOUND = 23;\n\nconst getDefaultStrings = (useHour12: boolean, showSeconds: boolean): ITimePickerStrings => {\n  const hourUnits = useHour12 ? '12-hour' : '24-hour';\n  const timeFormat = `hh:mm${showSeconds ? ':ss' : ''}${useHour12 ? ' AP' : ''}`;\n  const invalidInputErrorMessage = `Enter a valid time in the ${hourUnits} format: ${timeFormat}`;\n  const timeOutOfBoundsErrorMessage = `Please enter a time within the range of {0} and {1}`;\n\n  return {\n    invalidInputErrorMessage,\n    timeOutOfBoundsErrorMessage,\n  };\n};\n\n/**\n * {@docCategory TimePicker}\n */\nexport const TimePicker: React.FunctionComponent<ITimePickerProps> = ({\n  label,\n  increments = 30,\n  showSeconds = false,\n  allowFreeform = true,\n  useHour12 = false,\n  timeRange,\n  strings = getDefaultStrings(useHour12, showSeconds),\n  defaultValue,\n  value,\n  dateAnchor,\n  onChange,\n  onFormatDate,\n  onValidateUserInput,\n  onValidationResult,\n  ...rest\n}: ITimePickerProps) => {\n  const [comboBoxText, setComboBoxText] = React.useState<string>('');\n  const [selectedKey, setSelectedKey] = React.useState<string | number | undefined | null>();\n  const [errorMessage, setErrorMessage] = React.useState<string>('');\n\n  const fallbackDateAnchor = useConst(new Date());\n\n  const [selectedTime, setSelectedTime] = useControllableValue(value, defaultValue);\n\n  const optionsCount = getDropdownOptionsCount(increments, timeRange);\n\n  const internalDateAnchor = dateAnchor || value || defaultValue || fallbackDateAnchor;\n\n  const dateStartAnchor = React.useMemo(\n    () => getDateAnchor(internalDateAnchor, 'start', increments, timeRange),\n    [internalDateAnchor, increments, timeRange],\n  );\n\n  const dateEndAnchor = React.useMemo(\n    () => getDateAnchor(internalDateAnchor, 'end', increments, timeRange),\n    [internalDateAnchor, increments, timeRange],\n  );\n\n  const timePickerOptions: IComboBoxOption[] = React.useMemo(() => {\n    const optionsList = Array(optionsCount);\n    for (let i = 0; i < optionsCount; i++) {\n      optionsList[i] = 0;\n    }\n\n    return optionsList.map((_, index) => {\n      const option: Date = addMinutes(dateStartAnchor, increments * index);\n      option.setSeconds(0);\n      const formattedTimeString = formatTimeString(option, showSeconds, useHour12);\n      const optionText = onFormatDate ? onFormatDate(option) : formattedTimeString;\n      return {\n        key: formattedTimeString,\n        text: optionText,\n        data: option,\n      };\n    });\n  }, [dateStartAnchor, increments, optionsCount, showSeconds, onFormatDate, useHour12]);\n\n  React.useEffect(() => {\n    if (selectedTime && !isNaN(selectedTime.valueOf())) {\n      const formattedTimeString = formatTimeString(selectedTime, showSeconds, useHour12);\n      const comboboxOption = timePickerOptions.find((option: IComboBoxOption) => option.key === formattedTimeString);\n      setSelectedKey(comboboxOption?.key);\n      setComboBoxText(comboboxOption ? comboboxOption.text : formattedTimeString);\n    } else {\n      setSelectedKey(null);\n    }\n  }, [selectedTime, timePickerOptions, onFormatDate, showSeconds, useHour12]);\n\n  const onInputChange = React.useCallback(\n    (ev: React.FormEvent<IComboBox>, option?: IComboBoxOption, _index?: number, input?: string): void => {\n      const validateUserInput = (userInput: string): string => {\n        let errorMessageToDisplay = '';\n        let regex: RegExp;\n        if (useHour12) {\n          regex = showSeconds ? REGEX_SHOW_SECONDS_HOUR_12 : REGEX_HIDE_SECONDS_HOUR_12;\n        } else {\n          regex = showSeconds ? REGEX_SHOW_SECONDS_HOUR_24 : REGEX_HIDE_SECONDS_HOUR_24;\n        }\n        if (!regex.test(userInput)) {\n          errorMessageToDisplay = strings.invalidInputErrorMessage;\n        } else if (timeRange && strings.timeOutOfBoundsErrorMessage) {\n          const optionDate: Date = getDateFromTimeSelection(useHour12, dateStartAnchor, userInput);\n          if (optionDate < dateStartAnchor || optionDate > dateEndAnchor) {\n            errorMessageToDisplay = format(\n              strings.timeOutOfBoundsErrorMessage,\n              dateStartAnchor.toString(),\n              dateEndAnchor.toString(),\n            );\n          }\n        }\n        return errorMessageToDisplay;\n      };\n\n      let errorMessageToDisplay = '';\n      if (input) {\n        if (allowFreeform && !option) {\n          if (!onFormatDate) {\n            // Validate only if user did not add onFormatDate\n            errorMessageToDisplay = validateUserInput(input);\n          } else {\n            // Use user provided validation if onFormatDate is provided\n            if (onValidateUserInput) {\n              errorMessageToDisplay = onValidateUserInput(input);\n            }\n          }\n        }\n      }\n\n      if (onValidationResult && errorMessage !== errorMessageToDisplay) {\n        // only call onValidationResult if stored errorMessage state value is different from latest error message\n        onValidationResult(ev, { errorMessage: errorMessageToDisplay });\n      }\n\n      let changedTime: Date;\n      if (errorMessageToDisplay || (input !== undefined && !input.length)) {\n        const timeSelection = input || option?.text || '';\n        setComboBoxText(timeSelection);\n        setSelectedTime(errorMessageToDisplay ? new Date('invalid') : undefined);\n        changedTime = new Date('invalid');\n      } else {\n        let updatedTime;\n        if (option?.data instanceof Date) {\n          updatedTime = option.data;\n        } else {\n          const timeSelection = (option?.key as string) || input || '';\n          updatedTime = getDateFromTimeSelection(useHour12, dateStartAnchor, timeSelection);\n        }\n        setSelectedTime(updatedTime);\n        changedTime = updatedTime;\n      }\n\n      onChange?.(ev, changedTime);\n      setErrorMessage(errorMessageToDisplay);\n    },\n    [\n      timeRange,\n      dateStartAnchor,\n      dateEndAnchor,\n      allowFreeform,\n      onFormatDate,\n      onValidateUserInput,\n      showSeconds,\n      useHour12,\n      strings.invalidInputErrorMessage,\n      strings.timeOutOfBoundsErrorMessage,\n      setSelectedTime,\n      onValidationResult,\n      onChange,\n      errorMessage,\n    ],\n  );\n\n  const evaluatePressedKey = (event: React.KeyboardEvent<IComboBox>) => {\n    // eslint-disable-next-line deprecation/deprecation\n    const charCode = event.charCode;\n    if (\n      !onFormatDate &&\n      // Only permit input of digits, space, colon, A/P/M characters\n      !(\n        (charCode >= KeyCodes.zero && charCode <= KeyCodes.colon) ||\n        charCode === KeyCodes.space ||\n        charCode === KeyCodes.a ||\n        charCode === KeyCodes.m ||\n        charCode === KeyCodes.p\n      )\n    ) {\n      event.preventDefault();\n    }\n  };\n\n  return (\n    <ComboBox\n      {...rest}\n      allowFreeform={allowFreeform}\n      selectedKey={selectedKey}\n      label={label}\n      errorMessage={errorMessage}\n      options={timePickerOptions}\n      onChange={onInputChange}\n      text={comboBoxText}\n      //eslint-disable-next-line\n      onKeyPress={evaluatePressedKey}\n      useComboBoxAsMenuWidth\n    />\n  );\n};\nTimePicker.displayName = 'TimePicker';\n\nconst getDateAnchor = (\n  internalDateAnchor: Date,\n  startEnd: 'start' | 'end',\n  increments: number,\n  timeRange?: ITimeRange,\n) => {\n  const clampedDateAnchor = new Date(internalDateAnchor.getTime());\n  if (timeRange) {\n    const clampedTimeRange = clampTimeRange(timeRange);\n    const timeRangeHours = startEnd === 'start' ? clampedTimeRange.start : clampedTimeRange.end;\n    if (clampedDateAnchor.getHours() !== timeRangeHours) {\n      clampedDateAnchor.setHours(timeRangeHours);\n    }\n  } else if (startEnd === 'end') {\n    clampedDateAnchor.setDate(clampedDateAnchor.getDate() + 1);\n  }\n  clampedDateAnchor.setMinutes(0);\n  clampedDateAnchor.setSeconds(0);\n  clampedDateAnchor.setMilliseconds(0);\n\n  return ceilMinuteToIncrement(clampedDateAnchor, increments);\n};\n\nconst clampTimeRange = (timeRange: ITimeRange): ITimeRange => {\n  return {\n    start: Math.min(Math.max(timeRange.start, TIME_LOWER_BOUND), TIME_UPPER_BOUND),\n    end: Math.min(Math.max(timeRange.end, TIME_LOWER_BOUND), TIME_UPPER_BOUND),\n  };\n};\n\nconst getHoursInRange = (timeRange: ITimeRange | undefined) => {\n  let hoursInRange = TimeConstants.HoursInOneDay;\n  if (timeRange) {\n    const clampedTimeRange = clampTimeRange(timeRange);\n    if (clampedTimeRange.start > clampedTimeRange.end) {\n      hoursInRange = TimeConstants.HoursInOneDay - timeRange.start - timeRange.end;\n    } else if (timeRange.end > timeRange.start) {\n      hoursInRange = timeRange.end - timeRange.start;\n    }\n  }\n\n  return hoursInRange;\n};\n\nconst getDropdownOptionsCount = (increments: number, timeRange: ITimeRange | undefined) => {\n  const hoursInRange = getHoursInRange(timeRange);\n  return Math.floor((TimeConstants.MinutesInOneHour * hoursInRange) / increments);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}