{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport { EventGroup, getId } from '../../Utilities';\nimport { KeytipEvents } from '../../utilities/keytips/KeytipConstants';\n/**\n * This class is responsible for handling registering, updating, and unregistering of keytips\n */\nvar KeytipManager = /** @class */function () {\n  function KeytipManager() {\n    this.keytips = {};\n    this.persistedKeytips = {};\n    this.sequenceMapping = {};\n    // This is (and should be) updated and kept in sync\n    // with the inKeytipMode in KeytipLayer.\n    this.inKeytipMode = false;\n    // Boolean that gets checked before entering keytip mode by the KeytipLayer\n    // Used for an override in special cases (e.g. Disable entering keytip mode when a modal is shown)\n    this.shouldEnterKeytipMode = true;\n    // Boolean to indicate whether to delay firing an event to update subscribers of\n    // keytip data changed.\n    this.delayUpdatingKeytipChange = false;\n  }\n  /**\n   * Static function to get singleton KeytipManager instance\n   *\n   * @returns Singleton KeytipManager instance\n   */\n  KeytipManager.getInstance = function () {\n    return this._instance;\n  };\n  /**\n   * Initialization code to set set parameters to define\n   * how the KeytipManager handles keytip data.\n   *\n   * @param delayUpdatingKeytipChange - T/F if we should delay notifiying keytip subscribers\n   * of keytip changes\n   */\n  KeytipManager.prototype.init = function (delayUpdatingKeytipChange) {\n    this.delayUpdatingKeytipChange = delayUpdatingKeytipChange;\n  };\n  /**\n   * Registers a keytip\n   *\n   * @param keytipProps - Keytip to register\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   * @returns Unique ID for this keytip\n   */\n  KeytipManager.prototype.register = function (keytipProps, persisted) {\n    if (persisted === void 0) {\n      persisted = false;\n    }\n    var props = keytipProps;\n    if (!persisted) {\n      // Add the overflowSetSequence if necessary\n      props = this.addParentOverflow(keytipProps);\n      this.sequenceMapping[props.keySequences.toString()] = props;\n    }\n    // Create a unique keytip\n    var uniqueKeytip = this._getUniqueKtp(props);\n    // Add to dictionary\n    persisted ? this.persistedKeytips[uniqueKeytip.uniqueID] = uniqueKeytip : this.keytips[uniqueKeytip.uniqueID] = uniqueKeytip;\n    // We only want to add something new if we are currently showing keytip mode\n    if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n      var event_1 = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;\n      EventGroup.raise(this, event_1, {\n        keytip: props,\n        uniqueID: uniqueKeytip.uniqueID\n      });\n    }\n    return uniqueKeytip.uniqueID;\n  };\n  /**\n   * Update a keytip\n   *\n   * @param keytipProps - Keytip to update\n   * @param uniqueID - Unique ID of this keytip\n   */\n  KeytipManager.prototype.update = function (keytipProps, uniqueID) {\n    var newKeytipProps = this.addParentOverflow(keytipProps);\n    var uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);\n    var oldKeyTip = this.keytips[uniqueID];\n    if (oldKeyTip) {\n      // Update everything except 'visible'\n      uniqueKeytip.keytip.visible = oldKeyTip.keytip.visible;\n      // Update keytip in this.keytips\n      this.keytips[uniqueID] = uniqueKeytip;\n      // Update the sequence to be up to date\n      delete this.sequenceMapping[oldKeyTip.keytip.keySequences.toString()];\n      this.sequenceMapping[uniqueKeytip.keytip.keySequences.toString()] = uniqueKeytip.keytip;\n      // Raise event only if we are currently in keytip mode\n      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n        EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {\n          keytip: uniqueKeytip.keytip,\n          uniqueID: uniqueKeytip.uniqueID\n        });\n      }\n    }\n  };\n  /**\n   * Unregisters a keytip\n   *\n   * @param keytipToRemove - IKeytipProps of the keytip to remove\n   * @param uniqueID - Unique ID of this keytip\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   */\n  KeytipManager.prototype.unregister = function (keytipToRemove, uniqueID, persisted) {\n    if (persisted === void 0) {\n      persisted = false;\n    }\n    persisted ? delete this.persistedKeytips[uniqueID] : delete this.keytips[uniqueID];\n    !persisted && delete this.sequenceMapping[keytipToRemove.keySequences.toString()];\n    var event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;\n    // Update keytips only if we're in keytip mode\n    if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n      EventGroup.raise(this, event, {\n        keytip: keytipToRemove,\n        uniqueID: uniqueID\n      });\n    }\n  };\n  /**\n   * Manual call to enter keytip mode\n   */\n  KeytipManager.prototype.enterKeytipMode = function () {\n    EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);\n  };\n  /**\n   * Manual call to exit keytip mode\n   */\n  KeytipManager.prototype.exitKeytipMode = function () {\n    EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);\n  };\n  /**\n   * Gets all IKeytipProps from this.keytips\n   *\n   * @returns All keytips stored in the manager\n   */\n  KeytipManager.prototype.getKeytips = function () {\n    var _this = this;\n    return Object.keys(this.keytips).map(function (key) {\n      return _this.keytips[key].keytip;\n    });\n  };\n  /**\n   * Adds the overflowSetSequence to the keytipProps if its parent keytip also has it\n   *\n   * @param keytipProps - Keytip props to add overflowSetSequence to if necessary\n   * @returns - Modified keytip props, if needed to be modified\n   */\n  KeytipManager.prototype.addParentOverflow = function (keytipProps) {\n    var fullSequence = __spreadArray([], keytipProps.keySequences, true);\n    fullSequence.pop();\n    if (fullSequence.length !== 0) {\n      var parentKeytip = this.sequenceMapping[fullSequence.toString()];\n      if (parentKeytip && parentKeytip.overflowSetSequence) {\n        return __assign(__assign({}, keytipProps), {\n          overflowSetSequence: parentKeytip.overflowSetSequence\n        });\n      }\n    }\n    return keytipProps;\n  };\n  /**\n   * Public function to bind for overflow items that have a submenu\n   */\n  KeytipManager.prototype.menuExecute = function (overflowButtonSequences, keytipSequences) {\n    EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {\n      overflowButtonSequences: overflowButtonSequences,\n      keytipSequences: keytipSequences\n    });\n  };\n  /**\n   * Creates an IUniqueKeytip object\n   *\n   * @param keytipProps - IKeytipProps\n   * @param uniqueID - Unique ID, will default to the next unique ID if not passed\n   * @returns IUniqueKeytip object\n   */\n  KeytipManager.prototype._getUniqueKtp = function (keytipProps, uniqueID) {\n    if (uniqueID === void 0) {\n      uniqueID = getId();\n    }\n    return {\n      keytip: __assign({}, keytipProps),\n      uniqueID: uniqueID\n    };\n  };\n  KeytipManager._instance = new KeytipManager();\n  return KeytipManager;\n}();\nexport { KeytipManager };","map":{"version":3,"names":["EventGroup","getId","KeytipEvents","KeytipManager","keytips","persistedKeytips","sequenceMapping","inKeytipMode","shouldEnterKeytipMode","delayUpdatingKeytipChange","getInstance","_instance","prototype","init","register","keytipProps","persisted","props","addParentOverflow","keySequences","toString","uniqueKeytip","_getUniqueKtp","uniqueID","event_1","PERSISTED_KEYTIP_ADDED","KEYTIP_ADDED","raise","keytip","update","newKeytipProps","oldKeyTip","visible","KEYTIP_UPDATED","unregister","keytipToRemove","event","PERSISTED_KEYTIP_REMOVED","KEYTIP_REMOVED","enterKeytipMode","ENTER_KEYTIP_MODE","exitKeytipMode","EXIT_KEYTIP_MODE","getKeytips","_this","Object","keys","map","key","fullSequence","__spreadArray","pop","length","parentKeytip","overflowSetSequence","__assign","menuExecute","overflowButtonSequences","keytipSequences","PERSISTED_KEYTIP_EXECUTE"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/utilities/src/utilities/keytips/KeytipManager.ts"],"sourcesContent":["import { EventGroup, getId } from '../../Utilities';\nimport { KeytipEvents } from '../../utilities/keytips/KeytipConstants';\nimport type { IKeytipProps } from '../../Keytip';\n\nexport interface IUniqueKeytip {\n  uniqueID: string;\n  keytip: IKeytipProps;\n}\n\n/**\n * This class is responsible for handling registering, updating, and unregistering of keytips\n */\nexport class KeytipManager {\n  private static _instance: KeytipManager = new KeytipManager();\n\n  public keytips: { [key: string]: IUniqueKeytip } = {};\n  public persistedKeytips: { [key: string]: IUniqueKeytip } = {};\n  public sequenceMapping: { [key: string]: IKeytipProps } = {};\n\n  // This is (and should be) updated and kept in sync\n  // with the inKeytipMode in KeytipLayer.\n  public inKeytipMode = false;\n\n  // Boolean that gets checked before entering keytip mode by the KeytipLayer\n  // Used for an override in special cases (e.g. Disable entering keytip mode when a modal is shown)\n  public shouldEnterKeytipMode = true;\n\n  // Boolean to indicate whether to delay firing an event to update subscribers of\n  // keytip data changed.\n  public delayUpdatingKeytipChange = false;\n\n  /**\n   * Static function to get singleton KeytipManager instance\n   *\n   * @returns Singleton KeytipManager instance\n   */\n  public static getInstance(): KeytipManager {\n    return this._instance;\n  }\n\n  /**\n   * Initialization code to set set parameters to define\n   * how the KeytipManager handles keytip data.\n   *\n   * @param delayUpdatingKeytipChange - T/F if we should delay notifiying keytip subscribers\n   * of keytip changes\n   */\n  public init(delayUpdatingKeytipChange: boolean) {\n    this.delayUpdatingKeytipChange = delayUpdatingKeytipChange;\n  }\n\n  /**\n   * Registers a keytip\n   *\n   * @param keytipProps - Keytip to register\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   * @returns Unique ID for this keytip\n   */\n  public register(keytipProps: IKeytipProps, persisted: boolean = false): string {\n    let props: IKeytipProps = keytipProps;\n    if (!persisted) {\n      // Add the overflowSetSequence if necessary\n      props = this.addParentOverflow(keytipProps);\n      this.sequenceMapping[props.keySequences.toString()] = props;\n    }\n    // Create a unique keytip\n    const uniqueKeytip: IUniqueKeytip = this._getUniqueKtp(props);\n    // Add to dictionary\n    persisted\n      ? (this.persistedKeytips[uniqueKeytip.uniqueID] = uniqueKeytip)\n      : (this.keytips[uniqueKeytip.uniqueID] = uniqueKeytip);\n\n    // We only want to add something new if we are currently showing keytip mode\n    if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n      const event = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;\n      EventGroup.raise(this, event, {\n        keytip: props,\n        uniqueID: uniqueKeytip.uniqueID,\n      });\n    }\n\n    return uniqueKeytip.uniqueID;\n  }\n\n  /**\n   * Update a keytip\n   *\n   * @param keytipProps - Keytip to update\n   * @param uniqueID - Unique ID of this keytip\n   */\n  public update(keytipProps: IKeytipProps, uniqueID: string): void {\n    const newKeytipProps = this.addParentOverflow(keytipProps);\n    const uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);\n    const oldKeyTip = this.keytips[uniqueID];\n    if (oldKeyTip) {\n      // Update everything except 'visible'\n      uniqueKeytip.keytip.visible = oldKeyTip.keytip.visible;\n      // Update keytip in this.keytips\n      this.keytips[uniqueID] = uniqueKeytip;\n\n      // Update the sequence to be up to date\n      delete this.sequenceMapping[oldKeyTip.keytip.keySequences.toString()];\n      this.sequenceMapping[uniqueKeytip.keytip.keySequences.toString()] = uniqueKeytip.keytip;\n\n      // Raise event only if we are currently in keytip mode\n      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n        EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {\n          keytip: uniqueKeytip.keytip,\n          uniqueID: uniqueKeytip.uniqueID,\n        });\n      }\n    }\n  }\n\n  /**\n   * Unregisters a keytip\n   *\n   * @param keytipToRemove - IKeytipProps of the keytip to remove\n   * @param uniqueID - Unique ID of this keytip\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   */\n  public unregister(keytipToRemove: IKeytipProps, uniqueID: string, persisted: boolean = false): void {\n    persisted ? delete this.persistedKeytips[uniqueID] : delete this.keytips[uniqueID];\n    !persisted && delete this.sequenceMapping[keytipToRemove.keySequences.toString()];\n\n    const event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;\n    // Update keytips only if we're in keytip mode\n    if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n      EventGroup.raise(this, event, {\n        keytip: keytipToRemove,\n        uniqueID,\n      });\n    }\n  }\n\n  /**\n   * Manual call to enter keytip mode\n   */\n  public enterKeytipMode(): void {\n    EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);\n  }\n\n  /**\n   * Manual call to exit keytip mode\n   */\n  public exitKeytipMode(): void {\n    EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);\n  }\n\n  /**\n   * Gets all IKeytipProps from this.keytips\n   *\n   * @returns All keytips stored in the manager\n   */\n  public getKeytips(): IKeytipProps[] {\n    return Object.keys(this.keytips).map(key => this.keytips[key].keytip);\n  }\n\n  /**\n   * Adds the overflowSetSequence to the keytipProps if its parent keytip also has it\n   *\n   * @param keytipProps - Keytip props to add overflowSetSequence to if necessary\n   * @returns - Modified keytip props, if needed to be modified\n   */\n  public addParentOverflow(keytipProps: IKeytipProps): IKeytipProps {\n    const fullSequence = [...keytipProps.keySequences];\n    fullSequence.pop();\n    if (fullSequence.length !== 0) {\n      const parentKeytip = this.sequenceMapping[fullSequence.toString()];\n      if (parentKeytip && parentKeytip.overflowSetSequence) {\n        return {\n          ...keytipProps,\n          overflowSetSequence: parentKeytip.overflowSetSequence,\n        };\n      }\n    }\n    return keytipProps;\n  }\n\n  /**\n   * Public function to bind for overflow items that have a submenu\n   */\n  public menuExecute(overflowButtonSequences: string[], keytipSequences: string[]) {\n    EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {\n      overflowButtonSequences,\n      keytipSequences,\n    });\n  }\n\n  /**\n   * Creates an IUniqueKeytip object\n   *\n   * @param keytipProps - IKeytipProps\n   * @param uniqueID - Unique ID, will default to the next unique ID if not passed\n   * @returns IUniqueKeytip object\n   */\n  private _getUniqueKtp(keytipProps: IKeytipProps, uniqueID: string = getId()): IUniqueKeytip {\n    return { keytip: { ...keytipProps }, uniqueID };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}