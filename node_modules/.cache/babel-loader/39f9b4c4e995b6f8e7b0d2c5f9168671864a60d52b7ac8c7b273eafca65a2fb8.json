{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { BaseDecorator } from './BaseDecorator';\nimport { findScrollableParent, getRect, getWindow, Async, EventGroup } from '../../Utilities';\nvar RESIZE_DELAY = 500;\nvar MAX_RESIZE_ATTEMPTS = 3;\n/**\n * A decorator to update decorated component on viewport or window resize events.\n *\n * @param ComposedComponent - decorated React component reference.\n */\nexport function withViewport(ComposedComponent) {\n  return (/** @class */function (_super) {\n      __extends(WithViewportComponent, _super);\n      function WithViewportComponent(props) {\n        var _this = _super.call(this, props) || this;\n        _this._root = React.createRef();\n        _this._registerResizeObserver = function () {\n          var win = getWindow(_this._root.current);\n          _this._viewportResizeObserver = new win.ResizeObserver(_this._onAsyncResize);\n          _this._viewportResizeObserver.observe(_this._root.current);\n        };\n        _this._unregisterResizeObserver = function () {\n          if (_this._viewportResizeObserver) {\n            _this._viewportResizeObserver.disconnect();\n            delete _this._viewportResizeObserver;\n          }\n        };\n        /* Note: using lambda here because decorators don't seem to work in decorators. */\n        _this._updateViewport = function (withForceUpdate) {\n          var viewport = _this.state.viewport;\n          var viewportElement = _this._root.current;\n          var scrollElement = findScrollableParent(viewportElement);\n          var scrollRect = getRect(scrollElement);\n          var clientRect = getRect(viewportElement);\n          var updateComponent = function () {\n            if (withForceUpdate && _this._composedComponentInstance) {\n              _this._composedComponentInstance.forceUpdate();\n            }\n          };\n          var isSizeChanged = (clientRect && clientRect.width) !== viewport.width || (scrollRect && scrollRect.height) !== viewport.height;\n          if (isSizeChanged && _this._resizeAttempts < MAX_RESIZE_ATTEMPTS && clientRect && scrollRect) {\n            _this._resizeAttempts++;\n            _this.setState({\n              viewport: {\n                width: clientRect.width,\n                height: scrollRect.height\n              }\n            }, function () {\n              _this._updateViewport(withForceUpdate);\n            });\n          } else {\n            _this._resizeAttempts = 0;\n            updateComponent();\n          }\n        };\n        _this._async = new Async(_this);\n        _this._events = new EventGroup(_this);\n        _this._resizeAttempts = 0;\n        _this.state = {\n          viewport: {\n            width: 0,\n            height: 0\n          }\n        };\n        return _this;\n      }\n      WithViewportComponent.prototype.componentDidMount = function () {\n        var _this = this;\n        var _a = this.props,\n          delayFirstMeasure = _a.delayFirstMeasure,\n          disableResizeObserver = _a.disableResizeObserver,\n          skipViewportMeasures = _a.skipViewportMeasures;\n        var win = getWindow(this._root.current);\n        this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\n          leading: false\n        });\n        if (!skipViewportMeasures) {\n          if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n            this._registerResizeObserver();\n          } else {\n            this._events.on(win, 'resize', this._onAsyncResize);\n          }\n          if (delayFirstMeasure) {\n            this._async.setTimeout(function () {\n              _this._updateViewport();\n            }, RESIZE_DELAY);\n          } else {\n            this._updateViewport();\n          }\n        }\n      };\n      WithViewportComponent.prototype.componentDidUpdate = function (previousProps) {\n        var previousSkipViewportMeasures = previousProps.skipViewportMeasures;\n        var _a = this.props,\n          disableResizeObserver = _a.disableResizeObserver,\n          skipViewportMeasures = _a.skipViewportMeasures;\n        var win = getWindow(this._root.current);\n        if (skipViewportMeasures !== previousSkipViewportMeasures) {\n          if (!skipViewportMeasures) {\n            if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n              if (!this._viewportResizeObserver) {\n                this._registerResizeObserver();\n              }\n            } else {\n              this._events.on(win, 'resize', this._onAsyncResize);\n            }\n            this._updateViewport();\n          } else {\n            this._unregisterResizeObserver();\n            this._events.off(win, 'resize', this._onAsyncResize);\n          }\n        }\n      };\n      WithViewportComponent.prototype.componentWillUnmount = function () {\n        this._events.dispose();\n        this._async.dispose();\n        this._unregisterResizeObserver();\n      };\n      WithViewportComponent.prototype.render = function () {\n        var viewport = this.state.viewport;\n        var newViewport = viewport.width > 0 && viewport.height > 0 ? viewport : undefined;\n        return React.createElement(\"div\", {\n          className: \"ms-Viewport\",\n          ref: this._root,\n          style: {\n            minWidth: 1,\n            minHeight: 1\n          }\n        }, React.createElement(ComposedComponent, __assign({\n          ref: this._updateComposedComponentRef,\n          viewport: newViewport\n        }, this.props)));\n      };\n      WithViewportComponent.prototype.forceUpdate = function () {\n        this._updateViewport(true);\n      };\n      WithViewportComponent.prototype._onAsyncResize = function () {\n        this._updateViewport();\n      };\n      WithViewportComponent.prototype._isResizeObserverAvailable = function () {\n        var win = getWindow(this._root.current);\n        return win && win.ResizeObserver;\n      };\n      return WithViewportComponent;\n    }(BaseDecorator)\n  );\n}","map":{"version":3,"names":["React","BaseDecorator","findScrollableParent","getRect","getWindow","Async","EventGroup","RESIZE_DELAY","MAX_RESIZE_ATTEMPTS","withViewport","ComposedComponent","_super","__extends","WithViewportComponent","props","_this","call","_root","createRef","_registerResizeObserver","win","current","_viewportResizeObserver","ResizeObserver","_onAsyncResize","observe","_unregisterResizeObserver","disconnect","_updateViewport","withForceUpdate","viewport","state","viewportElement","scrollElement","scrollRect","clientRect","updateComponent","_composedComponentInstance","forceUpdate","isSizeChanged","width","height","_resizeAttempts","setState","_async","_events","prototype","componentDidMount","_a","delayFirstMeasure","disableResizeObserver","skipViewportMeasures","debounce","leading","_isResizeObserverAvailable","on","setTimeout","componentDidUpdate","previousProps","previousSkipViewportMeasures","off","componentWillUnmount","dispose","render","newViewport","undefined","createElement","className","ref","style","minWidth","minHeight","__assign","_updateComposedComponentRef"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/utilities/src/utilities/decorators/withViewport.tsx"],"sourcesContent":["import * as React from 'react';\nimport { BaseDecorator } from './BaseDecorator';\nimport { findScrollableParent, getRect, getWindow, Async, EventGroup } from '../../Utilities';\n\n/**\n * Viewport rectangle dimensions.\n *\n * {@docCategory DetailsList}\n */\nexport interface IViewport {\n  /**\n   * Width in pixels.\n   */\n  width: number;\n  /**\n   * Height in pixels.\n   */\n  height: number;\n}\n\nexport interface IWithViewportState {\n  viewport?: IViewport;\n}\n\n/**\n * Props interface for the withViewport component.\n *\n * {@docCategory DetailsList}\n */\nexport interface IWithViewportProps {\n  /**\n   * Whether or not `withViewport` should disable its viewport measurements, effectively making this decorator\n   * pass-through with no impact on the rendered component.\n   *\n   * Since `withViewport` measures the `viewport` on mount, after each React update, and in response to events,\n   * it may cause a component which does not currently need this information due to its configuration to re-render\n   * too often. `skipViewportMeasures` may be toggled on and off based on current state, and will suspend and resume\n   * measurement as-needed.\n   *\n   * For example, when this wraps `DetailsList`, set `skipViewportMeasures` to `true` when the `layoutMode` is\n   * `fixedColumns`, since the `DetailsList` does not use the viewport size in any calculations.\n   *\n   * In addition, consider setting `skipViewportMeasures` to `true` when running within a React test renderer, to avoid\n   * direct DOM dependencies.\n   */\n\n  skipViewportMeasures?: boolean;\n  /**\n   * Whether or not to explicitly disable usage of the `ResizeObserver` in favor of a `'resize'` event on `window`,\n   * even if the browser supports `ResizeObserver`. This may be necessary if use of `ResizeObserver` results in too\n   * many re-renders of the wrapped component due to the frequency at which events are fired.\n   *\n   * This has no impact if `skipViewportMeasures` is `true`, as no viewport measurement strategy is used.\n   */\n  disableResizeObserver?: boolean;\n\n  /**\n   * Whether or not `withViewport` will delay before first measuring the viewport size.\n   * Setting this will delay measurement by the same amount as the debounce for resizing the window.\n   * This is useful for giving the child of the viewport time to render before measuring.\n   *\n   * This is an opt-in setting as existing systems have a dependency on immediate measurement for performance.\n   * @default false\n   */\n  delayFirstMeasure?: boolean;\n}\n\nconst RESIZE_DELAY = 500;\nconst MAX_RESIZE_ATTEMPTS = 3;\n\n/**\n * A decorator to update decorated component on viewport or window resize events.\n *\n * @param ComposedComponent - decorated React component reference.\n */\nexport function withViewport<TProps extends { viewport?: IViewport }, TState>(\n  ComposedComponent: new (props: TProps, ...args: any[]) => React.Component<TProps, TState>,\n): any {\n  return class WithViewportComponent extends BaseDecorator<TProps, IWithViewportState> {\n    private _root = React.createRef<HTMLDivElement>();\n    private _resizeAttempts: number;\n    private _viewportResizeObserver: any;\n    private _async: Async;\n    private _events: EventGroup;\n\n    constructor(props: TProps) {\n      super(props);\n\n      this._async = new Async(this);\n      this._events = new EventGroup(this);\n      this._resizeAttempts = 0;\n\n      this.state = {\n        viewport: {\n          width: 0,\n          height: 0,\n        },\n      };\n    }\n\n    public componentDidMount(): void {\n      const { delayFirstMeasure, disableResizeObserver, skipViewportMeasures } = this.props as IWithViewportProps;\n      const win = getWindow(this._root.current);\n\n      this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\n        leading: false,\n      });\n\n      if (!skipViewportMeasures) {\n        if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n          this._registerResizeObserver();\n        } else {\n          this._events.on(win, 'resize', this._onAsyncResize);\n        }\n\n        if (delayFirstMeasure) {\n          this._async.setTimeout(() => {\n            this._updateViewport();\n          }, RESIZE_DELAY);\n        } else {\n          this._updateViewport();\n        }\n      }\n    }\n\n    public componentDidUpdate(previousProps: TProps) {\n      const { skipViewportMeasures: previousSkipViewportMeasures } = previousProps as IWithViewportProps;\n      const { disableResizeObserver, skipViewportMeasures } = this.props as IWithViewportProps;\n      const win = getWindow(this._root.current);\n\n      if (skipViewportMeasures !== previousSkipViewportMeasures) {\n        if (!skipViewportMeasures) {\n          if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n            if (!this._viewportResizeObserver) {\n              this._registerResizeObserver();\n            }\n          } else {\n            this._events.on(win, 'resize', this._onAsyncResize);\n          }\n\n          this._updateViewport();\n        } else {\n          this._unregisterResizeObserver();\n          this._events.off(win, 'resize', this._onAsyncResize);\n        }\n      }\n    }\n\n    public componentWillUnmount(): void {\n      this._events.dispose();\n      this._async.dispose();\n      this._unregisterResizeObserver();\n    }\n\n    public render(): JSX.Element {\n      const { viewport } = this.state;\n      const newViewport = viewport!.width > 0 && viewport!.height > 0 ? viewport : undefined;\n\n      return (\n        <div className=\"ms-Viewport\" ref={this._root} style={{ minWidth: 1, minHeight: 1 }}>\n          <ComposedComponent ref={this._updateComposedComponentRef} viewport={newViewport} {...(this.props as any)} />\n        </div>\n      );\n    }\n\n    public forceUpdate(): void {\n      this._updateViewport(true);\n    }\n\n    private _onAsyncResize(): void {\n      this._updateViewport();\n    }\n\n    private _isResizeObserverAvailable(): boolean {\n      const win = getWindow(this._root.current);\n\n      return win && (win as any).ResizeObserver;\n    }\n\n    private _registerResizeObserver = () => {\n      const win = getWindow(this._root.current);\n\n      this._viewportResizeObserver = new (win as any).ResizeObserver(this._onAsyncResize);\n      this._viewportResizeObserver.observe(this._root.current);\n    };\n\n    private _unregisterResizeObserver = () => {\n      if (this._viewportResizeObserver) {\n        this._viewportResizeObserver.disconnect();\n        delete this._viewportResizeObserver;\n      }\n    };\n\n    /* Note: using lambda here because decorators don't seem to work in decorators. */\n    private _updateViewport = (withForceUpdate?: boolean) => {\n      const { viewport } = this.state;\n      const viewportElement = this._root.current;\n      const scrollElement = findScrollableParent(viewportElement) as HTMLElement;\n      const scrollRect = getRect(scrollElement);\n      const clientRect = getRect(viewportElement);\n      const updateComponent = () => {\n        if (withForceUpdate && this._composedComponentInstance) {\n          this._composedComponentInstance.forceUpdate();\n        }\n      };\n\n      const isSizeChanged =\n        (clientRect && clientRect.width) !== viewport!.width || (scrollRect && scrollRect.height) !== viewport!.height;\n\n      if (isSizeChanged && this._resizeAttempts < MAX_RESIZE_ATTEMPTS && clientRect && scrollRect) {\n        this._resizeAttempts++;\n        this.setState(\n          {\n            viewport: {\n              width: clientRect.width,\n              height: scrollRect.height,\n            },\n          },\n          () => {\n            this._updateViewport(withForceUpdate);\n          },\n        );\n      } else {\n        this._resizeAttempts = 0;\n        updateComponent();\n      }\n    };\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}