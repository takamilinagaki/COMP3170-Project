{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { divProperties, getNativeProps } from '../../Utilities';\nimport { ResizeGroupDirection } from './ResizeGroup.types';\nimport { useConst, useMergedRefs, useAsync, useOnEvent, useWarnings } from '@fluentui/react-hooks';\nimport { useWindow } from '../../WindowProvider';\nvar RESIZE_DELAY = 16;\n/**\n * Returns a simple object is able to store measurements with a given key.\n */\nexport var getMeasurementCache = function () {\n  var measurementsCache = {};\n  return {\n    /**\n     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a\n     * corresponding entry in the measurementsCache, then it will return that value.\n     * Returns undefined otherwise.\n     */\n    getCachedMeasurement: function (data) {\n      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {\n        return measurementsCache[data.cacheKey];\n      }\n      return undefined;\n    },\n    /**\n     * Should be called whenever there is a new measurement associated with a given data object.\n     * If the data has a cacheKey, store that measurement in the measurementsCache.\n     */\n    addMeasurementToCache: function (data, measurement) {\n      if (data.cacheKey) {\n        measurementsCache[data.cacheKey] = measurement;\n      }\n    }\n  };\n};\n/**\n * Returns a function that is able to compute the next state for the ResizeGroup given the current\n * state and any measurement updates.\n */\nexport var getNextResizeGroupStateProvider = function (measurementCache) {\n  if (measurementCache === void 0) {\n    measurementCache = getMeasurementCache();\n  }\n  var _measurementCache = measurementCache;\n  var _containerDimension;\n  /**\n   * Gets the width/height of the data rendered in a hidden div.\n   * @param measuredData - The data corresponding to the measurement we wish to take.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _getMeasuredDimension(measuredData, getElementToMeasureDimension) {\n    var cachedDimension = _measurementCache.getCachedMeasurement(measuredData);\n    if (cachedDimension !== undefined) {\n      return cachedDimension;\n    }\n    var measuredDimension = getElementToMeasureDimension();\n    _measurementCache.addMeasurementToCache(measuredData, measuredDimension);\n    return measuredDimension;\n  }\n  /**\n   * Will get the next IResizeGroupState based on the current data while trying to shrink contents\n   * to fit in the container.\n   * @param data - The initial data point to start measuring.\n   * @param onReduceData - Function that transforms the data into something that should render with less width/height.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _shrinkContentsUntilTheyFit(data, onReduceData, getElementToMeasureDimension) {\n    var dataToMeasure = data;\n    var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);\n    while (measuredDimension > _containerDimension) {\n      var nextMeasuredData = onReduceData(dataToMeasure);\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onReduceData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined\n        };\n      }\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);\n      // If the measurement isn't in the cache, we need to re-render with some data in a hidden div\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n          resizeDirection: 'shrink'\n        };\n      }\n      dataToMeasure = nextMeasuredData;\n    }\n    return {\n      renderedData: dataToMeasure,\n      resizeDirection: undefined,\n      dataToMeasure: undefined\n    };\n  }\n  /**\n   * This function should be called when the state changes in a manner that might allow for more content to fit\n   * on the screen, such as the window width/height growing.\n   * @param data - The initial data point to start measuring.\n   * @param onGrowData - Function that transforms the data into something that may take up more space when rendering.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _growDataUntilItDoesNotFit(data, onGrowData, getElementToMeasureDimension, onReduceData) {\n    var dataToMeasure = data;\n    var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);\n    while (measuredDimension < _containerDimension) {\n      var nextMeasuredData = onGrowData(dataToMeasure);\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onGrowData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined\n        };\n      }\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);\n      // If the measurement isn't in the cache, we need to re-render with some data in a hidden div\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData\n        };\n      }\n      dataToMeasure = nextMeasuredData;\n    }\n    // Once the loop is done, we should now shrink until the contents fit.\n    return __assign({\n      resizeDirection: 'shrink'\n    }, _shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureDimension));\n  }\n  /**\n   * Handles an update to the container width/height.\n   * Should only be called when we knew the previous container width/height.\n   * @param newDimension - The new width/height of the container.\n   * @param fullDimensionData - The initial data passed in as a prop to resizeGroup.\n   * @param renderedData - The data that was rendered prior to the container size changing.\n   * @param onGrowData - Set to true if the Resize group has an onGrowData function.\n   */\n  function _updateContainerDimension(newDimension, fullDimensionData, renderedData, onGrowData) {\n    var nextState;\n    if (newDimension > _containerDimension) {\n      if (onGrowData) {\n        nextState = {\n          resizeDirection: 'grow',\n          dataToMeasure: onGrowData(renderedData)\n        };\n      } else {\n        nextState = {\n          resizeDirection: 'shrink',\n          dataToMeasure: fullDimensionData\n        };\n      }\n    } else {\n      nextState = {\n        resizeDirection: 'shrink',\n        dataToMeasure: renderedData\n      };\n    }\n    _containerDimension = newDimension;\n    return __assign(__assign({}, nextState), {\n      measureContainer: false\n    });\n  }\n  function getNextState(props, currentState, getElementToMeasureDimension, newContainerDimension) {\n    // If there is no new container width/height or data to measure, there is no need for a new state update\n    if (newContainerDimension === undefined && currentState.dataToMeasure === undefined) {\n      return undefined;\n    }\n    if (newContainerDimension) {\n      // If we know the last container size and we rendered data at that width/height, we can do an optimized render\n      if (_containerDimension && currentState.renderedData && !currentState.dataToMeasure) {\n        return __assign(__assign({}, currentState), _updateContainerDimension(newContainerDimension, props.data, currentState.renderedData, props.onGrowData));\n      }\n      // If we are just setting the container width/height for the first time, we can't do any optimizations\n      _containerDimension = newContainerDimension;\n    }\n    var nextState = __assign(__assign({}, currentState), {\n      measureContainer: false\n    });\n    if (currentState.dataToMeasure) {\n      if (currentState.resizeDirection === 'grow' && props.onGrowData) {\n        nextState = __assign(__assign({}, nextState), _growDataUntilItDoesNotFit(currentState.dataToMeasure, props.onGrowData, getElementToMeasureDimension, props.onReduceData));\n      } else {\n        nextState = __assign(__assign({}, nextState), _shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureDimension));\n      }\n    }\n    return nextState;\n  }\n  /** Function that determines if we need to render content for measurement based on the measurement cache contents. */\n  function shouldRenderDataForMeasurement(dataToMeasure) {\n    if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== undefined) {\n      return false;\n    }\n    return true;\n  }\n  function getInitialResizeGroupState(data) {\n    return {\n      dataToMeasure: __assign({}, data),\n      resizeDirection: 'grow',\n      measureContainer: true\n    };\n  }\n  return {\n    getNextState: getNextState,\n    shouldRenderDataForMeasurement: shouldRenderDataForMeasurement,\n    getInitialResizeGroupState: getInitialResizeGroupState\n  };\n};\n// Provides a context property that (if true) tells any child components that\n// they are only being used for measurement purposes and will not be visible.\nexport var MeasuredContext = React.createContext({\n  isMeasured: false\n});\n// Styles for the hidden div used for measurement\nvar hiddenDivStyles = {\n  position: 'fixed',\n  visibility: 'hidden'\n};\nvar hiddenParentStyles = {\n  position: 'relative'\n};\nvar COMPONENT_NAME = 'ResizeGroup';\n/**\n * Use useReducer instead of userState because React is not batching the state updates\n * when state is set in callbacks of setTimeout or requestAnimationFrame.\n * See issue: https://github.com/facebook/react/issues/14259\n */\nfunction resizeDataReducer(state, action) {\n  var _a;\n  switch (action.type) {\n    case 'resizeData':\n      return __assign({}, action.value);\n    case 'dataToMeasure':\n      return __assign(__assign({}, state), {\n        dataToMeasure: action.value,\n        resizeDirection: 'grow',\n        measureContainer: true\n      });\n    default:\n      return __assign(__assign({}, state), (_a = {}, _a[action.type] = action.value, _a));\n  }\n}\nfunction useResizeState(props, nextResizeGroupStateProvider, rootRef) {\n  var initialStateData = useConst(function () {\n    return nextResizeGroupStateProvider.getInitialResizeGroupState(props.data);\n  });\n  var _a = React.useReducer(resizeDataReducer, initialStateData),\n    resizeData = _a[0],\n    dispatchResizeDataAction = _a[1];\n  // Reset state when new data is provided\n  React.useEffect(function () {\n    dispatchResizeDataAction({\n      type: 'dataToMeasure',\n      value: props.data\n    });\n  }, [props.data]);\n  // Because it's possible that we may force more than one re-render per animation frame, we\n  // want to make sure that the RAF request is using the most recent data.\n  var stateRef = React.useRef(initialStateData);\n  stateRef.current = __assign({}, resizeData);\n  var updateResizeState = React.useCallback(function (nextState) {\n    if (nextState) {\n      dispatchResizeDataAction({\n        type: 'resizeData',\n        value: nextState\n      });\n    }\n  }, []);\n  var remeasure = React.useCallback(function () {\n    if (rootRef.current) {\n      dispatchResizeDataAction({\n        type: 'measureContainer',\n        value: true\n      });\n    }\n  }, [rootRef]);\n  return [stateRef, updateResizeState, remeasure];\n}\nfunction useResizingBehavior(props, rootRef) {\n  var nextResizeGroupStateProvider = useConst(getNextResizeGroupStateProvider);\n  // A div that can be used for the initial measurement so that we can avoid mounting a second instance\n  // of the component being measured for the initial render.\n  var initialHiddenDiv = React.useRef(null);\n  // A hidden div that is used for mounting a new instance of the component for measurement in a hidden\n  // div without unmounting the currently visible content.\n  var updateHiddenDiv = React.useRef(null);\n  // Tracks if any content has been rendered to the user. This enables us to do some performance optimizations\n  // for the initial render.\n  var hasRenderedContent = React.useRef(false);\n  var async = useAsync();\n  var _a = useResizeState(props, nextResizeGroupStateProvider, rootRef),\n    stateRef = _a[0],\n    updateResizeState = _a[1],\n    remeasure = _a[2];\n  React.useEffect(function () {\n    var _a;\n    if (stateRef.current.renderedData) {\n      hasRenderedContent.current = true;\n      (_a = props.dataDidRender) === null || _a === void 0 ? void 0 : _a.call(props, stateRef.current.renderedData);\n    }\n  });\n  React.useEffect(function () {\n    async.requestAnimationFrame(function () {\n      var containerDimension = undefined;\n      if (stateRef.current.measureContainer && rootRef.current) {\n        var boundingRect = rootRef.current.getBoundingClientRect();\n        containerDimension = props.direction === ResizeGroupDirection.vertical ? boundingRect.height : boundingRect.width;\n      }\n      var nextState = nextResizeGroupStateProvider.getNextState(props, stateRef.current, function () {\n        var refToMeasure = !hasRenderedContent.current ? initialHiddenDiv : updateHiddenDiv;\n        if (!refToMeasure.current) {\n          return 0;\n        }\n        var measuredBoundingRect = refToMeasure.current.getBoundingClientRect();\n        return props.direction === ResizeGroupDirection.vertical ? measuredBoundingRect.height : measuredBoundingRect.width;\n      }, containerDimension);\n      updateResizeState(nextState);\n    }, rootRef.current);\n  });\n  var win = useWindow();\n  useOnEvent(win, 'resize', async.debounce(remeasure, RESIZE_DELAY, {\n    leading: true\n  }));\n  var dataNeedsMeasuring = nextResizeGroupStateProvider.shouldRenderDataForMeasurement(stateRef.current.dataToMeasure);\n  var isInitialMeasure = !hasRenderedContent.current && dataNeedsMeasuring;\n  return [stateRef.current.dataToMeasure, stateRef.current.renderedData, remeasure, initialHiddenDiv, updateHiddenDiv, dataNeedsMeasuring, isInitialMeasure];\n}\nfunction useDebugWarnings(props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props: props,\n      deprecations: {\n        styles: 'className'\n      }\n    });\n  }\n}\nvar measuredContextValue = {\n  isMeasured: true\n};\nexport var ResizeGroupBase = React.forwardRef(function (props, forwardedRef) {\n  var rootRef = React.useRef(null);\n  // The root div which is the container inside of which we are trying to fit content.\n  var mergedRootRef = useMergedRefs(rootRef, forwardedRef);\n  var _a = useResizingBehavior(props, rootRef),\n    dataToMeasure = _a[0],\n    renderedData = _a[1],\n    remeasure = _a[2],\n    initialHiddenDiv = _a[3],\n    updateHiddenDiv = _a[4],\n    dataNeedsMeasuring = _a[5],\n    isInitialMeasure = _a[6];\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      remeasure: remeasure\n    };\n  }, [remeasure]);\n  useDebugWarnings(props);\n  var className = props.className,\n    onRenderData = props.onRenderData;\n  var divProps = getNativeProps(props, divProperties, ['data']);\n  // We only ever render the final content to the user. All measurements are done in a hidden div.\n  // For the initial render, we want this to be as fast as possible, so we need to make sure that we only mount one\n  // version of the component for measurement and the final render. For renders that update what is on screen, we\n  // want to make sure that there are no jarring effects such as the screen flashing as we apply scaling steps for\n  // measurement. In the update case, we mount a second version of the component just for measurement purposes and\n  // leave the rendered content untouched until we know the next state to show to the user.\n  return React.createElement(\"div\", __assign({}, divProps, {\n    className: className,\n    ref: mergedRootRef\n  }), React.createElement(\"div\", {\n    style: hiddenParentStyles\n  }, dataNeedsMeasuring && !isInitialMeasure && React.createElement(\"div\", {\n    style: hiddenDivStyles,\n    ref: updateHiddenDiv\n  }, React.createElement(MeasuredContext.Provider, {\n    value: measuredContextValue\n  }, onRenderData(dataToMeasure))), React.createElement(\"div\", {\n    ref: initialHiddenDiv,\n    style: isInitialMeasure ? hiddenDivStyles : undefined,\n    \"data-automation-id\": \"visibleContent\"\n  }, isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData))));\n});\nResizeGroupBase.displayName = 'ResizeGroupBase';","map":{"version":3,"names":["React","divProperties","getNativeProps","ResizeGroupDirection","useConst","useMergedRefs","useAsync","useOnEvent","useWarnings","useWindow","RESIZE_DELAY","getMeasurementCache","measurementsCache","getCachedMeasurement","data","cacheKey","hasOwnProperty","undefined","addMeasurementToCache","measurement","getNextResizeGroupStateProvider","measurementCache","_measurementCache","_containerDimension","_getMeasuredDimension","measuredData","getElementToMeasureDimension","cachedDimension","measuredDimension","_shrinkContentsUntilTheyFit","onReduceData","dataToMeasure","nextMeasuredData","renderedData","resizeDirection","_growDataUntilItDoesNotFit","onGrowData","__assign","_updateContainerDimension","newDimension","fullDimensionData","nextState","measureContainer","getNextState","props","currentState","newContainerDimension","shouldRenderDataForMeasurement","getInitialResizeGroupState","MeasuredContext","createContext","isMeasured","hiddenDivStyles","position","visibility","hiddenParentStyles","COMPONENT_NAME","resizeDataReducer","state","action","type","value","_a","useResizeState","nextResizeGroupStateProvider","rootRef","initialStateData","useReducer","resizeData","dispatchResizeDataAction","useEffect","stateRef","useRef","current","updateResizeState","useCallback","remeasure","useResizingBehavior","initialHiddenDiv","updateHiddenDiv","hasRenderedContent","async","dataDidRender","call","requestAnimationFrame","containerDimension","boundingRect","getBoundingClientRect","direction","vertical","height","width","refToMeasure","measuredBoundingRect","win","debounce","leading","dataNeedsMeasuring","isInitialMeasure","useDebugWarnings","process","env","NODE_ENV","name","deprecations","styles","measuredContextValue","ResizeGroupBase","forwardRef","forwardedRef","mergedRootRef","useImperativeHandle","componentRef","className","onRenderData","divProps","createElement","ref","style","Provider","displayName"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/components/src/components/ResizeGroup/ResizeGroup.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { Async, divProperties, getNativeProps } from '../../Utilities';\nimport { ResizeGroupDirection } from './ResizeGroup.types';\nimport { useConst, useMergedRefs, useAsync, useOnEvent, useWarnings } from '@fluentui/react-hooks';\nimport { useWindow } from '../../WindowProvider';\nimport type { IResizeGroupProps } from './ResizeGroup.types';\n\nconst RESIZE_DELAY = 16;\n\nexport interface IResizeGroupState {\n  /**\n   * Final data used to render proper sized component\n   */\n  renderedData?: any;\n\n  /**\n   * Data to render in a hidden div for measurement\n   */\n  dataToMeasure?: any;\n\n  /**\n   * Set to true when the content container might have new dimensions and should\n   * be remeasured.\n   */\n  measureContainer?: boolean;\n\n  /**\n   * Are we resizing to accommodate having more or less available space?\n   * The 'grow' direction is when the container may have more room than the last render,\n   * such as when a window resize occurs. This means we will try to fit more content in the window.\n   * The 'shrink' direction is when the contents don't fit in the container and we need\n   * to find a transformation of the data that makes everything fit.\n   */\n  resizeDirection?: 'grow' | 'shrink';\n}\n\n/**\n * Returns a simple object is able to store measurements with a given key.\n */\nexport const getMeasurementCache = () => {\n  const measurementsCache: { [key: string]: number } = {};\n\n  return {\n    /**\n     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a\n     * corresponding entry in the measurementsCache, then it will return that value.\n     * Returns undefined otherwise.\n     */\n    getCachedMeasurement: (data: any): number | undefined => {\n      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {\n        return measurementsCache[data.cacheKey];\n      }\n\n      return undefined;\n    },\n    /**\n     * Should be called whenever there is a new measurement associated with a given data object.\n     * If the data has a cacheKey, store that measurement in the measurementsCache.\n     */\n    addMeasurementToCache: (data: any, measurement: number): void => {\n      if (data.cacheKey) {\n        measurementsCache[data.cacheKey] = measurement;\n      }\n    },\n  };\n};\n\n/**\n * Returns a function that is able to compute the next state for the ResizeGroup given the current\n * state and any measurement updates.\n */\nexport const getNextResizeGroupStateProvider = (measurementCache = getMeasurementCache()) => {\n  const _measurementCache = measurementCache;\n  let _containerDimension: number | undefined;\n\n  /**\n   * Gets the width/height of the data rendered in a hidden div.\n   * @param measuredData - The data corresponding to the measurement we wish to take.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _getMeasuredDimension(measuredData: any, getElementToMeasureDimension: () => number): number {\n    const cachedDimension = _measurementCache.getCachedMeasurement(measuredData);\n    if (cachedDimension !== undefined) {\n      return cachedDimension;\n    }\n\n    const measuredDimension = getElementToMeasureDimension();\n    _measurementCache.addMeasurementToCache(measuredData, measuredDimension);\n    return measuredDimension;\n  }\n\n  /**\n   * Will get the next IResizeGroupState based on the current data while trying to shrink contents\n   * to fit in the container.\n   * @param data - The initial data point to start measuring.\n   * @param onReduceData - Function that transforms the data into something that should render with less width/height.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _shrinkContentsUntilTheyFit(\n    data: any,\n    onReduceData: (prevData: any) => any,\n    getElementToMeasureDimension: () => number,\n  ): IResizeGroupState {\n    let dataToMeasure = data;\n    let measuredDimension: number | undefined = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension > _containerDimension!) {\n      const nextMeasuredData = onReduceData(dataToMeasure);\n\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onReduceData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined,\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);\n\n      // If the measurement isn't in the cache, we need to re-render with some data in a hidden div\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n          resizeDirection: 'shrink',\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    return {\n      renderedData: dataToMeasure,\n      resizeDirection: undefined,\n      dataToMeasure: undefined,\n    };\n  }\n\n  /**\n   * This function should be called when the state changes in a manner that might allow for more content to fit\n   * on the screen, such as the window width/height growing.\n   * @param data - The initial data point to start measuring.\n   * @param onGrowData - Function that transforms the data into something that may take up more space when rendering.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _growDataUntilItDoesNotFit(\n    data: any,\n    onGrowData: (prevData: any) => any,\n    getElementToMeasureDimension: () => number,\n    onReduceData: (prevData: any) => any,\n  ): IResizeGroupState {\n    let dataToMeasure = data;\n    let measuredDimension: number | undefined = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension < _containerDimension!) {\n      const nextMeasuredData = onGrowData(dataToMeasure);\n\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onGrowData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined,\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);\n      // If the measurement isn't in the cache, we need to re-render with some data in a hidden div\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    // Once the loop is done, we should now shrink until the contents fit.\n    return {\n      resizeDirection: 'shrink',\n      ..._shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureDimension),\n    };\n  }\n\n  /**\n   * Handles an update to the container width/height.\n   * Should only be called when we knew the previous container width/height.\n   * @param newDimension - The new width/height of the container.\n   * @param fullDimensionData - The initial data passed in as a prop to resizeGroup.\n   * @param renderedData - The data that was rendered prior to the container size changing.\n   * @param onGrowData - Set to true if the Resize group has an onGrowData function.\n   */\n  function _updateContainerDimension(\n    newDimension: number,\n    fullDimensionData: any,\n    renderedData: any,\n    onGrowData?: (prevData: any) => any,\n  ): IResizeGroupState {\n    let nextState: IResizeGroupState;\n    if (newDimension > _containerDimension!) {\n      if (onGrowData) {\n        nextState = {\n          resizeDirection: 'grow',\n          dataToMeasure: onGrowData(renderedData),\n        };\n      } else {\n        nextState = {\n          resizeDirection: 'shrink',\n          dataToMeasure: fullDimensionData,\n        };\n      }\n    } else {\n      nextState = {\n        resizeDirection: 'shrink',\n        dataToMeasure: renderedData,\n      };\n    }\n    _containerDimension = newDimension;\n    return { ...nextState, measureContainer: false };\n  }\n\n  function getNextState(\n    props: IResizeGroupProps,\n    currentState: IResizeGroupState,\n    getElementToMeasureDimension: () => number,\n    newContainerDimension?: number,\n  ): IResizeGroupState | undefined {\n    // If there is no new container width/height or data to measure, there is no need for a new state update\n    if (newContainerDimension === undefined && currentState.dataToMeasure === undefined) {\n      return undefined;\n    }\n\n    if (newContainerDimension) {\n      // If we know the last container size and we rendered data at that width/height, we can do an optimized render\n      if (_containerDimension && currentState.renderedData && !currentState.dataToMeasure) {\n        return {\n          ...currentState,\n          ..._updateContainerDimension(newContainerDimension, props.data, currentState.renderedData, props.onGrowData),\n        };\n      }\n\n      // If we are just setting the container width/height for the first time, we can't do any optimizations\n      _containerDimension = newContainerDimension;\n    }\n\n    let nextState: IResizeGroupState = {\n      ...currentState,\n      measureContainer: false,\n    };\n\n    if (currentState.dataToMeasure) {\n      if (currentState.resizeDirection === 'grow' && props.onGrowData) {\n        nextState = {\n          ...nextState,\n          ..._growDataUntilItDoesNotFit(\n            currentState.dataToMeasure,\n            props.onGrowData,\n            getElementToMeasureDimension,\n            props.onReduceData,\n          ),\n        };\n      } else {\n        nextState = {\n          ...nextState,\n          ..._shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureDimension),\n        };\n      }\n    }\n\n    return nextState;\n  }\n\n  /** Function that determines if we need to render content for measurement based on the measurement cache contents. */\n  function shouldRenderDataForMeasurement(dataToMeasure: any | undefined): boolean {\n    if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function getInitialResizeGroupState(data: any): IResizeGroupState {\n    return {\n      dataToMeasure: { ...data },\n      resizeDirection: 'grow',\n      measureContainer: true,\n    };\n  }\n\n  return {\n    getNextState,\n    shouldRenderDataForMeasurement,\n    getInitialResizeGroupState,\n  };\n};\n\n// Provides a context property that (if true) tells any child components that\n// they are only being used for measurement purposes and will not be visible.\nexport const MeasuredContext = React.createContext({ isMeasured: false });\n\n// Styles for the hidden div used for measurement\nconst hiddenDivStyles: React.CSSProperties = { position: 'fixed', visibility: 'hidden' };\nconst hiddenParentStyles: React.CSSProperties = { position: 'relative' };\nconst COMPONENT_NAME = 'ResizeGroup';\n\ntype ResizeDataAction = {\n  type: 'resizeData' | keyof IResizeGroupState;\n  value: IResizeGroupState[keyof IResizeGroupState] | IResizeGroupState;\n};\n\n/**\n * Use useReducer instead of userState because React is not batching the state updates\n * when state is set in callbacks of setTimeout or requestAnimationFrame.\n * See issue: https://github.com/facebook/react/issues/14259\n */\nfunction resizeDataReducer(state: IResizeGroupState, action: ResizeDataAction): IResizeGroupState {\n  switch (action.type) {\n    case 'resizeData':\n      return { ...action.value };\n    case 'dataToMeasure':\n      return { ...state, dataToMeasure: action.value, resizeDirection: 'grow', measureContainer: true };\n    default:\n      return { ...state, [action.type]: action.value };\n  }\n}\n\nfunction useResizeState(\n  props: IResizeGroupProps,\n  nextResizeGroupStateProvider: ReturnType<typeof getNextResizeGroupStateProvider>,\n  rootRef: React.RefObject<HTMLDivElement | null>,\n) {\n  const initialStateData = useConst(() => nextResizeGroupStateProvider.getInitialResizeGroupState(props.data));\n  const [resizeData, dispatchResizeDataAction] = React.useReducer(resizeDataReducer, initialStateData);\n\n  // Reset state when new data is provided\n  React.useEffect(() => {\n    dispatchResizeDataAction({\n      type: 'dataToMeasure',\n      value: props.data,\n    });\n  }, [props.data]);\n\n  // Because it's possible that we may force more than one re-render per animation frame, we\n  // want to make sure that the RAF request is using the most recent data.\n  const stateRef = React.useRef<IResizeGroupState>(initialStateData);\n  stateRef.current = { ...resizeData };\n\n  const updateResizeState = React.useCallback((nextState?: IResizeGroupState) => {\n    if (nextState) {\n      dispatchResizeDataAction({\n        type: 'resizeData',\n        value: nextState,\n      });\n    }\n  }, []);\n\n  const remeasure: () => void = React.useCallback(() => {\n    if (rootRef.current) {\n      dispatchResizeDataAction({\n        type: 'measureContainer',\n        value: true,\n      });\n    }\n  }, [rootRef]);\n\n  return [stateRef, updateResizeState, remeasure] as const;\n}\n\nfunction useResizingBehavior(props: IResizeGroupProps, rootRef: React.RefObject<HTMLDivElement | null>) {\n  const nextResizeGroupStateProvider = useConst(getNextResizeGroupStateProvider);\n\n  // A div that can be used for the initial measurement so that we can avoid mounting a second instance\n  // of the component being measured for the initial render.\n  const initialHiddenDiv = React.useRef<HTMLDivElement | null>(null);\n  // A hidden div that is used for mounting a new instance of the component for measurement in a hidden\n  // div without unmounting the currently visible content.\n  const updateHiddenDiv = React.useRef<HTMLDivElement | null>(null);\n\n  // Tracks if any content has been rendered to the user. This enables us to do some performance optimizations\n  // for the initial render.\n  const hasRenderedContent = React.useRef(false);\n\n  const async: Async = useAsync();\n\n  const [stateRef, updateResizeState, remeasure] = useResizeState(props, nextResizeGroupStateProvider, rootRef);\n\n  React.useEffect(() => {\n    if (stateRef.current.renderedData) {\n      hasRenderedContent.current = true;\n      props.dataDidRender?.(stateRef.current.renderedData);\n    }\n  });\n\n  React.useEffect((): void => {\n    async.requestAnimationFrame(() => {\n      let containerDimension = undefined;\n      if (stateRef.current.measureContainer && rootRef.current) {\n        const boundingRect = rootRef.current.getBoundingClientRect();\n        containerDimension =\n          props.direction === ResizeGroupDirection.vertical ? boundingRect.height : boundingRect.width;\n      }\n      const nextState = nextResizeGroupStateProvider.getNextState(\n        props,\n        stateRef.current,\n        () => {\n          const refToMeasure = !hasRenderedContent.current ? initialHiddenDiv : updateHiddenDiv;\n          if (!refToMeasure.current) {\n            return 0;\n          }\n          const measuredBoundingRect = refToMeasure.current.getBoundingClientRect();\n          return props.direction === ResizeGroupDirection.vertical\n            ? measuredBoundingRect.height\n            : measuredBoundingRect.width;\n        },\n        containerDimension,\n      );\n\n      updateResizeState(nextState);\n    }, rootRef.current);\n  });\n\n  const win = useWindow();\n  useOnEvent(win, 'resize', async.debounce(remeasure, RESIZE_DELAY, { leading: true }));\n\n  const dataNeedsMeasuring = nextResizeGroupStateProvider.shouldRenderDataForMeasurement(\n    stateRef.current.dataToMeasure,\n  );\n\n  const isInitialMeasure = !hasRenderedContent.current && dataNeedsMeasuring;\n\n  return [\n    stateRef.current.dataToMeasure,\n    stateRef.current.renderedData,\n    remeasure,\n    initialHiddenDiv,\n    updateHiddenDiv,\n    dataNeedsMeasuring,\n    isInitialMeasure,\n  ] as const;\n}\n\nfunction useDebugWarnings(props: IResizeGroupProps) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      deprecations: { styles: 'className' },\n    });\n  }\n}\n\nconst measuredContextValue = { isMeasured: true };\n\nexport const ResizeGroupBase: React.FunctionComponent<IResizeGroupProps> = React.forwardRef<\n  HTMLDivElement,\n  IResizeGroupProps\n>((props, forwardedRef) => {\n  const rootRef = React.useRef<HTMLDivElement | null>(null);\n  // The root div which is the container inside of which we are trying to fit content.\n  const mergedRootRef = useMergedRefs(rootRef, forwardedRef);\n\n  const [\n    dataToMeasure,\n    renderedData,\n    remeasure,\n    initialHiddenDiv,\n    updateHiddenDiv,\n    dataNeedsMeasuring,\n    isInitialMeasure,\n  ] = useResizingBehavior(props, rootRef);\n\n  React.useImperativeHandle(props.componentRef, () => ({ remeasure }), [remeasure]);\n\n  useDebugWarnings(props);\n\n  const { className, onRenderData } = props;\n  const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, divProperties, ['data']);\n\n  // We only ever render the final content to the user. All measurements are done in a hidden div.\n  // For the initial render, we want this to be as fast as possible, so we need to make sure that we only mount one\n  // version of the component for measurement and the final render. For renders that update what is on screen, we\n  // want to make sure that there are no jarring effects such as the screen flashing as we apply scaling steps for\n  // measurement. In the update case, we mount a second version of the component just for measurement purposes and\n  // leave the rendered content untouched until we know the next state to show to the user.\n  return (\n    <div {...divProps} className={className} ref={mergedRootRef}>\n      <div style={hiddenParentStyles}>\n        {dataNeedsMeasuring && !isInitialMeasure && (\n          <div style={hiddenDivStyles} ref={updateHiddenDiv}>\n            <MeasuredContext.Provider value={measuredContextValue}>\n              {onRenderData(dataToMeasure)}\n            </MeasuredContext.Provider>\n          </div>\n        )}\n\n        <div\n          ref={initialHiddenDiv}\n          style={isInitialMeasure ? hiddenDivStyles : undefined}\n          data-automation-id=\"visibleContent\"\n        >\n          {isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData)}\n        </div>\n      </div>\n    </div>\n  );\n});\nResizeGroupBase.displayName = 'ResizeGroupBase';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}