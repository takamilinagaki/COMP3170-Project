{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, classNamesFunction, divProperties, getNativeProps, getRTL, initializeComponentRef } from '../../Utilities';\nimport { ScrollablePaneContext } from './ScrollablePane.types';\nvar getClassNames = classNamesFunction();\nvar ScrollablePaneBase = /** @class */function (_super) {\n  __extends(ScrollablePaneBase, _super);\n  function ScrollablePaneBase(props) {\n    var _this = _super.call(this, props) || this;\n    _this._root = React.createRef();\n    _this._stickyAboveRef = React.createRef();\n    _this._stickyBelowRef = React.createRef();\n    _this._contentContainer = React.createRef();\n    _this.subscribe = function (handler) {\n      _this._subscribers.add(handler);\n    };\n    _this.unsubscribe = function (handler) {\n      _this._subscribers.delete(handler);\n    };\n    _this.addSticky = function (sticky) {\n      _this._stickies.add(sticky);\n      // If ScrollablePane is mounted, then sort sticky in correct place\n      if (_this.contentContainer) {\n        sticky.setDistanceFromTop(_this.contentContainer);\n        _this.sortSticky(sticky);\n      }\n    };\n    _this.removeSticky = function (sticky) {\n      _this._stickies.delete(sticky);\n      _this._removeStickyFromContainers(sticky);\n      _this.notifySubscribers();\n    };\n    _this.sortSticky = function (sticky, sortAgain) {\n      if (_this.stickyAbove && _this.stickyBelow) {\n        if (sortAgain) {\n          _this._removeStickyFromContainers(sticky);\n        }\n        if (sticky.canStickyTop && sticky.stickyContentTop) {\n          _this._addToStickyContainer(sticky, _this.stickyAbove, sticky.stickyContentTop);\n        }\n        if (sticky.canStickyBottom && sticky.stickyContentBottom) {\n          _this._addToStickyContainer(sticky, _this.stickyBelow, sticky.stickyContentBottom);\n        }\n      }\n    };\n    _this.updateStickyRefHeights = function () {\n      var stickyItems = _this._stickies;\n      var stickyTopHeight = 0;\n      var stickyBottomHeight = 0;\n      stickyItems.forEach(function (sticky) {\n        var _a = sticky.state,\n          isStickyTop = _a.isStickyTop,\n          isStickyBottom = _a.isStickyBottom;\n        if (sticky.nonStickyContent) {\n          if (isStickyTop) {\n            stickyTopHeight += sticky.nonStickyContent.offsetHeight;\n          }\n          if (isStickyBottom) {\n            stickyBottomHeight += sticky.nonStickyContent.offsetHeight;\n          }\n          _this._checkStickyStatus(sticky);\n        }\n      });\n      _this.setState({\n        stickyTopHeight: stickyTopHeight,\n        stickyBottomHeight: stickyBottomHeight\n      });\n    };\n    _this.notifySubscribers = function () {\n      if (_this.contentContainer) {\n        _this._subscribers.forEach(function (handle) {\n          // this.stickyBelow is passed in for calculating distance to determine Sticky status\n          handle(_this.contentContainer, _this.stickyBelow);\n        });\n      }\n    };\n    _this.getScrollPosition = function () {\n      if (_this.contentContainer) {\n        return _this.contentContainer.scrollTop;\n      }\n      return 0;\n    };\n    _this.syncScrollSticky = function (sticky) {\n      if (sticky && _this.contentContainer) {\n        sticky.syncScroll(_this.contentContainer);\n      }\n    };\n    _this._getScrollablePaneContext = function () {\n      return {\n        scrollablePane: {\n          subscribe: _this.subscribe,\n          unsubscribe: _this.unsubscribe,\n          addSticky: _this.addSticky,\n          removeSticky: _this.removeSticky,\n          updateStickyRefHeights: _this.updateStickyRefHeights,\n          sortSticky: _this.sortSticky,\n          notifySubscribers: _this.notifySubscribers,\n          syncScrollSticky: _this.syncScrollSticky\n        }\n      };\n    };\n    _this._addToStickyContainer = function (sticky, stickyContainer, stickyContentToAdd) {\n      // If there's no children, append child to list, otherwise, sort though array and append at correct position\n      if (!stickyContainer.children.length) {\n        stickyContainer.appendChild(stickyContentToAdd);\n      } else {\n        // If stickyContentToAdd isn't a child element of target container, then append\n        if (!stickyContainer.contains(stickyContentToAdd)) {\n          var stickyChildrenElements_1 = [].slice.call(stickyContainer.children);\n          var stickyList_1 = [];\n          // Get stickies.  Filter by canStickyTop/Bottom, then sort by distance from top, and then\n          // filter by elements that are in the stickyContainer already.\n          _this._stickies.forEach(function (stickyItem) {\n            if (stickyContainer === _this.stickyAbove && sticky.canStickyTop) {\n              stickyList_1.push(stickyItem);\n            } else if (sticky.canStickyBottom) {\n              stickyList_1.push(stickyItem);\n            }\n          });\n          var stickyListSorted = stickyList_1.sort(function (a, b) {\n            return (a.state.distanceFromTop || 0) - (b.state.distanceFromTop || 0);\n          }).filter(function (item) {\n            var stickyContent = stickyContainer === _this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;\n            if (stickyContent) {\n              return stickyChildrenElements_1.indexOf(stickyContent) > -1;\n            }\n            return false;\n          });\n          // Get first element that has a distance from top that is further than our sticky that is being added\n          var targetStickyToAppendBefore = undefined;\n          for (var _i = 0, stickyListSorted_1 = stickyListSorted; _i < stickyListSorted_1.length; _i++) {\n            var stickyListItem = stickyListSorted_1[_i];\n            if ((stickyListItem.state.distanceFromTop || 0) >= (sticky.state.distanceFromTop || 0)) {\n              targetStickyToAppendBefore = stickyListItem;\n              break;\n            }\n          }\n          // If target element to append before is known, grab respective stickyContentTop/Bottom element\n          // and insert before\n          var targetContainer = null;\n          if (targetStickyToAppendBefore) {\n            targetContainer = stickyContainer === _this.stickyAbove ? targetStickyToAppendBefore.stickyContentTop : targetStickyToAppendBefore.stickyContentBottom;\n          }\n          stickyContainer.insertBefore(stickyContentToAdd, targetContainer);\n        }\n      }\n    };\n    _this._removeStickyFromContainers = function (sticky) {\n      if (_this.stickyAbove && sticky.stickyContentTop && _this.stickyAbove.contains(sticky.stickyContentTop)) {\n        _this.stickyAbove.removeChild(sticky.stickyContentTop);\n      }\n      if (_this.stickyBelow && sticky.stickyContentBottom && _this.stickyBelow.contains(sticky.stickyContentBottom)) {\n        _this.stickyBelow.removeChild(sticky.stickyContentBottom);\n      }\n    };\n    _this._onWindowResize = function () {\n      var scrollbarWidth = _this._getScrollbarWidth();\n      var scrollbarHeight = _this._getScrollbarHeight();\n      _this.setState({\n        scrollbarWidth: scrollbarWidth,\n        scrollbarHeight: scrollbarHeight\n      });\n      _this.notifySubscribers();\n    };\n    _this._getStickyContainerStyle = function (height, isTop) {\n      return __assign(__assign({\n        height: height\n      }, getRTL(_this.props.theme) ? {\n        right: '0',\n        left: \"\".concat(_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0, \"px\")\n      } : {\n        left: '0',\n        right: \"\".concat(_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0, \"px\")\n      }), isTop ? {\n        top: '0'\n      } : {\n        bottom: \"\".concat(_this.state.scrollbarHeight || _this._getScrollbarHeight() || 0, \"px\")\n      });\n    };\n    _this._onScroll = function () {\n      var contentContainer = _this.contentContainer;\n      if (contentContainer) {\n        _this._stickies.forEach(function (sticky) {\n          sticky.syncScroll(contentContainer);\n        });\n      }\n      _this._notifyThrottled();\n    };\n    _this._subscribers = new Set();\n    _this._stickies = new Set();\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this.state = {\n      stickyTopHeight: 0,\n      stickyBottomHeight: 0,\n      scrollbarWidth: 0,\n      scrollbarHeight: 0\n    };\n    _this._notifyThrottled = _this._async.throttle(_this.notifySubscribers, 50);\n    return _this;\n  }\n  Object.defineProperty(ScrollablePaneBase.prototype, \"root\", {\n    get: function () {\n      return this._root.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"stickyAbove\", {\n    get: function () {\n      return this._stickyAboveRef.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"stickyBelow\", {\n    get: function () {\n      return this._stickyBelowRef.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"contentContainer\", {\n    get: function () {\n      return this._contentContainer.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ScrollablePaneBase.prototype.componentDidMount = function () {\n    var _this = this;\n    var initialScrollPosition = this.props.initialScrollPosition;\n    this._events.on(this.contentContainer, 'scroll', this._onScroll);\n    this._events.on(window, 'resize', this._onWindowResize);\n    if (this.contentContainer && initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n    // Set sticky distances from top property, then sort in correct order and notify subscribers\n    this.setStickiesDistanceFromTop();\n    this._stickies.forEach(function (sticky) {\n      _this.sortSticky(sticky);\n    });\n    this.notifySubscribers();\n    if ('MutationObserver' in window) {\n      this._mutationObserver = new MutationObserver(function (mutation) {\n        // Function to check if mutation is occuring in stickyAbove or stickyBelow\n        function checkIfMutationIsSticky(mutationRecord) {\n          if (this.stickyAbove !== null && this.stickyBelow !== null) {\n            return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);\n          }\n          return false;\n        }\n        // Compute the scrollbar height, which might have changed if the content's width changed and caused overflow\n        var scrollbarHeight = _this._getScrollbarHeight();\n        // If the scrollbar height changed, update state so it's postioned correctly below sticky footer\n        if (scrollbarHeight !== _this.state.scrollbarHeight) {\n          _this.setState({\n            scrollbarHeight: scrollbarHeight\n          });\n        }\n        // Notify subscribers again to re-check whether Sticky should be Sticky'd or not\n        _this.notifySubscribers();\n        // If mutation occurs in sticky header or footer, then update sticky top/bottom heights\n        if (mutation.some(checkIfMutationIsSticky.bind(_this))) {\n          _this.updateStickyRefHeights();\n        } else {\n          // If mutation occurs in scrollable region, then find Sticky it belongs to and force update\n          var stickyList_2 = [];\n          _this._stickies.forEach(function (sticky) {\n            if (sticky.root && sticky.root.contains(mutation[0].target)) {\n              stickyList_2.push(sticky);\n            }\n          });\n          if (stickyList_2.length) {\n            stickyList_2.forEach(function (sticky) {\n              sticky.forceUpdate();\n            });\n          }\n        }\n      });\n      if (this.root) {\n        this._mutationObserver.observe(this.root, {\n          childList: true,\n          attributes: true,\n          subtree: true,\n          characterData: true\n        });\n      }\n    }\n  };\n  ScrollablePaneBase.prototype.componentWillUnmount = function () {\n    this._events.dispose();\n    this._async.dispose();\n    if (this._mutationObserver) {\n      this._mutationObserver.disconnect();\n    }\n  };\n  // Only updates if props/state change, just to prevent excessive setState with updateStickyRefHeights\n  ScrollablePaneBase.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    return this.props.children !== nextProps.children || this.props.initialScrollPosition !== nextProps.initialScrollPosition || this.props.className !== nextProps.className || this.state.stickyTopHeight !== nextState.stickyTopHeight || this.state.stickyBottomHeight !== nextState.stickyBottomHeight || this.state.scrollbarWidth !== nextState.scrollbarWidth || this.state.scrollbarHeight !== nextState.scrollbarHeight;\n  };\n  ScrollablePaneBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var initialScrollPosition = this.props.initialScrollPosition;\n    if (this.contentContainer && typeof initialScrollPosition === 'number' && prevProps.initialScrollPosition !== initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n    // Update subscribers when stickyTopHeight/stickyBottomHeight changes\n    if (prevState.stickyTopHeight !== this.state.stickyTopHeight || prevState.stickyBottomHeight !== this.state.stickyBottomHeight) {\n      this.notifySubscribers();\n    }\n    this._async.setTimeout(this._onWindowResize, 0);\n  };\n  ScrollablePaneBase.prototype.render = function () {\n    var _a = this.props,\n      className = _a.className,\n      scrollContainerFocus = _a.scrollContainerFocus,\n      scrollContainerAriaLabel = _a.scrollContainerAriaLabel,\n      theme = _a.theme,\n      styles = _a.styles,\n      onScroll = _a.onScroll;\n    var _b = this.state,\n      stickyTopHeight = _b.stickyTopHeight,\n      stickyBottomHeight = _b.stickyBottomHeight;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      scrollbarVisibility: this.props.scrollbarVisibility\n    });\n    var scrollContainerProps = scrollContainerFocus ? {\n      role: 'group',\n      tabIndex: 0,\n      'aria-label': scrollContainerAriaLabel,\n      onScroll: onScroll\n    } : {\n      onScroll: onScroll\n    };\n    return React.createElement(\"div\", __assign({}, getNativeProps(__assign({}, this.props), divProperties,\n    // on React 17 onScroll is not being invoked on root element,\n    // as a fix this method will be provided to the container element\n    ['onScroll']), {\n      ref: this._root,\n      className: classNames.root\n    }), React.createElement(\"div\", {\n      ref: this._stickyAboveRef,\n      className: classNames.stickyAbove,\n      style: this._getStickyContainerStyle(stickyTopHeight, true)\n    }), React.createElement(\"div\", __assign({\n      ref: this._contentContainer\n    }, scrollContainerProps, {\n      className: classNames.contentContainer,\n      \"data-is-scrollable\": true\n    }), React.createElement(ScrollablePaneContext.Provider, {\n      value: this._getScrollablePaneContext()\n    }, this.props.children)), React.createElement(\"div\", {\n      className: classNames.stickyBelow,\n      style: this._getStickyContainerStyle(stickyBottomHeight, false)\n    }, React.createElement(\"div\", {\n      ref: this._stickyBelowRef,\n      className: classNames.stickyBelowItems\n    })));\n  };\n  ScrollablePaneBase.prototype.setStickiesDistanceFromTop = function () {\n    var _this = this;\n    if (this.contentContainer) {\n      this._stickies.forEach(function (sticky) {\n        sticky.setDistanceFromTop(_this.contentContainer);\n      });\n    }\n  };\n  ScrollablePaneBase.prototype.forceLayoutUpdate = function () {\n    this._onWindowResize();\n  };\n  ScrollablePaneBase.prototype._checkStickyStatus = function (sticky) {\n    if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {\n      // If sticky is sticky, then append content to appropriate container\n      if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {\n        if (sticky.state.isStickyTop && !this.stickyAbove.contains(sticky.nonStickyContent) && sticky.stickyContentTop) {\n          sticky.addSticky(sticky.stickyContentTop);\n        }\n        if (sticky.state.isStickyBottom && !this.stickyBelow.contains(sticky.nonStickyContent) && sticky.stickyContentBottom) {\n          sticky.addSticky(sticky.stickyContentBottom);\n        }\n      } else if (!this.contentContainer.contains(sticky.nonStickyContent)) {\n        // Reset sticky if it's not sticky and not in the contentContainer element\n        sticky.resetSticky();\n      }\n    }\n  };\n  ScrollablePaneBase.prototype._getScrollbarWidth = function () {\n    var contentContainer = this.contentContainer;\n    return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : 0;\n  };\n  ScrollablePaneBase.prototype._getScrollbarHeight = function () {\n    var contentContainer = this.contentContainer;\n    return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : 0;\n  };\n  return ScrollablePaneBase;\n}(React.Component);\nexport { ScrollablePaneBase };","map":{"version":3,"names":["React","Async","EventGroup","classNamesFunction","divProperties","getNativeProps","getRTL","initializeComponentRef","ScrollablePaneContext","getClassNames","ScrollablePaneBase","_super","__extends","props","_this","call","_root","createRef","_stickyAboveRef","_stickyBelowRef","_contentContainer","subscribe","handler","_subscribers","add","unsubscribe","delete","addSticky","sticky","_stickies","contentContainer","setDistanceFromTop","sortSticky","removeSticky","_removeStickyFromContainers","notifySubscribers","sortAgain","stickyAbove","stickyBelow","canStickyTop","stickyContentTop","_addToStickyContainer","canStickyBottom","stickyContentBottom","updateStickyRefHeights","stickyItems","stickyTopHeight","stickyBottomHeight","forEach","_a","state","isStickyTop","isStickyBottom","nonStickyContent","offsetHeight","_checkStickyStatus","setState","handle","getScrollPosition","scrollTop","syncScrollSticky","syncScroll","_getScrollablePaneContext","scrollablePane","stickyContainer","stickyContentToAdd","children","length","appendChild","contains","stickyChildrenElements_1","slice","stickyList_1","stickyItem","push","stickyListSorted","sort","a","b","distanceFromTop","filter","item","stickyContent","indexOf","targetStickyToAppendBefore","undefined","_i","stickyListSorted_1","stickyListItem","targetContainer","insertBefore","removeChild","_onWindowResize","scrollbarWidth","_getScrollbarWidth","scrollbarHeight","_getScrollbarHeight","_getStickyContainerStyle","height","isTop","__assign","theme","right","left","concat","top","bottom","_onScroll","_notifyThrottled","Set","_async","_events","throttle","Object","defineProperty","prototype","get","current","componentDidMount","initialScrollPosition","on","window","setStickiesDistanceFromTop","_mutationObserver","MutationObserver","mutation","checkIfMutationIsSticky","mutationRecord","target","some","bind","stickyList_2","root","forceUpdate","observe","childList","attributes","subtree","characterData","componentWillUnmount","dispose","disconnect","shouldComponentUpdate","nextProps","nextState","className","componentDidUpdate","prevProps","prevState","setTimeout","render","scrollContainerFocus","scrollContainerAriaLabel","styles","onScroll","_b","classNames","scrollbarVisibility","scrollContainerProps","role","tabIndex","createElement","ref","style","Provider","value","stickyBelowItems","forceLayoutUpdate","resetSticky","offsetWidth","clientWidth","clientHeight","Component"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/components/src/components/ScrollablePane/ScrollablePane.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  EventGroup,\n  classNamesFunction,\n  divProperties,\n  getNativeProps,\n  getRTL,\n  initializeComponentRef,\n} from '../../Utilities';\nimport { ScrollablePaneContext } from './ScrollablePane.types';\nimport { Sticky } from '../../Sticky';\nimport type {\n  IScrollablePane,\n  IScrollablePaneContext,\n  IScrollablePaneProps,\n  IScrollablePaneStyleProps,\n  IScrollablePaneStyles,\n} from './ScrollablePane.types';\n\nexport interface IScrollablePaneState {\n  stickyTopHeight: number;\n  stickyBottomHeight: number;\n  scrollbarWidth: number;\n  scrollbarHeight: number;\n}\n\nconst getClassNames = classNamesFunction<IScrollablePaneStyleProps, IScrollablePaneStyles>();\n\nexport class ScrollablePaneBase\n  extends React.Component<IScrollablePaneProps, IScrollablePaneState>\n  implements IScrollablePane\n{\n  private _root = React.createRef<HTMLDivElement>();\n  private _stickyAboveRef = React.createRef<HTMLDivElement>();\n  private _stickyBelowRef = React.createRef<HTMLDivElement>();\n  private _contentContainer = React.createRef<HTMLDivElement>();\n  private _subscribers: Set<Function>;\n  private _stickies: Set<Sticky>;\n  private _mutationObserver: MutationObserver;\n  private _notifyThrottled: () => void;\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IScrollablePaneProps) {\n    super(props);\n    this._subscribers = new Set<Function>();\n    this._stickies = new Set<Sticky>();\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    this.state = {\n      stickyTopHeight: 0,\n      stickyBottomHeight: 0,\n      scrollbarWidth: 0,\n      scrollbarHeight: 0,\n    };\n\n    this._notifyThrottled = this._async.throttle(this.notifySubscribers, 50);\n  }\n\n  public get root(): HTMLDivElement | null {\n    return this._root.current;\n  }\n\n  public get stickyAbove(): HTMLDivElement | null {\n    return this._stickyAboveRef.current;\n  }\n\n  public get stickyBelow(): HTMLDivElement | null {\n    return this._stickyBelowRef.current;\n  }\n\n  public get contentContainer(): HTMLDivElement | null {\n    return this._contentContainer.current;\n  }\n\n  public componentDidMount() {\n    const { initialScrollPosition } = this.props;\n    this._events.on(this.contentContainer, 'scroll', this._onScroll);\n    this._events.on(window, 'resize', this._onWindowResize);\n    if (this.contentContainer && initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n\n    // Set sticky distances from top property, then sort in correct order and notify subscribers\n    this.setStickiesDistanceFromTop();\n    this._stickies.forEach(sticky => {\n      this.sortSticky(sticky);\n    });\n    this.notifySubscribers();\n\n    if ('MutationObserver' in window) {\n      this._mutationObserver = new MutationObserver(mutation => {\n        // Function to check if mutation is occuring in stickyAbove or stickyBelow\n        function checkIfMutationIsSticky(mutationRecord: MutationRecord): boolean {\n          if (this.stickyAbove !== null && this.stickyBelow !== null) {\n            return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);\n          }\n          return false;\n        }\n\n        // Compute the scrollbar height, which might have changed if the content's width changed and caused overflow\n        const scrollbarHeight = this._getScrollbarHeight();\n        // If the scrollbar height changed, update state so it's postioned correctly below sticky footer\n        if (scrollbarHeight !== this.state.scrollbarHeight) {\n          this.setState({\n            scrollbarHeight,\n          });\n        }\n\n        // Notify subscribers again to re-check whether Sticky should be Sticky'd or not\n        this.notifySubscribers();\n\n        // If mutation occurs in sticky header or footer, then update sticky top/bottom heights\n        if (mutation.some(checkIfMutationIsSticky.bind(this))) {\n          this.updateStickyRefHeights();\n        } else {\n          // If mutation occurs in scrollable region, then find Sticky it belongs to and force update\n          const stickyList: Sticky[] = [];\n          this._stickies.forEach(sticky => {\n            if (sticky.root && sticky.root.contains(mutation[0].target)) {\n              stickyList.push(sticky);\n            }\n          });\n          if (stickyList.length) {\n            stickyList.forEach(sticky => {\n              sticky.forceUpdate();\n            });\n          }\n        }\n      });\n\n      if (this.root) {\n        this._mutationObserver.observe(this.root, {\n          childList: true,\n          attributes: true,\n          subtree: true,\n          characterData: true,\n        });\n      }\n    }\n  }\n\n  public componentWillUnmount() {\n    this._events.dispose();\n    this._async.dispose();\n\n    if (this._mutationObserver) {\n      this._mutationObserver.disconnect();\n    }\n  }\n\n  // Only updates if props/state change, just to prevent excessive setState with updateStickyRefHeights\n  public shouldComponentUpdate(nextProps: IScrollablePaneProps, nextState: IScrollablePaneState): boolean {\n    return (\n      this.props.children !== nextProps.children ||\n      this.props.initialScrollPosition !== nextProps.initialScrollPosition ||\n      this.props.className !== nextProps.className ||\n      this.state.stickyTopHeight !== nextState.stickyTopHeight ||\n      this.state.stickyBottomHeight !== nextState.stickyBottomHeight ||\n      this.state.scrollbarWidth !== nextState.scrollbarWidth ||\n      this.state.scrollbarHeight !== nextState.scrollbarHeight\n    );\n  }\n\n  public componentDidUpdate(prevProps: IScrollablePaneProps, prevState: IScrollablePaneState) {\n    const initialScrollPosition = this.props.initialScrollPosition;\n    if (\n      this.contentContainer &&\n      typeof initialScrollPosition === 'number' &&\n      prevProps.initialScrollPosition !== initialScrollPosition\n    ) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n\n    // Update subscribers when stickyTopHeight/stickyBottomHeight changes\n    if (\n      prevState.stickyTopHeight !== this.state.stickyTopHeight ||\n      prevState.stickyBottomHeight !== this.state.stickyBottomHeight\n    ) {\n      this.notifySubscribers();\n    }\n\n    this._async.setTimeout(this._onWindowResize, 0);\n  }\n\n  public render(): JSX.Element {\n    const { className, scrollContainerFocus, scrollContainerAriaLabel, theme, styles, onScroll } = this.props;\n    const { stickyTopHeight, stickyBottomHeight } = this.state;\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      scrollbarVisibility: this.props.scrollbarVisibility,\n    });\n\n    const scrollContainerProps = scrollContainerFocus\n      ? {\n          role: 'group',\n          tabIndex: 0,\n          'aria-label': scrollContainerAriaLabel,\n          onScroll,\n        }\n      : {\n          onScroll,\n        };\n\n    return (\n      <div\n        {...getNativeProps(\n          {\n            ...this.props,\n          },\n          divProperties,\n          // on React 17 onScroll is not being invoked on root element,\n          // as a fix this method will be provided to the container element\n          ['onScroll'],\n        )}\n        ref={this._root}\n        className={classNames.root}\n      >\n        <div\n          ref={this._stickyAboveRef}\n          className={classNames.stickyAbove}\n          style={this._getStickyContainerStyle(stickyTopHeight, true)}\n        />\n        <div\n          ref={this._contentContainer}\n          {...scrollContainerProps}\n          className={classNames.contentContainer}\n          data-is-scrollable={true}\n        >\n          <ScrollablePaneContext.Provider value={this._getScrollablePaneContext()}>\n            {this.props.children}\n          </ScrollablePaneContext.Provider>\n        </div>\n        <div className={classNames.stickyBelow} style={this._getStickyContainerStyle(stickyBottomHeight, false)}>\n          <div ref={this._stickyBelowRef} className={classNames.stickyBelowItems} />\n        </div>\n      </div>\n    );\n  }\n\n  public setStickiesDistanceFromTop(): void {\n    if (this.contentContainer) {\n      this._stickies.forEach(sticky => {\n        sticky.setDistanceFromTop(this.contentContainer as HTMLDivElement);\n      });\n    }\n  }\n\n  public forceLayoutUpdate() {\n    this._onWindowResize();\n  }\n\n  public subscribe = (handler: Function): void => {\n    this._subscribers.add(handler);\n  };\n\n  public unsubscribe = (handler: Function): void => {\n    this._subscribers.delete(handler);\n  };\n\n  public addSticky = (sticky: Sticky): void => {\n    this._stickies.add(sticky);\n\n    // If ScrollablePane is mounted, then sort sticky in correct place\n    if (this.contentContainer) {\n      sticky.setDistanceFromTop(this.contentContainer);\n      this.sortSticky(sticky);\n    }\n  };\n\n  public removeSticky = (sticky: Sticky): void => {\n    this._stickies.delete(sticky);\n    this._removeStickyFromContainers(sticky);\n    this.notifySubscribers();\n  };\n\n  public sortSticky = (sticky: Sticky, sortAgain?: boolean): void => {\n    if (this.stickyAbove && this.stickyBelow) {\n      if (sortAgain) {\n        this._removeStickyFromContainers(sticky);\n      }\n      if (sticky.canStickyTop && sticky.stickyContentTop) {\n        this._addToStickyContainer(sticky, this.stickyAbove, sticky.stickyContentTop);\n      }\n\n      if (sticky.canStickyBottom && sticky.stickyContentBottom) {\n        this._addToStickyContainer(sticky, this.stickyBelow, sticky.stickyContentBottom);\n      }\n    }\n  };\n\n  public updateStickyRefHeights = (): void => {\n    const stickyItems = this._stickies;\n\n    let stickyTopHeight = 0;\n    let stickyBottomHeight = 0;\n\n    stickyItems.forEach((sticky: Sticky) => {\n      const { isStickyTop, isStickyBottom } = sticky.state;\n      if (sticky.nonStickyContent) {\n        if (isStickyTop) {\n          stickyTopHeight += sticky.nonStickyContent.offsetHeight;\n        }\n        if (isStickyBottom) {\n          stickyBottomHeight += sticky.nonStickyContent.offsetHeight;\n        }\n        this._checkStickyStatus(sticky);\n      }\n    });\n\n    this.setState({\n      stickyTopHeight,\n      stickyBottomHeight,\n    });\n  };\n\n  public notifySubscribers = (): void => {\n    if (this.contentContainer) {\n      this._subscribers.forEach(handle => {\n        // this.stickyBelow is passed in for calculating distance to determine Sticky status\n        handle(this.contentContainer, this.stickyBelow);\n      });\n    }\n  };\n\n  public getScrollPosition = (): number => {\n    if (this.contentContainer) {\n      return this.contentContainer.scrollTop;\n    }\n\n    return 0;\n  };\n\n  public syncScrollSticky = (sticky: Sticky): void => {\n    if (sticky && this.contentContainer) {\n      sticky.syncScroll(this.contentContainer);\n    }\n  };\n\n  private _getScrollablePaneContext = (): IScrollablePaneContext => {\n    return {\n      scrollablePane: {\n        subscribe: this.subscribe,\n        unsubscribe: this.unsubscribe,\n        addSticky: this.addSticky,\n        removeSticky: this.removeSticky,\n        updateStickyRefHeights: this.updateStickyRefHeights,\n        sortSticky: this.sortSticky,\n        notifySubscribers: this.notifySubscribers,\n        syncScrollSticky: this.syncScrollSticky,\n      },\n    };\n  };\n\n  private _checkStickyStatus(sticky: Sticky): void {\n    if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {\n      // If sticky is sticky, then append content to appropriate container\n      if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {\n        if (\n          sticky.state.isStickyTop &&\n          !this.stickyAbove.contains(sticky.nonStickyContent) &&\n          sticky.stickyContentTop\n        ) {\n          sticky.addSticky(sticky.stickyContentTop);\n        }\n\n        if (\n          sticky.state.isStickyBottom &&\n          !this.stickyBelow.contains(sticky.nonStickyContent) &&\n          sticky.stickyContentBottom\n        ) {\n          sticky.addSticky(sticky.stickyContentBottom);\n        }\n      } else if (!this.contentContainer.contains(sticky.nonStickyContent)) {\n        // Reset sticky if it's not sticky and not in the contentContainer element\n        sticky.resetSticky();\n      }\n    }\n  }\n\n  private _addToStickyContainer = (\n    sticky: Sticky,\n    stickyContainer: HTMLDivElement,\n    stickyContentToAdd: HTMLDivElement,\n  ): void => {\n    // If there's no children, append child to list, otherwise, sort though array and append at correct position\n    if (!stickyContainer.children.length) {\n      stickyContainer.appendChild(stickyContentToAdd);\n    } else {\n      // If stickyContentToAdd isn't a child element of target container, then append\n      if (!stickyContainer.contains(stickyContentToAdd)) {\n        const stickyChildrenElements: Element[] = [].slice.call(stickyContainer.children);\n\n        const stickyList: Sticky[] = [];\n        // Get stickies.  Filter by canStickyTop/Bottom, then sort by distance from top, and then\n        // filter by elements that are in the stickyContainer already.\n        this._stickies.forEach(stickyItem => {\n          if (stickyContainer === this.stickyAbove && sticky.canStickyTop) {\n            stickyList.push(stickyItem);\n          } else if (sticky.canStickyBottom) {\n            stickyList.push(stickyItem);\n          }\n        });\n\n        const stickyListSorted = stickyList\n          .sort((a, b) => {\n            return (a.state.distanceFromTop || 0) - (b.state.distanceFromTop || 0);\n          })\n          .filter(item => {\n            const stickyContent =\n              stickyContainer === this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;\n            if (stickyContent) {\n              return stickyChildrenElements.indexOf(stickyContent) > -1;\n            }\n            return false;\n          });\n\n        // Get first element that has a distance from top that is further than our sticky that is being added\n        let targetStickyToAppendBefore: Sticky | undefined = undefined;\n        for (const stickyListItem of stickyListSorted) {\n          if ((stickyListItem.state.distanceFromTop || 0) >= (sticky.state.distanceFromTop || 0)) {\n            targetStickyToAppendBefore = stickyListItem;\n            break;\n          }\n        }\n\n        // If target element to append before is known, grab respective stickyContentTop/Bottom element\n        // and insert before\n        let targetContainer: HTMLDivElement | null = null;\n        if (targetStickyToAppendBefore) {\n          targetContainer =\n            stickyContainer === this.stickyAbove\n              ? targetStickyToAppendBefore.stickyContentTop\n              : targetStickyToAppendBefore.stickyContentBottom;\n        }\n        stickyContainer.insertBefore(stickyContentToAdd, targetContainer);\n      }\n    }\n  };\n\n  private _removeStickyFromContainers = (sticky: Sticky): void => {\n    if (this.stickyAbove && sticky.stickyContentTop && this.stickyAbove.contains(sticky.stickyContentTop)) {\n      this.stickyAbove.removeChild(sticky.stickyContentTop);\n    }\n    if (this.stickyBelow && sticky.stickyContentBottom && this.stickyBelow.contains(sticky.stickyContentBottom)) {\n      this.stickyBelow.removeChild(sticky.stickyContentBottom);\n    }\n  };\n\n  private _onWindowResize = (): void => {\n    const scrollbarWidth = this._getScrollbarWidth();\n    const scrollbarHeight = this._getScrollbarHeight();\n\n    this.setState({\n      scrollbarWidth,\n      scrollbarHeight,\n    });\n\n    this.notifySubscribers();\n  };\n\n  private _getStickyContainerStyle = (height: number, isTop: boolean): React.CSSProperties => {\n    return {\n      height,\n      ...(getRTL(this.props.theme)\n        ? {\n            right: '0',\n            left: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`,\n          }\n        : {\n            left: '0',\n            right: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`,\n          }),\n      ...(isTop\n        ? {\n            top: '0',\n          }\n        : {\n            bottom: `${this.state.scrollbarHeight || this._getScrollbarHeight() || 0}px`,\n          }),\n    };\n  };\n\n  private _getScrollbarWidth(): number {\n    const { contentContainer } = this;\n    return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : 0;\n  }\n\n  private _getScrollbarHeight(): number {\n    const { contentContainer } = this;\n    return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : 0;\n  }\n\n  private _onScroll = () => {\n    const { contentContainer } = this;\n\n    if (contentContainer) {\n      this._stickies.forEach((sticky: Sticky) => {\n        sticky.syncScroll(contentContainer);\n      });\n    }\n\n    this._notifyThrottled();\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}