{"ast":null,"code":"import { __assign, __rest, __spreadArray } from \"tslib\";\nimport * as React from 'react';\nimport { ContextualMenuItemType } from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, FocusZoneTabbableElements } from '../../FocusZone';\nimport { divProperties, getNativeProps, shallowCompare, assign, classNamesFunction, css, getFirstFocusable, getLastFocusable, getRTL, KeyCodes, shouldWrapFocus, isIOS, isMac, memoizeFunction, getPropsWithDefaults, getDocument, FocusRects } from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { Callout } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport { ContextualMenuSplitButton, ContextualMenuButton, ContextualMenuAnchor } from './ContextualMenuItemWrapper/index';\nimport { concatStyleSetsWithProps } from '../../Styling';\nimport { getItemStyles } from './ContextualMenu.classNames';\nimport { useTarget, usePrevious, useAsync, useWarnings, useId, useIsomorphicLayoutEffect } from '@fluentui/react-hooks';\nimport { useResponsiveMode, ResponsiveMode } from '../../ResponsiveMode';\nimport { MenuContext } from '../../utilities/MenuContext/index';\nvar getClassNames = classNamesFunction();\nvar getContextualMenuItemClassNames = classNamesFunction();\n// The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\nvar DEFAULT_PROPS = {\n  items: [],\n  shouldFocusOnMount: true,\n  gapSpace: 0,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n  beakWidth: 16\n};\n/* return number of menu items, excluding headers and dividers */\nfunction getItemCount(items) {\n  var totalItemCount = 0;\n  for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n    var item = items_1[_i];\n    if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n      var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n      totalItemCount += itemCount;\n    }\n  }\n  return totalItemCount;\n}\nexport function getSubmenuItems(item, options) {\n  var target = options === null || options === void 0 ? void 0 : options.target;\n  // eslint-disable-next-line deprecation/deprecation\n  var items = item.subMenuProps ? item.subMenuProps.items : item.items;\n  if (items) {\n    var overrideItems = [];\n    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {\n      var subItem = items_2[_i];\n      if (subItem.preferMenuTargetAsEventTarget) {\n        // For sub-items which need an overridden target, intercept `onClick`\n        var onClick = subItem.onClick,\n          contextItem = __rest(subItem, [\"onClick\"]);\n        overrideItems.push(__assign(__assign({}, contextItem), {\n          onClick: getOnClickWithOverrideTarget(onClick, target)\n        }));\n      } else {\n        overrideItems.push(subItem);\n      }\n    }\n    return overrideItems;\n  }\n}\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\nexport function canAnyMenuItemsCheck(items) {\n  return items.some(function (item) {\n    if (item.canCheck) {\n      return true;\n    }\n    // If the item is a section, check if any of the items in the section can check.\n    if (item.sectionProps && item.sectionProps.items.some(function (submenuItem) {\n      return submenuItem.canCheck === true;\n    })) {\n      return true;\n    }\n    return false;\n  });\n}\nvar NavigationIdleDelay = 250; /* ms */\nvar COMPONENT_NAME = 'ContextualMenu';\nvar _getMenuItemStylesFunction = memoizeFunction(function () {\n  var styles = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    styles[_i] = arguments[_i];\n  }\n  return function (styleProps) {\n    return concatStyleSetsWithProps.apply(void 0, __spreadArray([styleProps, getItemStyles], styles, false));\n  };\n});\n//#region Custom hooks\nfunction useVisibility(props, targetWindow) {\n  var _a = props.hidden,\n    hidden = _a === void 0 ? false : _a,\n    onMenuDismissed = props.onMenuDismissed,\n    onMenuOpened = props.onMenuOpened;\n  var previousHidden = usePrevious(hidden);\n  var onMenuOpenedRef = React.useRef(onMenuOpened);\n  var onMenuClosedRef = React.useRef(onMenuDismissed);\n  var propsRef = React.useRef(props);\n  onMenuOpenedRef.current = onMenuOpened;\n  onMenuClosedRef.current = onMenuDismissed;\n  propsRef.current = props;\n  React.useEffect(function () {\n    var _a, _b;\n    // Don't issue dismissed callbacks on initial mount\n    if (hidden && previousHidden === false) {\n      (_a = onMenuClosedRef.current) === null || _a === void 0 ? void 0 : _a.call(onMenuClosedRef, propsRef.current);\n    } else if (!hidden && previousHidden !== false) {\n      (_b = onMenuOpenedRef.current) === null || _b === void 0 ? void 0 : _b.call(onMenuOpenedRef, propsRef.current);\n    }\n  }, [hidden, previousHidden]);\n  // Issue onDismissedCallback on unmount\n  React.useEffect(function () {\n    return function () {\n      var _a;\n      return (_a = onMenuClosedRef.current) === null || _a === void 0 ? void 0 : _a.call(onMenuClosedRef, propsRef.current);\n    };\n  }, []);\n}\nfunction useSubMenuState(_a, dismiss) {\n  var hidden = _a.hidden,\n    items = _a.items,\n    theme = _a.theme,\n    className = _a.className,\n    id = _a.id,\n    menuTarget = _a.target;\n  var _b = React.useState(),\n    expandedMenuItemKey = _b[0],\n    setExpandedMenuItemKey = _b[1];\n  var _c = React.useState(),\n    submenuTarget = _c[0],\n    setSubmenuTarget = _c[1];\n  /** True if the menu was expanded by mouse click OR hover (as opposed to by keyboard) */\n  var _d = React.useState(),\n    shouldFocusOnContainer = _d[0],\n    setShouldFocusOnContainer = _d[1];\n  var subMenuId = useId(COMPONENT_NAME, id);\n  var closeSubMenu = React.useCallback(function () {\n    setShouldFocusOnContainer(undefined);\n    setExpandedMenuItemKey(undefined);\n    setSubmenuTarget(undefined);\n  }, []);\n  var openSubMenu = React.useCallback(function (_a, target, focusContainer) {\n    var submenuItemKey = _a.key;\n    if (expandedMenuItemKey === submenuItemKey) {\n      return;\n    }\n    target.focus();\n    setShouldFocusOnContainer(focusContainer);\n    setExpandedMenuItemKey(submenuItemKey);\n    setSubmenuTarget(target);\n  }, [expandedMenuItemKey]);\n  React.useEffect(function () {\n    if (hidden) {\n      closeSubMenu();\n    }\n  }, [hidden, closeSubMenu]);\n  var onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);\n  var getSubmenuProps = function () {\n    var item = findItemByKeyFromItems(expandedMenuItemKey, items);\n    var submenuProps = null;\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item, {\n          target: menuTarget\n        }),\n        target: submenuTarget,\n        onDismiss: onSubMenuDismiss,\n        isSubMenu: true,\n        id: subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: shouldFocusOnContainer,\n        directionalHint: getRTL(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: className,\n        gapSpace: 0,\n        isBeakVisible: false\n      };\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n      if (item.preferMenuTargetAsEventTarget) {\n        var onItemClick = item.onItemClick;\n        submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);\n      }\n    }\n    return submenuProps;\n  };\n  return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss];\n}\nfunction useShouldUpdateFocusOnMouseMove(_a) {\n  var delayUpdateFocusOnHover = _a.delayUpdateFocusOnHover,\n    hidden = _a.hidden;\n  var shouldUpdateFocusOnMouseEvent = React.useRef(!delayUpdateFocusOnHover);\n  var gotMouseMove = React.useRef(false);\n  React.useEffect(function () {\n    shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;\n    gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;\n  }, [delayUpdateFocusOnHover, hidden]);\n  var onMenuFocusCapture = React.useCallback(function () {\n    if (delayUpdateFocusOnHover) {\n      shouldUpdateFocusOnMouseEvent.current = false;\n    }\n  }, [delayUpdateFocusOnHover]);\n  return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture];\n}\nfunction usePreviousActiveElement(_a, targetWindow, hostElement) {\n  var hidden = _a.hidden,\n    onRestoreFocus = _a.onRestoreFocus;\n  var previousActiveElement = React.useRef();\n  var tryFocusPreviousActiveElement = React.useCallback(function (options) {\n    var _a, _b;\n    if (onRestoreFocus) {\n      onRestoreFocus(options);\n    } else if (options === null || options === void 0 ? void 0 : options.documentContainsFocus) {\n      // Make sure that the focus method actually exists\n      // In some cases the object might exist but not be a real element.\n      // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n      (_b = (_a = previousActiveElement.current) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }, [onRestoreFocus]);\n  useIsomorphicLayoutEffect(function () {\n    var _a, _b;\n    if (!hidden) {\n      var newElement = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement;\n      if (!((_a = hostElement.current) === null || _a === void 0 ? void 0 : _a.contains(newElement)) && newElement.tagName !== 'BODY') {\n        previousActiveElement.current = newElement;\n      }\n    } else if (previousActiveElement.current) {\n      tryFocusPreviousActiveElement({\n        originalElement: previousActiveElement.current,\n        containsFocus: true,\n        documentContainsFocus: ((_b = getDocument()) === null || _b === void 0 ? void 0 : _b.hasFocus()) || false\n      });\n      previousActiveElement.current = undefined;\n    }\n  }, [hidden, targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement, tryFocusPreviousActiveElement, hostElement]);\n  return [tryFocusPreviousActiveElement];\n}\nfunction useKeyHandlers(_a, dismiss, hostElement, openSubMenu) {\n  var theme = _a.theme,\n    isSubMenu = _a.isSubMenu,\n    _b = _a.focusZoneProps,\n    _c = _b === void 0 ? {} : _b,\n    checkForNoWrap = _c.checkForNoWrap,\n    _d = _c.direction,\n    focusZoneDirection = _d === void 0 ? FocusZoneDirection.vertical : _d;\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n  var lastKeyDownWasAltOrMeta = React.useRef();\n  /**\n   * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n   * if so, stops event propagation and dismisses menu(s).\n   * @param ev - The keyboard event.\n   * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n   * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n   * Only does anything if `shouldHandleKey` returns true.\n   * @returns Whether the event was handled.\n   */\n  var keyHandler = function (ev, shouldHandleKey, dismissAllMenus) {\n    var handled = false;\n    if (shouldHandleKey(ev)) {\n      dismiss(ev, dismissAllMenus);\n      ev.preventDefault();\n      ev.stopPropagation();\n      handled = true;\n    }\n    return handled;\n  };\n  /**\n   * Checks if the submenu should be closed\n   */\n  var shouldCloseSubMenu = function (ev) {\n    var submenuCloseKey = getRTL(theme) ? KeyCodes.right : KeyCodes.left;\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which !== submenuCloseKey || !isSubMenu) {\n      return false;\n    }\n    return !!(focusZoneDirection === FocusZoneDirection.vertical || checkForNoWrap && !shouldWrapFocus(ev.target, 'data-no-horizontal-wrap'));\n  };\n  var shouldHandleKeyDown = function (ev) {\n    return (\n      // eslint-disable-next-line deprecation/deprecation\n      ev.which === KeyCodes.escape || shouldCloseSubMenu(ev) ||\n      // eslint-disable-next-line deprecation/deprecation\n      ev.which === KeyCodes.up && (ev.altKey || ev.metaKey)\n    );\n  };\n  var onKeyDown = function (ev) {\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in shouldHandleKeyUp for reasoning.\n    lastKeyDownWasAltOrMeta.current = isAltOrMeta(ev);\n    // On Mac, pressing escape dismisses all levels of native context menus\n    // eslint-disable-next-line deprecation/deprecation\n    var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n    return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);\n  };\n  /**\n   * We close the menu on key up only if ALL of the following are true:\n   * - Most recent key down was alt or meta (command)\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n   *   expand/collapse the menu)\n   * - We're not on a Mac (or iOS)\n   *\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n   * closing any open context menus. There is not a similar behavior on Macs.\n   */\n  var shouldHandleKeyUp = function (ev) {\n    var keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta(ev);\n    lastKeyDownWasAltOrMeta.current = false;\n    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n  };\n  var onKeyUp = function (ev) {\n    return keyHandler(ev, shouldHandleKeyUp, true /* dismissAllMenus */);\n  };\n\n  var onMenuKeyDown = function (ev) {\n    // Mark as handled if onKeyDown returns true (for handling collapse cases)\n    // or if we are attempting to expand a submenu\n    var handled = onKeyDown(ev);\n    if (handled || !hostElement.current) {\n      return;\n    }\n    // If we have a modifier key being pressed, we do not want to move focus.\n    // Otherwise, handle up and down keys.\n    var hasModifier = !!(ev.altKey || ev.metaKey);\n    // eslint-disable-next-line deprecation/deprecation\n    var isUp = ev.which === KeyCodes.up;\n    // eslint-disable-next-line deprecation/deprecation\n    var isDown = ev.which === KeyCodes.down;\n    if (!hasModifier && (isUp || isDown)) {\n      var elementToFocus = isUp ? getLastFocusable(hostElement.current, hostElement.current.lastChild, true) : getFirstFocusable(hostElement.current, hostElement.current.firstChild, true);\n      if (elementToFocus) {\n        elementToFocus.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n  var onItemKeyDown = function (item, ev) {\n    var openKey = getRTL(theme) ? KeyCodes.left : KeyCodes.right;\n    if (!item.disabled && (\n    // eslint-disable-next-line deprecation/deprecation\n    ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {\n      openSubMenu(item, ev.currentTarget);\n      ev.preventDefault();\n    }\n  };\n  return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown];\n}\nfunction useScrollHandler(asyncTracker) {\n  var isScrollIdle = React.useRef(true);\n  var scrollIdleTimeoutId = React.useRef();\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n  var onScroll = function () {\n    if (!isScrollIdle.current && scrollIdleTimeoutId.current !== undefined) {\n      asyncTracker.clearTimeout(scrollIdleTimeoutId.current);\n      scrollIdleTimeoutId.current = undefined;\n    } else {\n      isScrollIdle.current = false;\n    }\n    scrollIdleTimeoutId.current = asyncTracker.setTimeout(function () {\n      isScrollIdle.current = true;\n    }, NavigationIdleDelay);\n  };\n  return [onScroll, isScrollIdle];\n}\nfunction useOnSubmenuDismiss(dismiss, closeSubMenu) {\n  var isMountedRef = React.useRef(false);\n  React.useEffect(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  /**\n   * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n   * after the component is unmounted. The isMountedRef is added to prevent\n   * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n   * code.\n   */\n  var onSubMenuDismiss = function (ev, dismissAll) {\n    if (dismissAll) {\n      dismiss(ev, dismissAll);\n    } else if (isMountedRef.current) {\n      closeSubMenu();\n    }\n  };\n  return onSubMenuDismiss;\n}\nfunction useSubmenuEnterTimer(_a, asyncTracker) {\n  var _b = _a.subMenuHoverDelay,\n    subMenuHoverDelay = _b === void 0 ? NavigationIdleDelay : _b;\n  var enterTimerRef = React.useRef(undefined);\n  var cancelSubMenuTimer = function () {\n    if (enterTimerRef.current !== undefined) {\n      asyncTracker.clearTimeout(enterTimerRef.current);\n      enterTimerRef.current = undefined;\n    }\n  };\n  var startSubmenuTimer = function (onTimerExpired) {\n    enterTimerRef.current = asyncTracker.setTimeout(function () {\n      onTimerExpired();\n      cancelSubMenuTimer();\n    }, subMenuHoverDelay);\n  };\n  return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef];\n}\nfunction useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss) {\n  var menuTarget = props.target;\n  var onItemMouseEnterBase = function (item, ev, target) {\n    if (shouldUpdateFocusOnMouseEvent.current) {\n      gotMouseMove.current = true;\n    }\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n  var onItemMouseMoveBase = function (item, ev, target) {\n    var targetElement = ev.currentTarget;\n    // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n    if (shouldUpdateFocusOnMouseEvent.current) {\n      gotMouseMove.current = true;\n    } else {\n      return;\n    }\n    if (!isScrollIdle.current || subMenuEntryTimer.current !== undefined || targetElement === (targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement)) {\n      return;\n    }\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n  var shouldIgnoreMouseEvent = function () {\n    return !isScrollIdle.current || !gotMouseMove.current;\n  };\n  var onMouseItemLeave = function (item, ev) {\n    var _a;\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n    cancelSubMenuTimer();\n    if (expandedMenuItemKey !== undefined) {\n      return;\n    }\n    /**\n     * IE11 focus() method forces parents to scroll to top of element.\n     * Edge and IE expose a setActive() function for focusable divs that\n     * sets the page focus but does not scroll the parent element.\n     */\n    if (hostElement.current.setActive) {\n      try {\n        hostElement.current.setActive();\n      } catch (e) {\n        /* no-op */\n      }\n    } else {\n      (_a = hostElement.current) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n  };\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n  var updateFocusOnMouseEvent = function (item, ev, target) {\n    var targetElement = target ? target : ev.currentTarget;\n    if (item.key === expandedMenuItemKey) {\n      return;\n    }\n    cancelSubMenuTimer();\n    // If the menu is not expanded we can update focus without any delay\n    if (expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    }\n    // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      startSubmenuTimer(function () {\n        targetElement.focus();\n        openSubMenu(item, targetElement, true);\n      });\n    } else {\n      startSubmenuTimer(function () {\n        onSubMenuDismiss(ev);\n        targetElement.focus();\n      });\n    }\n  };\n  var onItemClick = function (item, ev) {\n    onItemClickBase(item, ev, ev.currentTarget);\n  };\n  var onItemClickBase = function (item, ev, target) {\n    var items = getSubmenuItems(item, {\n      target: menuTarget\n    });\n    // Cancel an async menu item hover timeout action from being taken and instead\n    // just trigger the click event instead.\n    cancelSubMenuTimer();\n    if (!hasSubmenu(item) && (!items || !items.length)) {\n      // This is an item without a menu. Click it.\n      executeItemClick(item, ev);\n    } else {\n      if (item.key !== expandedMenuItemKey) {\n        // This has a collapsed sub menu. Expand it.\n        // focus on the container by default when the menu is opened with a click event\n        // this differentiates from a keyboard interaction triggering the click event\n        var shouldFocusOnContainer = typeof props.shouldFocusOnContainer === 'boolean' ? props.shouldFocusOnContainer : ev.nativeEvent.pointerType === 'mouse';\n        openSubMenu(item, target, shouldFocusOnContainer);\n      }\n    }\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n  var onAnchorClick = function (item, ev) {\n    executeItemClick(item, ev);\n    ev.stopPropagation();\n  };\n  var executeItemClick = function (item, ev) {\n    if (item.disabled || item.isDisabled) {\n      return;\n    }\n    if (item.preferMenuTargetAsEventTarget) {\n      overrideTarget(ev, menuTarget);\n    }\n    var shouldDismiss = false;\n    if (item.onClick) {\n      shouldDismiss = !!item.onClick(ev, item);\n    } else if (props.onItemClick) {\n      shouldDismiss = !!props.onItemClick(ev, item);\n    }\n    if (shouldDismiss || !ev.defaultPrevented) {\n      dismiss(ev, true);\n    }\n  };\n  return [onItemMouseEnterBase, onItemMouseMoveBase, onMouseItemLeave, onItemClick, onAnchorClick, executeItemClick, onItemClickBase];\n}\n//#endregion\nexport var ContextualMenuBase = React.memo(React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var _a;\n  var _b = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults),\n    ref = _b.ref,\n    props = __rest(_b, [\"ref\"]);\n  var hostElement = React.useRef(null);\n  var asyncTracker = useAsync();\n  var menuId = useId(COMPONENT_NAME, props.id);\n  useWarnings({\n    name: COMPONENT_NAME,\n    props: props,\n    deprecations: {\n      getMenuClassNames: 'styles'\n    }\n  });\n  var dismiss = function (ev, dismissAll) {\n    var _a;\n    return (_a = props.onDismiss) === null || _a === void 0 ? void 0 : _a.call(props, ev, dismissAll);\n  };\n  var _c = useTarget(props.target, hostElement),\n    targetRef = _c[0],\n    targetWindow = _c[1];\n  var tryFocusPreviousActiveElement = usePreviousActiveElement(props, targetWindow, hostElement)[0];\n  var _d = useSubMenuState(props, dismiss),\n    expandedMenuItemKey = _d[0],\n    openSubMenu = _d[1],\n    getSubmenuProps = _d[2],\n    onSubMenuDismiss = _d[3];\n  var _e = useShouldUpdateFocusOnMouseMove(props),\n    shouldUpdateFocusOnMouseEvent = _e[0],\n    gotMouseMove = _e[1],\n    onMenuFocusCapture = _e[2];\n  var _f = useScrollHandler(asyncTracker),\n    onScroll = _f[0],\n    isScrollIdle = _f[1];\n  var _g = useSubmenuEnterTimer(props, asyncTracker),\n    cancelSubMenuTimer = _g[0],\n    startSubmenuTimer = _g[1],\n    subMenuEntryTimer = _g[2];\n  var responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);\n  useVisibility(props, targetWindow);\n  var _h = useKeyHandlers(props, dismiss, hostElement, openSubMenu),\n    onKeyDown = _h[0],\n    onKeyUp = _h[1],\n    onMenuKeyDown = _h[2],\n    onItemKeyDown = _h[3];\n  var _j = useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss),\n    onItemMouseEnterBase = _j[0],\n    onItemMouseMoveBase = _j[1],\n    onMouseItemLeave = _j[2],\n    onItemClick = _j[3],\n    onAnchorClick = _j[4],\n    executeItemClick = _j[5],\n    onItemClickBase = _j[6];\n  //#region Render helpers\n  var onDefaultRenderMenuList = function (menuListProps,\n  // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, defaultRender) {\n    var indexCorrection = 0;\n    var items = menuListProps.items,\n      totalItemCount = menuListProps.totalItemCount,\n      hasCheckmarks = menuListProps.hasCheckmarks,\n      hasIcons = menuListProps.hasIcons;\n    return React.createElement(\"ul\", {\n      className: menuClassNames.list,\n      onKeyDown: onKeyDown,\n      onKeyUp: onKeyUp,\n      role: 'presentation'\n    }, items.map(function (item, index) {\n      var menuItem = renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks, hasIcons, menuClassNames);\n      if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n        var indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n        indexCorrection += indexIncrease;\n      }\n      return menuItem;\n    }));\n  };\n  var renderFocusZone = function (children, adjustedFocusZoneProps) {\n    var _a = props.focusZoneAs,\n      ChildrenRenderer = _a === void 0 ? FocusZone : _a;\n    return React.createElement(ChildrenRenderer, __assign({}, adjustedFocusZoneProps), children);\n  };\n  /**\n   * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n   * cause the menu items to always re-render because the component update is based on shallow comparison.\n   */\n  var renderMenuItem = function (item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons,\n  // eslint-disable-next-line deprecation/deprecation\n  menuClassNames) {\n    var _a;\n    var renderedItems = [];\n    var iconProps = item.iconProps || {\n      iconName: 'None'\n    };\n    var getItemClassNames = item.getItemClassNames,\n      // eslint-disable-line deprecation/deprecation\n      itemProps = item.itemProps;\n    var styles = itemProps ? itemProps.styles : undefined;\n    // We only send a dividerClassName when the item to be rendered is a divider.\n    // For all other cases, the default divider style is used.\n    var dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n    var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';\n    // eslint-disable-next-line deprecation/deprecation\n    var itemClassNames;\n    // IContextualMenuItem#getItemClassNames for backwards compatibility\n    // otherwise uses mergeStyles for class names.\n    if (getItemClassNames) {\n      itemClassNames = getItemClassNames(props.theme, isItemDisabled(item), expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== 'None', item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);\n    } else {\n      var itemStyleProps = {\n        theme: props.theme,\n        disabled: isItemDisabled(item),\n        expanded: expandedMenuItemKey === item.key,\n        checked: !!getIsChecked(item),\n        isAnchorLink: !!item.href,\n        knownIcon: iconProps.iconName !== 'None',\n        itemClassName: item.className,\n        dividerClassName: dividerClassName,\n        iconClassName: iconProps.className,\n        subMenuClassName: subMenuIconClassName,\n        primaryDisabled: item.primaryDisabled\n      };\n      // We need to generate default styles then override if styles are provided\n      // since the ContextualMenu currently handles item classNames.\n      itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a = menuClassNames.subComponentStyles) === null || _a === void 0 ? void 0 : _a.menuItem, styles), itemStyleProps);\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    if (item.text === '-' || item.name === '-') {\n      item.itemType = ContextualMenuItemType.Divider;\n    }\n    switch (item.itemType) {\n      case ContextualMenuItemType.Divider:\n        renderedItems.push(renderSeparator(index, itemClassNames));\n        break;\n      case ContextualMenuItemType.Header:\n        renderedItems.push(renderSeparator(index, itemClassNames));\n        var headerItem = renderHeaderMenuItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons);\n        renderedItems.push(renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n        break;\n      case ContextualMenuItemType.Section:\n        renderedItems.push(renderSectionItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons));\n        break;\n      default:\n        var defaultRenderNormalItem = function () {\n          return renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n        };\n        var menuItem = props.onRenderContextualMenuItem ? props.onRenderContextualMenuItem(item, defaultRenderNormalItem) : defaultRenderNormalItem();\n        renderedItems.push(renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n        break;\n    }\n    // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n    // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n    return React.createElement(React.Fragment, {\n      key: item.key\n    }, renderedItems);\n  };\n  var defaultMenuItemRenderer = function (item,\n  // eslint-disable-next-line deprecation/deprecation\n  menuClassNames) {\n    var index = item.index,\n      focusableElementIndex = item.focusableElementIndex,\n      totalItemCount = item.totalItemCount,\n      hasCheckmarks = item.hasCheckmarks,\n      hasIcons = item.hasIcons;\n    return renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons, menuClassNames);\n  };\n  var renderSectionItem = function (sectionItem,\n  // eslint-disable-next-line deprecation/deprecation\n  itemClassNames,\n  // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, index, hasCheckmarks, hasIcons) {\n    var sectionProps = sectionItem.sectionProps;\n    if (!sectionProps) {\n      return;\n    }\n    var headerItem;\n    var groupProps;\n    if (sectionProps.title) {\n      var headerContextualMenuItem = undefined;\n      var ariaLabelledby = '';\n      if (typeof sectionProps.title === 'string') {\n        // Since title is a user-facing string, it needs to be stripped\n        // of whitespace in order to build a valid element ID\n        var id_1 = menuId + sectionProps.title.replace(/\\s/g, '');\n        headerContextualMenuItem = {\n          key: \"section-\".concat(sectionProps.title, \"-title\"),\n          itemType: ContextualMenuItemType.Header,\n          text: sectionProps.title,\n          id: id_1\n        };\n        ariaLabelledby = id_1;\n      } else {\n        var id_2 = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\\s/g, '');\n        headerContextualMenuItem = __assign(__assign({}, sectionProps.title), {\n          id: id_2\n        });\n        ariaLabelledby = id_2;\n      }\n      if (headerContextualMenuItem) {\n        groupProps = {\n          role: 'group',\n          'aria-labelledby': ariaLabelledby\n        };\n        headerItem = renderHeaderMenuItem(headerContextualMenuItem, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons);\n      }\n    }\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      var correctedIndex_1 = 0;\n      return React.createElement(\"li\", {\n        role: \"presentation\",\n        key: sectionProps.key || sectionItem.key || \"section-\".concat(index)\n      }, React.createElement(\"div\", __assign({}, groupProps), React.createElement(\"ul\", {\n        className: menuClassNames.list,\n        role: \"presentation\"\n      }, sectionProps.topDivider && renderSeparator(index, itemClassNames, true, true), headerItem && renderListItem(headerItem, sectionItem.key || index, itemClassNames, sectionItem.title), sectionProps.items.map(function (contextualMenuItem, itemsIndex) {\n        var menuItem = renderMenuItem(contextualMenuItem, itemsIndex, correctedIndex_1, getItemCount(sectionProps.items), hasCheckmarks, hasIcons, menuClassNames);\n        if (contextualMenuItem.itemType !== ContextualMenuItemType.Divider && contextualMenuItem.itemType !== ContextualMenuItemType.Header) {\n          var indexIncrease = contextualMenuItem.customOnRenderListLength ? contextualMenuItem.customOnRenderListLength : 1;\n          correctedIndex_1 += indexIncrease;\n        }\n        return menuItem;\n      }), sectionProps.bottomDivider && renderSeparator(index, itemClassNames, false, true))));\n    }\n  };\n  var renderListItem = function (content, key, classNames,\n  // eslint-disable-line deprecation/deprecation\n  title) {\n    return React.createElement(\"li\", {\n      role: \"presentation\",\n      title: title,\n      key: key,\n      className: classNames.item\n    }, content);\n  };\n  var renderSeparator = function (index, classNames,\n  // eslint-disable-line deprecation/deprecation\n  top, fromSection) {\n    if (fromSection || index > 0) {\n      return React.createElement(\"li\", {\n        role: \"separator\",\n        key: 'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom'),\n        className: classNames.divider,\n        \"aria-hidden\": \"true\"\n      });\n    }\n    return null;\n  };\n  var renderNormalItem = function (item, classNames,\n  // eslint-disable-line deprecation/deprecation\n  index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    if (item.onRender) {\n      return item.onRender(__assign({\n        'aria-posinset': focusableElementIndex + 1,\n        'aria-setsize': totalItemCount\n      }, item), dismiss);\n    }\n    var contextualMenuItemAs = props.contextualMenuItemAs;\n    var commonProps = {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: onItemMouseEnterBase,\n      onItemMouseLeave: onMouseItemLeave,\n      onItemMouseMove: onItemMouseMoveBase,\n      onItemMouseDown: onItemMouseDown,\n      executeItemClick: executeItemClick,\n      onItemKeyDown: onItemKeyDown,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: openSubMenu,\n      dismissSubMenu: onSubMenuDismiss,\n      dismissMenu: dismiss\n    };\n    if (item.href) {\n      return React.createElement(ContextualMenuAnchor, __assign({}, commonProps, {\n        onItemClick: onAnchorClick\n      }));\n    }\n    if (item.split && hasSubmenu(item)) {\n      return React.createElement(ContextualMenuSplitButton, __assign({}, commonProps, {\n        onItemClick: onItemClick,\n        onItemClickBase: onItemClickBase,\n        onTap: cancelSubMenuTimer\n      }));\n    }\n    return React.createElement(ContextualMenuButton, __assign({}, commonProps, {\n      onItemClick: onItemClick,\n      onItemClickBase: onItemClickBase\n    }));\n  };\n  var renderHeaderMenuItem = function (item,\n  // eslint-disable-next-line deprecation/deprecation\n  itemClassNames,\n  // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, index, hasCheckmarks, hasIcons) {\n    var _a = props.contextualMenuItemAs,\n      ChildrenRenderer = _a === void 0 ? ContextualMenuItem : _a;\n    var itemProps = item.itemProps,\n      id = item.id;\n    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);\n    return (\n      // eslint-disable-next-line deprecation/deprecation\n      React.createElement(\"div\", __assign({\n        id: id,\n        className: menuClassNames.header\n      }, divHtmlProperties, {\n        style: item.style\n      }), React.createElement(ChildrenRenderer, __assign({\n        item: item,\n        classNames: itemClassNames,\n        index: index,\n        onCheckmarkClick: hasCheckmarks ? onItemClick : undefined,\n        hasIcons: hasIcons\n      }, itemProps)))\n    );\n  };\n  //#endregion\n  //#region Main render\n  var isBeakVisible = props.isBeakVisible;\n  var items = props.items,\n    labelElementId = props.labelElementId,\n    id = props.id,\n    className = props.className,\n    beakWidth = props.beakWidth,\n    directionalHint = props.directionalHint,\n    directionalHintForRTL = props.directionalHintForRTL,\n    alignTargetEdge = props.alignTargetEdge,\n    gapSpace = props.gapSpace,\n    coverTarget = props.coverTarget,\n    ariaLabel = props.ariaLabel,\n    doNotLayer = props.doNotLayer,\n    target = props.target,\n    bounds = props.bounds,\n    useTargetWidth = props.useTargetWidth,\n    useTargetAsMinWidth = props.useTargetAsMinWidth,\n    directionalHintFixed = props.directionalHintFixed,\n    shouldFocusOnMount = props.shouldFocusOnMount,\n    shouldFocusOnContainer = props.shouldFocusOnContainer,\n    title = props.title,\n    styles = props.styles,\n    theme = props.theme,\n    calloutProps = props.calloutProps,\n    _k = props.onRenderSubMenu,\n    onRenderSubMenu = _k === void 0 ? onDefaultRenderSubMenu : _k,\n    _l = props.onRenderMenuList,\n    onRenderMenuList = _l === void 0 ? function (menuListProps, defaultRender) {\n      return onDefaultRenderMenuList(menuListProps, classNames, defaultRender);\n    } : _l,\n    focusZoneProps = props.focusZoneProps,\n    // eslint-disable-next-line deprecation/deprecation\n    getMenuClassNames = props.getMenuClassNames;\n  var classNames = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames(styles, {\n    theme: theme,\n    className: className\n  });\n  var hasIcons = itemsHaveIcons(items);\n  function itemsHaveIcons(contextualMenuItems) {\n    for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {\n      var item = contextualMenuItems_1[_i];\n      if (item.iconProps) {\n        return true;\n      }\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var adjustedFocusZoneProps = __assign(__assign({\n    direction: FocusZoneDirection.vertical,\n    handleTabKey: FocusZoneTabbableElements.all,\n    isCircularNavigation: true\n  }, focusZoneProps), {\n    className: css(classNames.root, (_a = props.focusZoneProps) === null || _a === void 0 ? void 0 : _a.className)\n  });\n  var hasCheckmarks = canAnyMenuItemsCheck(items);\n  var submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;\n  isBeakVisible = isBeakVisible === undefined ? responsiveMode <= ResponsiveMode.medium : isBeakVisible;\n  /**\n   * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n   */\n  var contextMenuStyle;\n  var targetAsHtmlElement = targetRef.current;\n  if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n    var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n    var targetWidth = targetBoundingRect.width - 2; /* Accounts for 1px border */\n    if (useTargetWidth) {\n      contextMenuStyle = {\n        width: targetWidth\n      };\n    } else if (useTargetAsMinWidth) {\n      contextMenuStyle = {\n        minWidth: targetWidth\n      };\n    }\n  }\n  // The menu should only return if items were provided, if no items were provided then it should not appear.\n  if (items && items.length > 0) {\n    var totalItemCount_1 = getItemCount(items);\n    var calloutStyles_1 = classNames.subComponentStyles ? classNames.subComponentStyles.callout : undefined;\n    return React.createElement(MenuContext.Consumer, null, function (menuContext) {\n      return React.createElement(Callout, __assign({\n        styles: calloutStyles_1,\n        onRestoreFocus: tryFocusPreviousActiveElement\n      }, calloutProps, {\n        target: target || menuContext.target,\n        isBeakVisible: isBeakVisible,\n        beakWidth: beakWidth,\n        directionalHint: directionalHint,\n        directionalHintForRTL: directionalHintForRTL,\n        gapSpace: gapSpace,\n        coverTarget: coverTarget,\n        doNotLayer: doNotLayer,\n        className: css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className),\n        setInitialFocus: shouldFocusOnMount,\n        onDismiss: props.onDismiss || menuContext.onDismiss,\n        onScroll: onScroll,\n        bounds: bounds,\n        directionalHintFixed: directionalHintFixed,\n        alignTargetEdge: alignTargetEdge,\n        hidden: props.hidden || menuContext.hidden,\n        ref: forwardedRef\n      }), React.createElement(\"div\", {\n        style: contextMenuStyle,\n        ref: hostElement,\n        id: id,\n        className: classNames.container,\n        tabIndex: shouldFocusOnContainer ? 0 : -1,\n        onKeyDown: onMenuKeyDown,\n        onKeyUp: onKeyUp,\n        onFocusCapture: onMenuFocusCapture,\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": labelElementId,\n        role: 'menu'\n      }, title && React.createElement(\"div\", {\n        className: classNames.title\n      }, \" \", title, \" \"), items && items.length ? renderFocusZone(onRenderMenuList({\n        ariaLabel: ariaLabel,\n        items: items,\n        totalItemCount: totalItemCount_1,\n        hasCheckmarks: hasCheckmarks,\n        hasIcons: hasIcons,\n        defaultMenuItemRenderer: function (item) {\n          return defaultMenuItemRenderer(item, classNames);\n        },\n        labelElementId: labelElementId\n      }, function (menuListProps, defaultRender) {\n        return onDefaultRenderMenuList(menuListProps, classNames, defaultRender);\n      }), adjustedFocusZoneProps) : null, submenuProps && onRenderSubMenu(submenuProps, onDefaultRenderSubMenu)), React.createElement(FocusRects, null));\n    });\n  } else {\n    return null;\n  }\n  //#endregion\n}), function (prevProps, newProps) {\n  if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {\n    // Do not update when hidden.\n    return true;\n  }\n  return shallowCompare(prevProps, newProps);\n});\nContextualMenuBase.displayName = 'ContextualMenuBase';\n/**\n * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n */\nfunction isAltOrMeta(ev) {\n  // eslint-disable-next-line deprecation/deprecation\n  return ev.which === KeyCodes.alt || ev.key === 'Meta';\n}\nfunction onItemMouseDown(item, ev) {\n  var _a;\n  (_a = item.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(item, item, ev);\n}\nfunction onDefaultRenderSubMenu(subMenuProps, defaultRender) {\n  throw Error('ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' + 'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.');\n}\n/**\n * Returns the item that matches a given key if any.\n * @param key - The key of the item to match\n * @param items - The items to look for the key\n */\nfunction findItemByKeyFromItems(key, items) {\n  for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {\n    var item = items_3[_i];\n    if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n      var match = findItemByKeyFromItems(key, item.sectionProps.items);\n      if (match) {\n        return match;\n      }\n    } else if (item.key && item.key === key) {\n      return item;\n    }\n  }\n}\nfunction getOnClickWithOverrideTarget(onClick, target) {\n  return onClick ? function (ev, item) {\n    overrideTarget(ev, target);\n    return onClick(ev, item);\n  } : onClick;\n}\nfunction overrideTarget(ev, target) {\n  if (ev && target) {\n    ev.persist();\n    if (target instanceof Event) {\n      ev.target = target.target;\n    } else if (target instanceof Element) {\n      ev.target = target;\n    }\n  }\n}","map":{"version":3,"names":["React","ContextualMenuItemType","DirectionalHint","FocusZone","FocusZoneDirection","FocusZoneTabbableElements","divProperties","getNativeProps","shallowCompare","assign","classNamesFunction","css","getFirstFocusable","getLastFocusable","getRTL","KeyCodes","shouldWrapFocus","isIOS","isMac","memoizeFunction","getPropsWithDefaults","getDocument","FocusRects","hasSubmenu","getIsChecked","isItemDisabled","Callout","ContextualMenuItem","ContextualMenuSplitButton","ContextualMenuButton","ContextualMenuAnchor","concatStyleSetsWithProps","getItemStyles","useTarget","usePrevious","useAsync","useWarnings","useId","useIsomorphicLayoutEffect","useResponsiveMode","ResponsiveMode","MenuContext","getClassNames","getContextualMenuItemClassNames","DEFAULT_PROPS","items","shouldFocusOnMount","gapSpace","directionalHint","bottomAutoEdge","beakWidth","getItemCount","totalItemCount","_i","items_1","length","item","itemType","Divider","Header","itemCount","customOnRenderListLength","getSubmenuItems","options","target","subMenuProps","overrideItems","items_2","subItem","preferMenuTargetAsEventTarget","onClick","contextItem","__rest","push","__assign","getOnClickWithOverrideTarget","canAnyMenuItemsCheck","some","canCheck","sectionProps","submenuItem","NavigationIdleDelay","COMPONENT_NAME","_getMenuItemStylesFunction","styles","arguments","styleProps","apply","__spreadArray","useVisibility","props","targetWindow","_a","hidden","onMenuDismissed","onMenuOpened","previousHidden","onMenuOpenedRef","useRef","onMenuClosedRef","propsRef","current","useEffect","call","_b","useSubMenuState","dismiss","theme","className","id","menuTarget","useState","expandedMenuItemKey","setExpandedMenuItemKey","_c","submenuTarget","setSubmenuTarget","_d","shouldFocusOnContainer","setShouldFocusOnContainer","subMenuId","closeSubMenu","useCallback","undefined","openSubMenu","focusContainer","submenuItemKey","key","focus","onSubMenuDismiss","useOnSubmenuDismiss","getSubmenuProps","findItemByKeyFromItems","submenuProps","onDismiss","isSubMenu","leftTopEdge","rightTopEdge","isBeakVisible","onItemClick","useShouldUpdateFocusOnMouseMove","delayUpdateFocusOnHover","shouldUpdateFocusOnMouseEvent","gotMouseMove","onMenuFocusCapture","usePreviousActiveElement","hostElement","onRestoreFocus","previousActiveElement","tryFocusPreviousActiveElement","documentContainsFocus","newElement","document","activeElement","contains","tagName","originalElement","containsFocus","hasFocus","useKeyHandlers","focusZoneProps","checkForNoWrap","direction","focusZoneDirection","vertical","lastKeyDownWasAltOrMeta","keyHandler","ev","shouldHandleKey","dismissAllMenus","handled","preventDefault","stopPropagation","shouldCloseSubMenu","submenuCloseKey","right","left","which","shouldHandleKeyDown","escape","up","altKey","metaKey","onKeyDown","isAltOrMeta","shouldHandleKeyUp","keyPressIsAltOrMetaAlone","onKeyUp","onMenuKeyDown","hasModifier","isUp","isDown","down","elementToFocus","lastChild","firstChild","onItemKeyDown","openKey","disabled","enter","currentTarget","useScrollHandler","asyncTracker","isScrollIdle","scrollIdleTimeoutId","onScroll","clearTimeout","setTimeout","isMountedRef","dismissAll","useSubmenuEnterTimer","subMenuHoverDelay","enterTimerRef","cancelSubMenuTimer","startSubmenuTimer","onTimerExpired","useMouseHandlers","subMenuEntryTimer","onItemMouseEnterBase","shouldIgnoreMouseEvent","updateFocusOnMouseEvent","onItemMouseMoveBase","targetElement","onMouseItemLeave","setActive","e","onItemClickBase","executeItemClick","nativeEvent","pointerType","onAnchorClick","isDisabled","overrideTarget","shouldDismiss","defaultPrevented","ContextualMenuBase","memo","forwardRef","propsWithoutDefaults","forwardedRef","ref","menuId","name","deprecations","getMenuClassNames","targetRef","_e","_f","_g","responsiveMode","_h","_j","onDefaultRenderMenuList","menuListProps","menuClassNames","defaultRender","indexCorrection","hasCheckmarks","hasIcons","createElement","list","role","map","index","menuItem","renderMenuItem","indexIncrease","renderFocusZone","children","adjustedFocusZoneProps","focusZoneAs","ChildrenRenderer","focusableElementIndex","renderedItems","iconProps","iconName","getItemClassNames","itemProps","dividerClassName","subMenuIconClassName","submenuIconProps","itemClassNames","href","primaryDisabled","itemStyleProps","expanded","checked","isAnchorLink","knownIcon","itemClassName","iconClassName","subMenuClassName","subComponentStyles","text","renderSeparator","headerItem","renderHeaderMenuItem","renderListItem","title","Section","renderSectionItem","defaultRenderNormalItem","renderNormalItem","onRenderContextualMenuItem","Fragment","defaultMenuItemRenderer","sectionItem","groupProps","headerContextualMenuItem","ariaLabelledby","id_1","replace","concat","id_2","correctedIndex_1","topDivider","contextualMenuItem","itemsIndex","bottomDivider","content","classNames","top","fromSection","divider","onRender","contextualMenuItemAs","commonProps","onItemMouseEnter","onItemMouseLeave","onItemMouseMove","onItemMouseDown","dismissSubMenu","dismissMenu","split","onTap","divHtmlProperties","header","style","onCheckmarkClick","labelElementId","directionalHintForRTL","alignTargetEdge","coverTarget","ariaLabel","doNotLayer","bounds","useTargetWidth","useTargetAsMinWidth","directionalHintFixed","calloutProps","_k","onRenderSubMenu","onDefaultRenderSubMenu","_l","onRenderMenuList","itemsHaveIcons","contextualMenuItems","contextualMenuItems_1","handleTabKey","all","isCircularNavigation","root","medium","contextMenuStyle","targetAsHtmlElement","offsetWidth","targetBoundingRect","getBoundingClientRect","targetWidth","width","minWidth","totalItemCount_1","calloutStyles_1","callout","Consumer","menuContext","setInitialFocus","container","tabIndex","onFocusCapture","prevProps","newProps","shouldUpdateWhenHidden","displayName","alt","onMouseDown","Error","items_3","match","persist","Event","Element"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/components/src/components/ContextualMenu/ContextualMenu.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { ContextualMenuItemType } from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, FocusZoneTabbableElements } from '../../FocusZone';\nimport {\n  divProperties,\n  getNativeProps,\n  shallowCompare,\n  Async,\n  assign,\n  classNamesFunction,\n  css,\n  getFirstFocusable,\n  getLastFocusable,\n  getRTL,\n  KeyCodes,\n  shouldWrapFocus,\n  isIOS,\n  isMac,\n  memoizeFunction,\n  getPropsWithDefaults,\n  getDocument,\n  FocusRects,\n} from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { Callout } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport {\n  ContextualMenuSplitButton,\n  ContextualMenuButton,\n  ContextualMenuAnchor,\n} from './ContextualMenuItemWrapper/index';\nimport { concatStyleSetsWithProps } from '../../Styling';\nimport { getItemStyles } from './ContextualMenu.classNames';\nimport {\n  useTarget,\n  usePrevious,\n  useAsync,\n  useWarnings,\n  useId,\n  Target,\n  useIsomorphicLayoutEffect,\n} from '@fluentui/react-hooks';\nimport { useResponsiveMode, ResponsiveMode } from '../../ResponsiveMode';\nimport { MenuContext } from '../../utilities/MenuContext/index';\nimport type {\n  IContextualMenuProps,\n  IContextualMenuItem,\n  IContextualMenuListProps,\n  IContextualMenuStyleProps,\n  IContextualMenuStyles,\n  IContextualMenuItemRenderProps,\n} from './ContextualMenu.types';\nimport type { IFocusZoneProps } from '../../FocusZone';\nimport type { IMenuItemClassNames, IContextualMenuClassNames } from './ContextualMenu.classNames';\nimport type { IRenderFunction, IStyleFunctionOrObject } from '../../Utilities';\nimport type { ICalloutContentStyleProps, ICalloutContentStyles } from '../../Callout';\nimport type { IProcessedStyleSet } from '../../Styling';\nimport type { IContextualMenuItemStyleProps, IContextualMenuItemStyles } from './ContextualMenuItem.types';\nimport type { IPopupRestoreFocusParams } from '../../Popup';\n\nconst getClassNames = classNamesFunction<IContextualMenuStyleProps, IContextualMenuStyles>();\nconst getContextualMenuItemClassNames = classNamesFunction<IContextualMenuItemStyleProps, IContextualMenuItemStyles>();\n\n// The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\nconst DEFAULT_PROPS: Partial<IContextualMenuProps> = {\n  items: [],\n  shouldFocusOnMount: true,\n  gapSpace: 0,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n  beakWidth: 16,\n};\n\n/* return number of menu items, excluding headers and dividers */\nfunction getItemCount(items: IContextualMenuItem[]): number {\n  let totalItemCount = 0;\n  for (const item of items) {\n    if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n      const itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n      totalItemCount += itemCount;\n    }\n  }\n  return totalItemCount;\n}\n\nexport function getSubmenuItems(\n  item: IContextualMenuItem,\n  options?: {\n    target?: Target;\n  },\n): IContextualMenuItem[] | undefined {\n  const target = options?.target;\n\n  // eslint-disable-next-line deprecation/deprecation\n  const items = item.subMenuProps ? item.subMenuProps.items : item.items;\n\n  if (items) {\n    const overrideItems: typeof items = [];\n\n    for (const subItem of items) {\n      if (subItem.preferMenuTargetAsEventTarget) {\n        // For sub-items which need an overridden target, intercept `onClick`\n        const { onClick, ...contextItem } = subItem;\n\n        overrideItems.push({\n          ...contextItem,\n          onClick: getOnClickWithOverrideTarget(onClick, target),\n        });\n      } else {\n        overrideItems.push(subItem);\n      }\n    }\n\n    return overrideItems;\n  }\n}\n\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\nexport function canAnyMenuItemsCheck(items: IContextualMenuItem[]): boolean {\n  return items.some(item => {\n    if (item.canCheck) {\n      return true;\n    }\n\n    // If the item is a section, check if any of the items in the section can check.\n    if (item.sectionProps && item.sectionProps.items.some(submenuItem => submenuItem.canCheck === true)) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nconst NavigationIdleDelay = 250; /* ms */\n\nconst COMPONENT_NAME = 'ContextualMenu';\n\nconst _getMenuItemStylesFunction = memoizeFunction(\n  (\n    ...styles: (IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> | undefined)[]\n  ): IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> => {\n    return (styleProps: IContextualMenuItemStyleProps) =>\n      concatStyleSetsWithProps(styleProps, getItemStyles, ...styles);\n  },\n);\n\n//#region Custom hooks\nfunction useVisibility(props: IContextualMenuProps, targetWindow: Window | undefined) {\n  const { hidden = false, onMenuDismissed, onMenuOpened } = props;\n  const previousHidden = usePrevious(hidden);\n\n  const onMenuOpenedRef = React.useRef(onMenuOpened);\n  const onMenuClosedRef = React.useRef(onMenuDismissed);\n  const propsRef = React.useRef(props);\n\n  onMenuOpenedRef.current = onMenuOpened;\n  onMenuClosedRef.current = onMenuDismissed;\n  propsRef.current = props;\n\n  React.useEffect(() => {\n    // Don't issue dismissed callbacks on initial mount\n    if (hidden && previousHidden === false) {\n      onMenuClosedRef.current?.(propsRef.current);\n    } else if (!hidden && previousHidden !== false) {\n      onMenuOpenedRef.current?.(propsRef.current);\n    }\n  }, [hidden, previousHidden]);\n\n  // Issue onDismissedCallback on unmount\n  React.useEffect(() => () => onMenuClosedRef.current?.(propsRef.current), []);\n}\n\nfunction useSubMenuState(\n  { hidden, items, theme, className, id, target: menuTarget }: IContextualMenuProps,\n  dismiss: () => void,\n) {\n  const [expandedMenuItemKey, setExpandedMenuItemKey] = React.useState<string>();\n  const [submenuTarget, setSubmenuTarget] = React.useState<HTMLElement>();\n  /** True if the menu was expanded by mouse click OR hover (as opposed to by keyboard) */\n  const [shouldFocusOnContainer, setShouldFocusOnContainer] = React.useState<boolean>();\n  const subMenuId = useId(COMPONENT_NAME, id);\n\n  const closeSubMenu = React.useCallback(() => {\n    setShouldFocusOnContainer(undefined);\n    setExpandedMenuItemKey(undefined);\n    setSubmenuTarget(undefined);\n  }, []);\n\n  const openSubMenu = React.useCallback(\n    ({ key: submenuItemKey }: IContextualMenuItem, target: HTMLElement, focusContainer?: boolean) => {\n      if (expandedMenuItemKey === submenuItemKey) {\n        return;\n      }\n\n      target.focus();\n      setShouldFocusOnContainer(focusContainer);\n      setExpandedMenuItemKey(submenuItemKey);\n      setSubmenuTarget(target);\n    },\n    [expandedMenuItemKey],\n  );\n\n  React.useEffect(() => {\n    if (hidden) {\n      closeSubMenu();\n    }\n  }, [hidden, closeSubMenu]);\n\n  const onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);\n\n  const getSubmenuProps = (): IContextualMenuProps | null => {\n    const item = findItemByKeyFromItems(expandedMenuItemKey!, items);\n    let submenuProps: IContextualMenuProps | null = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item, { target: menuTarget })!,\n        target: submenuTarget,\n        onDismiss: onSubMenuDismiss,\n        isSubMenu: true,\n        id: subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer,\n        directionalHint: getRTL(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className,\n        gapSpace: 0,\n        isBeakVisible: false,\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n\n      if (item.preferMenuTargetAsEventTarget) {\n        const { onItemClick } = item;\n\n        submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);\n      }\n    }\n    return submenuProps;\n  };\n\n  return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss] as const;\n}\n\nfunction useShouldUpdateFocusOnMouseMove({ delayUpdateFocusOnHover, hidden }: IContextualMenuProps) {\n  const shouldUpdateFocusOnMouseEvent = React.useRef<boolean>(!delayUpdateFocusOnHover);\n  const gotMouseMove = React.useRef<boolean>(false);\n\n  React.useEffect(() => {\n    shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;\n    gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;\n  }, [delayUpdateFocusOnHover, hidden]);\n\n  const onMenuFocusCapture = React.useCallback(() => {\n    if (delayUpdateFocusOnHover) {\n      shouldUpdateFocusOnMouseEvent.current = false;\n    }\n  }, [delayUpdateFocusOnHover]);\n\n  return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture] as const;\n}\n\nfunction usePreviousActiveElement(\n  { hidden, onRestoreFocus }: IContextualMenuProps,\n  targetWindow: Window | undefined,\n  hostElement: any,\n) {\n  const previousActiveElement = React.useRef<undefined | HTMLElement>();\n\n  const tryFocusPreviousActiveElement = React.useCallback(\n    (options: IPopupRestoreFocusParams) => {\n      if (onRestoreFocus) {\n        onRestoreFocus(options);\n      } else if (options?.documentContainsFocus) {\n        // Make sure that the focus method actually exists\n        // In some cases the object might exist but not be a real element.\n        // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n        previousActiveElement.current?.focus?.();\n      }\n    },\n    [onRestoreFocus],\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (!hidden) {\n      const newElement = targetWindow?.document.activeElement as HTMLElement;\n      if (!hostElement.current?.contains(newElement) && newElement.tagName !== 'BODY') {\n        previousActiveElement.current = newElement;\n      }\n    } else if (previousActiveElement.current) {\n      tryFocusPreviousActiveElement({\n        originalElement: previousActiveElement.current,\n        containsFocus: true,\n        documentContainsFocus: getDocument()?.hasFocus() || false,\n      });\n\n      previousActiveElement.current = undefined;\n    }\n  }, [hidden, targetWindow?.document.activeElement, tryFocusPreviousActiveElement, hostElement]);\n\n  return [tryFocusPreviousActiveElement] as const;\n}\n\nfunction useKeyHandlers(\n  {\n    theme,\n    isSubMenu,\n    focusZoneProps: { checkForNoWrap, direction: focusZoneDirection = FocusZoneDirection.vertical } = {},\n  }: IContextualMenuProps,\n  dismiss: (ev?: any, dismissAll?: boolean | undefined) => void | undefined,\n  hostElement: React.RefObject<HTMLDivElement>,\n  openSubMenu: (submenuItemKey: IContextualMenuItem, target: HTMLElement) => void,\n) {\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n  const lastKeyDownWasAltOrMeta = React.useRef<boolean | undefined>();\n\n  /**\n   * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n   * if so, stops event propagation and dismisses menu(s).\n   * @param ev - The keyboard event.\n   * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n   * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n   * Only does anything if `shouldHandleKey` returns true.\n   * @returns Whether the event was handled.\n   */\n  const keyHandler = (\n    ev: React.KeyboardEvent<HTMLElement>,\n    shouldHandleKey: (ev: React.KeyboardEvent<HTMLElement>) => boolean,\n    dismissAllMenus?: boolean,\n  ): boolean => {\n    let handled = false;\n\n    if (shouldHandleKey(ev)) {\n      dismiss(ev, dismissAllMenus);\n      ev.preventDefault();\n      ev.stopPropagation();\n      handled = true;\n    }\n\n    return handled;\n  };\n\n  /**\n   * Checks if the submenu should be closed\n   */\n  const shouldCloseSubMenu = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    const submenuCloseKey = getRTL(theme) ? KeyCodes.right : KeyCodes.left;\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which !== submenuCloseKey || !isSubMenu) {\n      return false;\n    }\n\n    return !!(\n      focusZoneDirection === FocusZoneDirection.vertical ||\n      (checkForNoWrap && !shouldWrapFocus(ev.target as HTMLElement, 'data-no-horizontal-wrap'))\n    );\n  };\n\n  const shouldHandleKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    return (\n      // eslint-disable-next-line deprecation/deprecation\n      ev.which === KeyCodes.escape ||\n      shouldCloseSubMenu(ev) ||\n      // eslint-disable-next-line deprecation/deprecation\n      (ev.which === KeyCodes.up && (ev.altKey || ev.metaKey))\n    );\n  };\n\n  const onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in shouldHandleKeyUp for reasoning.\n    lastKeyDownWasAltOrMeta.current = isAltOrMeta(ev);\n\n    // On Mac, pressing escape dismisses all levels of native context menus\n    // eslint-disable-next-line deprecation/deprecation\n    const dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n\n    return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);\n  };\n\n  /**\n   * We close the menu on key up only if ALL of the following are true:\n   * - Most recent key down was alt or meta (command)\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n   *   expand/collapse the menu)\n   * - We're not on a Mac (or iOS)\n   *\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n   * closing any open context menus. There is not a similar behavior on Macs.\n   */\n  const shouldHandleKeyUp = (ev: React.KeyboardEvent<HTMLElement>) => {\n    const keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta(ev);\n    lastKeyDownWasAltOrMeta.current = false;\n    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n  };\n\n  const onKeyUp = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    return keyHandler(ev, shouldHandleKeyUp, true /* dismissAllMenus */);\n  };\n\n  const onMenuKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    // Mark as handled if onKeyDown returns true (for handling collapse cases)\n    // or if we are attempting to expand a submenu\n    const handled = onKeyDown(ev);\n\n    if (handled || !hostElement.current) {\n      return;\n    }\n\n    // If we have a modifier key being pressed, we do not want to move focus.\n    // Otherwise, handle up and down keys.\n    const hasModifier = !!(ev.altKey || ev.metaKey);\n    // eslint-disable-next-line deprecation/deprecation\n    const isUp = ev.which === KeyCodes.up;\n    // eslint-disable-next-line deprecation/deprecation\n    const isDown = ev.which === KeyCodes.down;\n    if (!hasModifier && (isUp || isDown)) {\n      const elementToFocus = isUp\n        ? getLastFocusable(hostElement.current, hostElement.current.lastChild as HTMLElement, true)\n        : getFirstFocusable(hostElement.current, hostElement.current.firstChild as HTMLElement, true);\n\n      if (elementToFocus) {\n        elementToFocus.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  const onItemKeyDown = (item: any, ev: React.KeyboardEvent<HTMLElement>): void => {\n    const openKey = getRTL(theme) ? KeyCodes.left : KeyCodes.right;\n\n    if (\n      !item.disabled &&\n      // eslint-disable-next-line deprecation/deprecation\n      (ev.which === openKey || ev.which === KeyCodes.enter || (ev.which === KeyCodes.down && (ev.altKey || ev.metaKey)))\n    ) {\n      openSubMenu(item, ev.currentTarget as HTMLElement);\n      ev.preventDefault();\n    }\n  };\n\n  return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown] as const;\n}\n\nfunction useScrollHandler(asyncTracker: Async) {\n  const isScrollIdle = React.useRef<boolean>(true);\n  const scrollIdleTimeoutId = React.useRef<number | undefined>();\n\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n  const onScroll = (): void => {\n    if (!isScrollIdle.current && scrollIdleTimeoutId.current !== undefined) {\n      asyncTracker.clearTimeout(scrollIdleTimeoutId.current);\n      scrollIdleTimeoutId.current = undefined;\n    } else {\n      isScrollIdle.current = false;\n    }\n\n    scrollIdleTimeoutId.current = asyncTracker.setTimeout(() => {\n      isScrollIdle.current = true;\n    }, NavigationIdleDelay);\n  };\n\n  return [onScroll, isScrollIdle] as const;\n}\n\nfunction useOnSubmenuDismiss(dismiss: (ev?: any, dismissAll?: boolean) => void, closeSubMenu: () => void) {\n  const isMountedRef = React.useRef(false);\n  React.useEffect(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  /**\n   * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n   * after the component is unmounted. The isMountedRef is added to prevent\n   * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n   * code.\n   */\n  const onSubMenuDismiss = (ev?: any, dismissAll?: boolean): void => {\n    if (dismissAll) {\n      dismiss(ev, dismissAll);\n    } else if (isMountedRef.current) {\n      closeSubMenu();\n    }\n  };\n\n  return onSubMenuDismiss;\n}\n\nfunction useSubmenuEnterTimer({ subMenuHoverDelay = NavigationIdleDelay }: IContextualMenuProps, asyncTracker: Async) {\n  const enterTimerRef = React.useRef<number | undefined>(undefined);\n\n  const cancelSubMenuTimer = () => {\n    if (enterTimerRef.current !== undefined) {\n      asyncTracker.clearTimeout(enterTimerRef.current);\n      enterTimerRef.current = undefined;\n    }\n  };\n\n  const startSubmenuTimer = (onTimerExpired: () => void) => {\n    enterTimerRef.current = asyncTracker.setTimeout(() => {\n      onTimerExpired();\n      cancelSubMenuTimer();\n    }, subMenuHoverDelay);\n  };\n\n  return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef as React.RefObject<number | undefined>] as const;\n}\n\nfunction useMouseHandlers(\n  props: IContextualMenuProps,\n  isScrollIdle: React.MutableRefObject<boolean>,\n  subMenuEntryTimer: React.RefObject<number | undefined>,\n  targetWindow: Window | undefined,\n  shouldUpdateFocusOnMouseEvent: React.MutableRefObject<boolean>,\n  gotMouseMove: React.MutableRefObject<boolean>,\n  expandedMenuItemKey: string | undefined,\n  hostElement: React.RefObject<HTMLDivElement>,\n  startSubmenuTimer: (onTimerExpired: () => void) => void,\n  cancelSubMenuTimer: () => void,\n  openSubMenu: (submenuItemKey: IContextualMenuItem, target: HTMLElement, openedByMouseClick?: boolean) => void,\n  onSubMenuDismiss: (ev?: any, dismissAll?: boolean) => void,\n  dismiss: (ev?: any, dismissAll?: boolean) => void,\n) {\n  const { target: menuTarget } = props;\n\n  const onItemMouseEnterBase = (item: any, ev: React.MouseEvent<HTMLElement>, target?: HTMLElement): void => {\n    if (shouldUpdateFocusOnMouseEvent.current) {\n      gotMouseMove.current = true;\n    }\n\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  const onItemMouseMoveBase = (item: any, ev: React.MouseEvent<HTMLElement>, target: HTMLElement): void => {\n    const targetElement = ev.currentTarget as HTMLElement;\n\n    // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n    if (shouldUpdateFocusOnMouseEvent.current) {\n      gotMouseMove.current = true;\n    } else {\n      return;\n    }\n\n    if (\n      !isScrollIdle.current ||\n      subMenuEntryTimer.current !== undefined ||\n      targetElement === (targetWindow?.document.activeElement as HTMLElement)\n    ) {\n      return;\n    }\n\n    updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  const shouldIgnoreMouseEvent = (): boolean => {\n    return !isScrollIdle.current || !gotMouseMove.current;\n  };\n\n  const onMouseItemLeave = (item: any, ev: React.MouseEvent<HTMLElement>): void => {\n    if (shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    cancelSubMenuTimer();\n\n    if (expandedMenuItemKey !== undefined) {\n      return;\n    }\n\n    /**\n     * IE11 focus() method forces parents to scroll to top of element.\n     * Edge and IE expose a setActive() function for focusable divs that\n     * sets the page focus but does not scroll the parent element.\n     */\n    if ((hostElement.current as any).setActive) {\n      try {\n        (hostElement.current as any).setActive();\n      } catch (e) {\n        /* no-op */\n      }\n    } else {\n      hostElement.current?.focus();\n    }\n  };\n\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n  const updateFocusOnMouseEvent = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement>,\n    target?: HTMLElement,\n  ) => {\n    const targetElement = target ? target : (ev.currentTarget as HTMLElement);\n\n    if (item.key === expandedMenuItemKey) {\n      return;\n    }\n\n    cancelSubMenuTimer();\n\n    // If the menu is not expanded we can update focus without any delay\n    if (expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    }\n\n    // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      startSubmenuTimer(() => {\n        targetElement.focus();\n        openSubMenu(item, targetElement, true);\n      });\n    } else {\n      startSubmenuTimer(() => {\n        onSubMenuDismiss(ev);\n        targetElement.focus();\n      });\n    }\n  };\n\n  const onItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    onItemClickBase(item, ev, ev.currentTarget as HTMLElement);\n  };\n\n  const onItemClickBase = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    target: HTMLElement,\n  ): void => {\n    const items = getSubmenuItems(item, { target: menuTarget });\n\n    // Cancel an async menu item hover timeout action from being taken and instead\n    // just trigger the click event instead.\n    cancelSubMenuTimer();\n\n    if (!hasSubmenu(item) && (!items || !items.length)) {\n      // This is an item without a menu. Click it.\n      executeItemClick(item, ev);\n    } else {\n      if (item.key !== expandedMenuItemKey) {\n        // This has a collapsed sub menu. Expand it.\n\n        // focus on the container by default when the menu is opened with a click event\n        // this differentiates from a keyboard interaction triggering the click event\n        const shouldFocusOnContainer =\n          typeof props.shouldFocusOnContainer === 'boolean'\n            ? props.shouldFocusOnContainer\n            : (ev.nativeEvent as PointerEvent).pointerType === 'mouse';\n        openSubMenu(item, target, shouldFocusOnContainer);\n      }\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  const onAnchorClick = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>) => {\n    executeItemClick(item, ev);\n    ev.stopPropagation();\n  };\n\n  const executeItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    if (item.disabled || item.isDisabled) {\n      return;\n    }\n\n    if (item.preferMenuTargetAsEventTarget) {\n      overrideTarget(ev, menuTarget);\n    }\n\n    let shouldDismiss = false;\n    if (item.onClick) {\n      shouldDismiss = !!item.onClick(ev, item);\n    } else if (props.onItemClick) {\n      shouldDismiss = !!props.onItemClick(ev, item);\n    }\n\n    if (shouldDismiss || !ev.defaultPrevented) {\n      dismiss(ev, true);\n    }\n  };\n\n  return [\n    onItemMouseEnterBase,\n    onItemMouseMoveBase,\n    onMouseItemLeave,\n    onItemClick,\n    onAnchorClick,\n    executeItemClick,\n    onItemClickBase,\n  ] as const;\n}\n//#endregion\n\nexport const ContextualMenuBase: React.FunctionComponent<IContextualMenuProps> = React.memo(\n  React.forwardRef<HTMLDivElement, IContextualMenuProps>((propsWithoutDefaults, forwardedRef) => {\n    const { ref, ...props } = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n    const hostElement = React.useRef<HTMLDivElement>(null);\n    const asyncTracker = useAsync();\n    const menuId = useId(COMPONENT_NAME, props.id);\n\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      deprecations: {\n        getMenuClassNames: 'styles',\n      },\n    });\n\n    const dismiss = (ev?: any, dismissAll?: boolean) => props.onDismiss?.(ev, dismissAll);\n    const [targetRef, targetWindow] = useTarget(props.target, hostElement);\n    const [tryFocusPreviousActiveElement] = usePreviousActiveElement(props, targetWindow, hostElement);\n    const [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss] = useSubMenuState(props, dismiss);\n    const [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture] = useShouldUpdateFocusOnMouseMove(props);\n    const [onScroll, isScrollIdle] = useScrollHandler(asyncTracker);\n    const [cancelSubMenuTimer, startSubmenuTimer, subMenuEntryTimer] = useSubmenuEnterTimer(props, asyncTracker);\n\n    const responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);\n\n    useVisibility(props, targetWindow);\n\n    const [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown] = useKeyHandlers(props, dismiss, hostElement, openSubMenu);\n    const [\n      onItemMouseEnterBase,\n      onItemMouseMoveBase,\n      onMouseItemLeave,\n      onItemClick,\n      onAnchorClick,\n      executeItemClick,\n      onItemClickBase,\n    ] = useMouseHandlers(\n      props,\n      isScrollIdle,\n      subMenuEntryTimer,\n      targetWindow,\n      shouldUpdateFocusOnMouseEvent,\n      gotMouseMove,\n      expandedMenuItemKey,\n      hostElement,\n      startSubmenuTimer,\n      cancelSubMenuTimer,\n      openSubMenu,\n      onSubMenuDismiss,\n      dismiss,\n    );\n\n    //#region Render helpers\n\n    const onDefaultRenderMenuList = (\n      menuListProps: IContextualMenuListProps,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n      defaultRender?: IRenderFunction<IContextualMenuListProps>,\n    ): JSX.Element => {\n      let indexCorrection = 0;\n      const { items, totalItemCount, hasCheckmarks, hasIcons } = menuListProps;\n\n      return (\n        <ul className={menuClassNames.list} onKeyDown={onKeyDown} onKeyUp={onKeyUp} role={'presentation'}>\n          {items.map((item, index) => {\n            const menuItem = renderMenuItem(\n              item,\n              index,\n              indexCorrection,\n              totalItemCount,\n              hasCheckmarks,\n              hasIcons,\n              menuClassNames,\n            );\n            if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n              const indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n              indexCorrection += indexIncrease;\n            }\n            return menuItem;\n          })}\n        </ul>\n      );\n    };\n\n    const renderFocusZone = (children: JSX.Element | null, adjustedFocusZoneProps: IFocusZoneProps): JSX.Element => {\n      const { focusZoneAs: ChildrenRenderer = FocusZone } = props;\n      return <ChildrenRenderer {...adjustedFocusZoneProps}>{children}</ChildrenRenderer>;\n    };\n\n    /**\n     * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n     * cause the menu items to always re-render because the component update is based on shallow comparison.\n     */\n    const renderMenuItem = (\n      item: IContextualMenuItem,\n      index: number,\n      focusableElementIndex: number,\n      totalItemCount: number,\n      hasCheckmarks: boolean,\n      hasIcons: boolean,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n    ): JSX.Element => {\n      const renderedItems: React.ReactNode[] = [];\n      const iconProps = item.iconProps || { iconName: 'None' };\n      const {\n        getItemClassNames, // eslint-disable-line deprecation/deprecation\n        itemProps,\n      } = item;\n      const styles = itemProps ? itemProps.styles : undefined;\n\n      // We only send a dividerClassName when the item to be rendered is a divider.\n      // For all other cases, the default divider style is used.\n      const dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n      const subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';\n\n      // eslint-disable-next-line deprecation/deprecation\n      let itemClassNames: IMenuItemClassNames;\n\n      // IContextualMenuItem#getItemClassNames for backwards compatibility\n      // otherwise uses mergeStyles for class names.\n      if (getItemClassNames) {\n        itemClassNames = getItemClassNames(\n          props.theme!,\n          isItemDisabled(item),\n          expandedMenuItemKey === item.key,\n          !!getIsChecked(item),\n          !!item.href,\n          iconProps.iconName !== 'None',\n          item.className,\n          dividerClassName,\n          iconProps.className,\n          subMenuIconClassName,\n          item.primaryDisabled,\n        );\n      } else {\n        const itemStyleProps: IContextualMenuItemStyleProps = {\n          theme: props.theme!,\n          disabled: isItemDisabled(item),\n          expanded: expandedMenuItemKey === item.key,\n          checked: !!getIsChecked(item),\n          isAnchorLink: !!item.href,\n          knownIcon: iconProps.iconName !== 'None',\n          itemClassName: item.className,\n          dividerClassName,\n          iconClassName: iconProps.className,\n          subMenuClassName: subMenuIconClassName,\n          primaryDisabled: item.primaryDisabled,\n        };\n\n        // We need to generate default styles then override if styles are provided\n        // since the ContextualMenu currently handles item classNames.\n        itemClassNames = getContextualMenuItemClassNames(\n          _getMenuItemStylesFunction(menuClassNames.subComponentStyles?.menuItem, styles),\n          itemStyleProps,\n        );\n      }\n\n      // eslint-disable-next-line deprecation/deprecation\n      if (item.text === '-' || item.name === '-') {\n        item.itemType = ContextualMenuItemType.Divider;\n      }\n      switch (item.itemType) {\n        case ContextualMenuItemType.Divider:\n          renderedItems.push(renderSeparator(index, itemClassNames));\n          break;\n        case ContextualMenuItemType.Header:\n          renderedItems.push(renderSeparator(index, itemClassNames));\n          const headerItem = renderHeaderMenuItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons);\n          renderedItems.push(renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n          break;\n        case ContextualMenuItemType.Section:\n          renderedItems.push(renderSectionItem(item, itemClassNames, menuClassNames, index, hasCheckmarks, hasIcons));\n          break;\n        default:\n          const defaultRenderNormalItem = () =>\n            renderNormalItem(\n              item,\n              itemClassNames,\n              index,\n              focusableElementIndex,\n              totalItemCount,\n              hasCheckmarks,\n              hasIcons,\n            ) as JSX.Element;\n\n          const menuItem = props.onRenderContextualMenuItem\n            ? props.onRenderContextualMenuItem(item, defaultRenderNormalItem)\n            : defaultRenderNormalItem();\n          renderedItems.push(renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n          break;\n      }\n\n      // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n      // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n      return <React.Fragment key={item.key}>{renderedItems}</React.Fragment>;\n    };\n\n    const defaultMenuItemRenderer = (\n      item: IContextualMenuItemRenderProps,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n    ): React.ReactNode => {\n      const { index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons } = item;\n      return renderMenuItem(\n        item,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n        menuClassNames,\n      );\n    };\n\n    const renderSectionItem = (\n      sectionItem: IContextualMenuItem,\n      // eslint-disable-next-line deprecation/deprecation\n      itemClassNames: IMenuItemClassNames,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n      index: number,\n      hasCheckmarks: boolean,\n      hasIcons: boolean,\n    ) => {\n      const sectionProps = sectionItem.sectionProps;\n      if (!sectionProps) {\n        return;\n      }\n\n      let headerItem;\n      let groupProps;\n      if (sectionProps.title) {\n        let headerContextualMenuItem: IContextualMenuItem | undefined = undefined;\n        let ariaLabelledby = '';\n        if (typeof sectionProps.title === 'string') {\n          // Since title is a user-facing string, it needs to be stripped\n          // of whitespace in order to build a valid element ID\n          const id = menuId + sectionProps.title.replace(/\\s/g, '');\n          headerContextualMenuItem = {\n            key: `section-${sectionProps.title}-title`,\n            itemType: ContextualMenuItemType.Header,\n            text: sectionProps.title,\n            id,\n          };\n          ariaLabelledby = id;\n        } else {\n          const id = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\\s/g, '');\n          headerContextualMenuItem = { ...sectionProps.title, id };\n          ariaLabelledby = id;\n        }\n\n        if (headerContextualMenuItem) {\n          groupProps = {\n            role: 'group',\n            'aria-labelledby': ariaLabelledby,\n          };\n          headerItem = renderHeaderMenuItem(\n            headerContextualMenuItem,\n            itemClassNames,\n            menuClassNames,\n            index,\n            hasCheckmarks,\n            hasIcons,\n          );\n        }\n      }\n\n      if (sectionProps.items && sectionProps.items.length > 0) {\n        let correctedIndex = 0;\n        return (\n          <li role=\"presentation\" key={sectionProps.key || sectionItem.key || `section-${index}`}>\n            <div {...groupProps}>\n              <ul className={menuClassNames.list} role=\"presentation\">\n                {sectionProps.topDivider && renderSeparator(index, itemClassNames, true, true)}\n                {headerItem && renderListItem(headerItem, sectionItem.key || index, itemClassNames, sectionItem.title)}\n                {sectionProps.items.map((contextualMenuItem, itemsIndex) => {\n                  const menuItem = renderMenuItem(\n                    contextualMenuItem,\n                    itemsIndex,\n                    correctedIndex,\n                    getItemCount(sectionProps.items),\n                    hasCheckmarks,\n                    hasIcons,\n                    menuClassNames,\n                  );\n                  if (\n                    contextualMenuItem.itemType !== ContextualMenuItemType.Divider &&\n                    contextualMenuItem.itemType !== ContextualMenuItemType.Header\n                  ) {\n                    const indexIncrease = contextualMenuItem.customOnRenderListLength\n                      ? contextualMenuItem.customOnRenderListLength\n                      : 1;\n                    correctedIndex += indexIncrease;\n                  }\n                  return menuItem;\n                })}\n                {sectionProps.bottomDivider && renderSeparator(index, itemClassNames, false, true)}\n              </ul>\n            </div>\n          </li>\n        );\n      }\n    };\n\n    const renderListItem = (\n      content: React.ReactNode,\n      key: string | number,\n      classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n      title?: string,\n    ) => {\n      return (\n        <li role=\"presentation\" title={title} key={key} className={classNames.item}>\n          {content}\n        </li>\n      );\n    };\n\n    const renderSeparator = (\n      index: number,\n      classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n      top?: boolean,\n      fromSection?: boolean,\n    ): React.ReactNode => {\n      if (fromSection || index > 0) {\n        return (\n          <li\n            role=\"separator\"\n            key={'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom')}\n            className={classNames.divider}\n            aria-hidden=\"true\"\n          />\n        );\n      }\n      return null;\n    };\n\n    const renderNormalItem = (\n      item: IContextualMenuItem,\n      classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n      index: number,\n      focusableElementIndex: number,\n      totalItemCount: number,\n      hasCheckmarks: boolean,\n      hasIcons: boolean,\n    ): React.ReactNode => {\n      if (item.onRender) {\n        return item.onRender(\n          { 'aria-posinset': focusableElementIndex + 1, 'aria-setsize': totalItemCount, ...item },\n          dismiss,\n        );\n      }\n\n      const { contextualMenuItemAs } = props;\n\n      const commonProps = {\n        item,\n        classNames,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n        contextualMenuItemAs,\n        onItemMouseEnter: onItemMouseEnterBase,\n        onItemMouseLeave: onMouseItemLeave,\n        onItemMouseMove: onItemMouseMoveBase,\n        onItemMouseDown,\n        executeItemClick,\n        onItemKeyDown,\n        expandedMenuItemKey,\n        openSubMenu,\n        dismissSubMenu: onSubMenuDismiss,\n        dismissMenu: dismiss,\n      } as const;\n\n      if (item.href) {\n        return <ContextualMenuAnchor {...commonProps} onItemClick={onAnchorClick} />;\n      }\n\n      if (item.split && hasSubmenu(item)) {\n        return (\n          <ContextualMenuSplitButton\n            {...commonProps}\n            onItemClick={onItemClick}\n            onItemClickBase={onItemClickBase}\n            onTap={cancelSubMenuTimer}\n          />\n        );\n      }\n\n      return <ContextualMenuButton {...commonProps} onItemClick={onItemClick} onItemClickBase={onItemClickBase} />;\n    };\n\n    const renderHeaderMenuItem = (\n      item: IContextualMenuItem,\n      // eslint-disable-next-line deprecation/deprecation\n      itemClassNames: IMenuItemClassNames,\n      // eslint-disable-next-line deprecation/deprecation\n      menuClassNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames,\n      index: number,\n      hasCheckmarks: boolean,\n      hasIcons: boolean,\n    ): React.ReactNode => {\n      const { contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem } = props;\n      const { itemProps, id } = item;\n      const divHtmlProperties =\n        itemProps && getNativeProps<React.HTMLAttributes<HTMLDivElement>>(itemProps, divProperties);\n      return (\n        // eslint-disable-next-line deprecation/deprecation\n        <div id={id} className={menuClassNames.header} {...divHtmlProperties} style={item.style}>\n          <ChildrenRenderer\n            item={item}\n            classNames={itemClassNames}\n            index={index}\n            onCheckmarkClick={hasCheckmarks ? onItemClick : undefined}\n            hasIcons={hasIcons}\n            {...itemProps}\n          />\n        </div>\n      );\n    };\n    //#endregion\n\n    //#region Main render\n    let { isBeakVisible } = props;\n\n    const {\n      items,\n      labelElementId,\n      id,\n      className,\n      beakWidth,\n      directionalHint,\n      directionalHintForRTL,\n      alignTargetEdge,\n      gapSpace,\n      coverTarget,\n      ariaLabel,\n      doNotLayer,\n      target,\n      bounds,\n      useTargetWidth,\n      useTargetAsMinWidth,\n      directionalHintFixed,\n      shouldFocusOnMount,\n      shouldFocusOnContainer,\n      title,\n      styles,\n      theme,\n      calloutProps,\n      onRenderSubMenu = onDefaultRenderSubMenu,\n      onRenderMenuList = (\n        menuListProps: IContextualMenuListProps,\n        defaultRender?: IRenderFunction<IContextualMenuListProps>,\n      ) => onDefaultRenderMenuList(menuListProps, classNames, defaultRender),\n      focusZoneProps,\n      // eslint-disable-next-line deprecation/deprecation\n      getMenuClassNames,\n    } = props;\n\n    const classNames = getMenuClassNames\n      ? getMenuClassNames(theme!, className)\n      : getClassNames(styles, {\n          theme: theme!,\n          className,\n        });\n\n    const hasIcons = itemsHaveIcons(items);\n\n    function itemsHaveIcons(contextualMenuItems: IContextualMenuItem[]): boolean {\n      for (const item of contextualMenuItems) {\n        if (item.iconProps) {\n          return true;\n        }\n\n        if (\n          item.itemType === ContextualMenuItemType.Section &&\n          item.sectionProps &&\n          itemsHaveIcons(item.sectionProps.items)\n        ) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    const adjustedFocusZoneProps = {\n      direction: FocusZoneDirection.vertical,\n      handleTabKey: FocusZoneTabbableElements.all,\n      isCircularNavigation: true,\n      ...focusZoneProps,\n      className: css(classNames.root, props.focusZoneProps?.className),\n    };\n\n    const hasCheckmarks = canAnyMenuItemsCheck(items);\n    const submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;\n\n    isBeakVisible = isBeakVisible === undefined ? responsiveMode! <= ResponsiveMode.medium : isBeakVisible;\n    /**\n     * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n     */\n    let contextMenuStyle: React.CSSProperties;\n    const targetAsHtmlElement = targetRef.current as HTMLElement;\n    if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n      const targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n      const targetWidth = targetBoundingRect.width - 2; /* Accounts for 1px border */\n\n      if (useTargetWidth) {\n        contextMenuStyle = {\n          width: targetWidth,\n        };\n      } else if (useTargetAsMinWidth) {\n        contextMenuStyle = {\n          minWidth: targetWidth,\n        };\n      }\n    }\n\n    // The menu should only return if items were provided, if no items were provided then it should not appear.\n    if (items && items.length > 0) {\n      const totalItemCount = getItemCount(items);\n\n      const calloutStyles = classNames.subComponentStyles\n        ? (classNames.subComponentStyles.callout as IStyleFunctionOrObject<\n            ICalloutContentStyleProps,\n            ICalloutContentStyles\n          >)\n        : undefined;\n\n      return (\n        <MenuContext.Consumer>\n          {menuContext => (\n            <Callout\n              styles={calloutStyles}\n              onRestoreFocus={tryFocusPreviousActiveElement}\n              {...calloutProps}\n              target={target || (menuContext.target as IContextualMenuProps['target'])}\n              isBeakVisible={isBeakVisible}\n              beakWidth={beakWidth}\n              directionalHint={directionalHint}\n              directionalHintForRTL={directionalHintForRTL}\n              gapSpace={gapSpace}\n              coverTarget={coverTarget}\n              doNotLayer={doNotLayer}\n              className={css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className)}\n              setInitialFocus={shouldFocusOnMount}\n              onDismiss={props.onDismiss || menuContext.onDismiss}\n              onScroll={onScroll}\n              bounds={bounds}\n              directionalHintFixed={directionalHintFixed}\n              alignTargetEdge={alignTargetEdge}\n              hidden={props.hidden || menuContext.hidden}\n              ref={forwardedRef}\n            >\n              <div\n                style={contextMenuStyle}\n                ref={hostElement}\n                id={id}\n                className={classNames.container}\n                tabIndex={shouldFocusOnContainer ? 0 : -1}\n                onKeyDown={onMenuKeyDown}\n                onKeyUp={onKeyUp}\n                onFocusCapture={onMenuFocusCapture}\n                aria-label={ariaLabel}\n                aria-labelledby={labelElementId}\n                role={'menu'}\n              >\n                {title && <div className={classNames.title}> {title} </div>}\n                {items && items.length\n                  ? renderFocusZone(\n                      onRenderMenuList(\n                        {\n                          ariaLabel,\n                          items,\n                          totalItemCount,\n                          hasCheckmarks,\n                          hasIcons,\n                          defaultMenuItemRenderer: (item: IContextualMenuItemRenderProps) =>\n                            defaultMenuItemRenderer(item, classNames),\n                          labelElementId,\n                        },\n                        (\n                          menuListProps: IContextualMenuListProps,\n                          defaultRender?: IRenderFunction<IContextualMenuListProps>,\n                        ) => onDefaultRenderMenuList(menuListProps, classNames, defaultRender),\n                      ),\n                      adjustedFocusZoneProps,\n                    )\n                  : null}\n                {submenuProps && onRenderSubMenu(submenuProps, onDefaultRenderSubMenu)}\n              </div>\n              <FocusRects />\n            </Callout>\n          )}\n        </MenuContext.Consumer>\n      );\n    } else {\n      return null;\n    }\n    //#endregion\n  }),\n  (prevProps, newProps) => {\n    if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return true;\n    }\n\n    return shallowCompare(prevProps, newProps);\n  },\n);\nContextualMenuBase.displayName = 'ContextualMenuBase';\n\n/**\n * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n */\nfunction isAltOrMeta(ev: React.KeyboardEvent<HTMLElement>): boolean {\n  // eslint-disable-next-line deprecation/deprecation\n  return ev.which === KeyCodes.alt || ev.key === 'Meta';\n}\n\nfunction onItemMouseDown(item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>): void {\n  item.onMouseDown?.(item, ev);\n}\n\nfunction onDefaultRenderSubMenu(\n  subMenuProps: IContextualMenuProps,\n  defaultRender?: IRenderFunction<IContextualMenuProps>,\n): JSX.Element {\n  throw Error(\n    'ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' +\n      'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.',\n  );\n}\n\n/**\n * Returns the item that matches a given key if any.\n * @param key - The key of the item to match\n * @param items - The items to look for the key\n */\nfunction findItemByKeyFromItems(key: string, items: IContextualMenuItem[]): IContextualMenuItem | undefined {\n  for (const item of items) {\n    if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n      const match = findItemByKeyFromItems(key, item.sectionProps.items);\n      if (match) {\n        return match;\n      }\n    } else if (item.key && item.key === key) {\n      return item;\n    }\n  }\n}\n\nfunction getOnClickWithOverrideTarget(\n  onClick:\n    | ((\n        ev?: React.MouseEvent<HTMLElement, MouseEvent> | React.KeyboardEvent<HTMLElement> | undefined,\n        item?: IContextualMenuItem | undefined,\n      ) => boolean | void)\n    | undefined,\n  target: Target | undefined,\n) {\n  return onClick\n    ? (\n        ev?: React.MouseEvent<HTMLElement, MouseEvent> | React.KeyboardEvent<HTMLElement> | undefined,\n        item?: IContextualMenuItem | undefined,\n      ) => {\n        overrideTarget(ev, target);\n\n        return onClick(ev, item);\n      }\n    : onClick;\n}\n\nfunction overrideTarget(\n  ev?: React.MouseEvent<HTMLElement, MouseEvent> | React.KeyboardEvent<HTMLElement> | undefined,\n  target?: Target,\n): void {\n  if (ev && target) {\n    ev.persist();\n\n    if (target instanceof Event) {\n      ev.target = target.target as HTMLElement;\n    } else if (target instanceof Element) {\n      ev.target = target;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}