{"ast":null,"code":"import * as React from 'react';\nimport { useIsomorphicLayoutEffect, useRefEffect } from '@fluentui/react-hooks';\nimport { getWindow } from '@fluentui/utilities';\nimport { observeResize } from './observeResize';\n/**\n * Track whether any items don't fit within their container, and move them to the overflow menu.\n * Items are moved into the overflow menu from back to front, excluding pinned items.\n *\n * The overflow menu button must be the last sibling of all of the items that can be put into the overflow, and it\n * must be hooked up to the `setMenuButtonRef` setter function that's returned by `useOverflow`:\n * ```ts\n * const overflow = useOverflow(...);\n * ```\n * ```jsx\n * <Container>\n *  <Item /> // Index 0\n *  <Item /> // Index 1\n *  ...\n *  <Button ref={overflow.setMenuButtonRef} /> // Can be any React.Component or HTMLElement\n * </Container>\n * ```\n */\nexport var useOverflow = function (_a) {\n  var onOverflowItemsChanged = _a.onOverflowItemsChanged,\n    rtl = _a.rtl,\n    pinnedIndex = _a.pinnedIndex;\n  var updateOverflowRef = React.useRef();\n  var containerWidthRef = React.useRef();\n  // Attach a resize observer to the container\n  var containerRef = useRefEffect(function (container) {\n    var cleanupObserver = observeResize(container, function (entries) {\n      containerWidthRef.current = entries ? entries[0].contentRect.width : container.clientWidth;\n      if (updateOverflowRef.current) {\n        updateOverflowRef.current();\n      }\n    });\n    return function () {\n      cleanupObserver();\n      containerWidthRef.current = undefined;\n    };\n  });\n  var menuButtonRef = useRefEffect(function (menuButton) {\n    containerRef(menuButton.parentElement);\n    return function () {\n      return containerRef(null);\n    };\n  });\n  useIsomorphicLayoutEffect(function () {\n    var container = containerRef.current;\n    var menuButton = menuButtonRef.current;\n    if (!container || !menuButton) {\n      return;\n    }\n    // items contains the container's children, excluding the overflow menu button itself\n    var items = [];\n    for (var i = 0; i < container.children.length; i++) {\n      var item = container.children[i];\n      if (item instanceof HTMLElement && item !== menuButton) {\n        items.push(item);\n      }\n    }\n    // Keep track of the minimum width of the container to fit each child index.\n    // This cache is an integral part of the algorithm and not just a performance optimization: it allows us to\n    // recalculate the overflowIndex on subsequent resizes even if some items are already inside the overflow.\n    var minContainerWidth = [];\n    var extraWidth = 0; // The accumulated width of items that don't move into the overflow\n    updateOverflowRef.current = function () {\n      var containerWidth = containerWidthRef.current;\n      if (containerWidth === undefined) {\n        return;\n      }\n      // Iterate the items in reverse order until we find one that fits within the bounds of the container\n      for (var i = items.length - 1; i >= 0; i--) {\n        // Calculate the min container width for this item if we haven't done so yet\n        if (minContainerWidth[i] === undefined) {\n          var itemOffsetEnd = rtl ? containerWidth - items[i].offsetLeft : items[i].offsetLeft + items[i].offsetWidth;\n          // If the item after this one is pinned, reserve space for it\n          if (i + 1 < items.length && i + 1 === pinnedIndex) {\n            // Use distance between the end of the previous item and this one (rather than the\n            // pinned item's offsetWidth), to account for any margin between the items.\n            extraWidth = minContainerWidth[i + 1] - itemOffsetEnd;\n          }\n          // Reserve space for the menu button after the first item was added to the overflow\n          if (i === items.length - 2) {\n            extraWidth += menuButton.offsetWidth;\n          }\n          minContainerWidth[i] = itemOffsetEnd + extraWidth;\n        }\n        if (containerWidth > minContainerWidth[i]) {\n          setOverflowIndex(i + 1);\n          return;\n        }\n      }\n      // If we got here, nothing fits outside the overflow\n      setOverflowIndex(0);\n    };\n    var prevOverflowIndex = items.length;\n    var setOverflowIndex = function (overflowIndex) {\n      if (prevOverflowIndex !== overflowIndex) {\n        prevOverflowIndex = overflowIndex;\n        onOverflowItemsChanged(overflowIndex, items.map(function (ele, index) {\n          return {\n            ele: ele,\n            isOverflowing: index >= overflowIndex && index !== pinnedIndex\n          };\n        }));\n      }\n    };\n    var cancelAnimationFrame = undefined;\n    // If the container width is already known from a previous render, update the overflow with its width.\n    // Do this in an animation frame to avoid forcing layout to happen early.\n    if (containerWidthRef.current !== undefined) {\n      var win_1 = getWindow(container);\n      if (win_1) {\n        var animationFrameId_1 = win_1.requestAnimationFrame(updateOverflowRef.current);\n        cancelAnimationFrame = function () {\n          return win_1.cancelAnimationFrame(animationFrameId_1);\n        };\n      }\n    }\n    return function () {\n      if (cancelAnimationFrame) {\n        cancelAnimationFrame();\n      }\n      // On cleanup, need to remove all items from the overflow\n      // so they don't have stale properties on the next render\n      setOverflowIndex(items.length);\n      updateOverflowRef.current = undefined;\n    };\n  });\n  return {\n    menuButtonRef: menuButtonRef\n  };\n};","map":{"version":3,"names":["React","useIsomorphicLayoutEffect","useRefEffect","getWindow","observeResize","useOverflow","_a","onOverflowItemsChanged","rtl","pinnedIndex","updateOverflowRef","useRef","containerWidthRef","containerRef","container","cleanupObserver","entries","current","contentRect","width","clientWidth","undefined","menuButtonRef","menuButton","parentElement","items","i","children","length","item","HTMLElement","push","minContainerWidth","extraWidth","containerWidth","itemOffsetEnd","offsetLeft","offsetWidth","setOverflowIndex","prevOverflowIndex","overflowIndex","map","ele","index","isOverflowing","cancelAnimationFrame","win_1","animationFrameId_1","requestAnimationFrame"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/src/utilities/useOverflow.ts"],"sourcesContent":["import * as React from 'react';\nimport { useIsomorphicLayoutEffect, useRefEffect } from '@fluentui/react-hooks';\nimport { getWindow } from '@fluentui/utilities';\nimport { observeResize } from './observeResize';\nimport type { RefCallback } from '@fluentui/react-hooks';\n\n/**\n * Callback to notify the user that the items in the overflow have changed. This should ensure that the overflow menu\n * is visible, and contains all of the overflowing items.\n *\n * @param overflowIndex - The index of the first item in the overflow, or items.length if nothing is overflowing.\n * @param items - The list of all items in the container, and whether that particular item is in the overflow\n */\nexport type OverflowItemsChangedCallback = (\n  overflowIndex: number,\n  items: { ele: HTMLElement; isOverflowing: boolean }[],\n) => void;\n\n/** Parameters for {@see useOverflow} */\nexport type OverflowParams = {\n  /** Callback to notify the user that the items in the overflow have changed. */\n  onOverflowItemsChanged: OverflowItemsChangedCallback;\n\n  /** True if the element containing overflowMenuButtonRef is in right-to-left order */\n  rtl: boolean;\n\n  /** Optional: Index of item that should never go into the overflow menu. */\n  pinnedIndex?: number;\n};\n\n/** Return value for {@see useOverflow} */\nexport type OverflowRefs = {\n  /** Set the overflow menu button's ref to this ref callback */\n  menuButtonRef: RefCallback<HTMLElement>;\n};\n\n/**\n * Track whether any items don't fit within their container, and move them to the overflow menu.\n * Items are moved into the overflow menu from back to front, excluding pinned items.\n *\n * The overflow menu button must be the last sibling of all of the items that can be put into the overflow, and it\n * must be hooked up to the `setMenuButtonRef` setter function that's returned by `useOverflow`:\n * ```ts\n * const overflow = useOverflow(...);\n * ```\n * ```jsx\n * <Container>\n *  <Item /> // Index 0\n *  <Item /> // Index 1\n *  ...\n *  <Button ref={overflow.setMenuButtonRef} /> // Can be any React.Component or HTMLElement\n * </Container>\n * ```\n */\nexport const useOverflow = ({ onOverflowItemsChanged, rtl, pinnedIndex }: OverflowParams): OverflowRefs => {\n  const updateOverflowRef = React.useRef<() => void>();\n  const containerWidthRef = React.useRef<number>();\n\n  // Attach a resize observer to the container\n  const containerRef = useRefEffect<HTMLElement>(container => {\n    const cleanupObserver = observeResize(container, entries => {\n      containerWidthRef.current = entries ? entries[0].contentRect.width : container.clientWidth;\n      if (updateOverflowRef.current) {\n        updateOverflowRef.current();\n      }\n    });\n\n    return () => {\n      cleanupObserver();\n      containerWidthRef.current = undefined;\n    };\n  });\n\n  const menuButtonRef = useRefEffect<HTMLElement>(menuButton => {\n    containerRef(menuButton.parentElement);\n    return () => containerRef(null);\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    const container = containerRef.current;\n    const menuButton = menuButtonRef.current;\n    if (!container || !menuButton) {\n      return;\n    }\n\n    // items contains the container's children, excluding the overflow menu button itself\n    const items: HTMLElement[] = [];\n    for (let i = 0; i < container.children.length; i++) {\n      const item = container.children[i];\n      if (item instanceof HTMLElement && item !== menuButton) {\n        items.push(item);\n      }\n    }\n\n    // Keep track of the minimum width of the container to fit each child index.\n    // This cache is an integral part of the algorithm and not just a performance optimization: it allows us to\n    // recalculate the overflowIndex on subsequent resizes even if some items are already inside the overflow.\n    const minContainerWidth: number[] = [];\n    let extraWidth = 0; // The accumulated width of items that don't move into the overflow\n\n    updateOverflowRef.current = () => {\n      const containerWidth = containerWidthRef.current;\n      if (containerWidth === undefined) {\n        return;\n      }\n\n      // Iterate the items in reverse order until we find one that fits within the bounds of the container\n      for (let i = items.length - 1; i >= 0; i--) {\n        // Calculate the min container width for this item if we haven't done so yet\n        if (minContainerWidth[i] === undefined) {\n          const itemOffsetEnd = rtl ? containerWidth - items[i].offsetLeft : items[i].offsetLeft + items[i].offsetWidth;\n\n          // If the item after this one is pinned, reserve space for it\n          if (i + 1 < items.length && i + 1 === pinnedIndex) {\n            // Use distance between the end of the previous item and this one (rather than the\n            // pinned item's offsetWidth), to account for any margin between the items.\n            extraWidth = minContainerWidth[i + 1] - itemOffsetEnd;\n          }\n\n          // Reserve space for the menu button after the first item was added to the overflow\n          if (i === items.length - 2) {\n            extraWidth += menuButton.offsetWidth;\n          }\n\n          minContainerWidth[i] = itemOffsetEnd + extraWidth;\n        }\n\n        if (containerWidth > minContainerWidth[i]) {\n          setOverflowIndex(i + 1);\n          return;\n        }\n      }\n\n      // If we got here, nothing fits outside the overflow\n      setOverflowIndex(0);\n    };\n\n    let prevOverflowIndex = items.length;\n    const setOverflowIndex = (overflowIndex: number) => {\n      if (prevOverflowIndex !== overflowIndex) {\n        prevOverflowIndex = overflowIndex;\n        onOverflowItemsChanged(\n          overflowIndex,\n          items.map((ele, index) => ({\n            ele,\n            isOverflowing: index >= overflowIndex && index !== pinnedIndex,\n          })),\n        );\n      }\n    };\n\n    let cancelAnimationFrame: (() => void) | undefined = undefined;\n\n    // If the container width is already known from a previous render, update the overflow with its width.\n    // Do this in an animation frame to avoid forcing layout to happen early.\n    if (containerWidthRef.current !== undefined) {\n      const win = getWindow(container);\n      if (win) {\n        const animationFrameId = win.requestAnimationFrame(updateOverflowRef.current);\n        cancelAnimationFrame = () => win.cancelAnimationFrame(animationFrameId);\n      }\n    }\n\n    return () => {\n      if (cancelAnimationFrame) {\n        cancelAnimationFrame();\n      }\n\n      // On cleanup, need to remove all items from the overflow\n      // so they don't have stale properties on the next render\n      setOverflowIndex(items.length);\n      updateOverflowRef.current = undefined;\n    };\n  });\n\n  return { menuButtonRef };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}