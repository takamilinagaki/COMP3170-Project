{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { getClassNames } from './DraggableZone.styles';\nimport { on } from '../../Utilities';\nvar eventMapping = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup'\n  }\n};\nvar DraggableZone = /** @class */function (_super) {\n  __extends(DraggableZone, _super);\n  function DraggableZone(props) {\n    var _this = _super.call(this, props) || this;\n    _this._currentEventType = eventMapping.mouse;\n    _this._events = [];\n    _this._onMouseDown = function (event) {\n      var onMouseDown = React.Children.only(_this.props.children).props.onMouseDown;\n      if (onMouseDown) {\n        onMouseDown(event);\n      }\n      _this._currentEventType = eventMapping.mouse;\n      return _this._onDragStart(event);\n    };\n    _this._onMouseUp = function (event) {\n      var onMouseUp = React.Children.only(_this.props.children).props.onMouseUp;\n      if (onMouseUp) {\n        onMouseUp(event);\n      }\n      _this._currentEventType = eventMapping.mouse;\n      return _this._onDragStop(event);\n    };\n    _this._onTouchStart = function (event) {\n      var onTouchStart = React.Children.only(_this.props.children).props.onTouchStart;\n      if (onTouchStart) {\n        onTouchStart(event);\n      }\n      _this._currentEventType = eventMapping.touch;\n      return _this._onDragStart(event);\n    };\n    _this._onTouchEnd = function (event) {\n      var onTouchEnd = React.Children.only(_this.props.children).props.onTouchEnd;\n      if (onTouchEnd) {\n        onTouchEnd(event);\n      }\n      _this._currentEventType = eventMapping.touch;\n      _this._onDragStop(event);\n    };\n    _this._onDragStart = function (event) {\n      // Only handle left click for dragging\n      if (typeof event.button === 'number' && event.button !== 0) {\n        return false;\n      }\n      // If the target doesn't match the handleSelector OR\n      // if the target does match the preventDragSelector, bail out\n      if (_this.props.handleSelector && !_this._matchesSelector(event.target, _this.props.handleSelector) || _this.props.preventDragSelector && _this._matchesSelector(event.target, _this.props.preventDragSelector)) {\n        return;\n      }\n      // Remember the touch identifier if this is a touch event so we can\n      // distinguish between individual touches in multitouch scenarios\n      // by remembering which touch point we were given\n      _this._touchId = _this._getTouchId(event);\n      var position = _this._getControlPosition(event);\n      if (position === undefined) {\n        return;\n      }\n      var dragData = _this._createDragDataFromPosition(position);\n      _this.props.onStart && _this.props.onStart(event, dragData);\n      _this.setState({\n        isDragging: true,\n        lastPosition: position\n      });\n      // hook up the appropriate mouse/touch events to the body to ensure\n      // smooth dragging\n      _this._events = [on(document.body, _this._currentEventType.move, _this._onDrag, true /* use capture phase */), on(document.body, _this._currentEventType.stop, _this._onDragStop, true /* use capture phase */)];\n    };\n\n    _this._onDrag = function (event) {\n      // Prevent scrolling on mobile devices\n      if (event.type === 'touchmove') {\n        event.preventDefault();\n      }\n      var position = _this._getControlPosition(event);\n      if (!position) {\n        return;\n      }\n      // create the updated drag data from the position data\n      var updatedData = _this._createUpdatedDragData(_this._createDragDataFromPosition(position));\n      var updatedPosition = updatedData.position;\n      _this.props.onDragChange && _this.props.onDragChange(event, updatedData);\n      _this.setState({\n        position: updatedPosition,\n        lastPosition: position\n      });\n    };\n    _this._onDragStop = function (event) {\n      if (!_this.state.isDragging) {\n        return;\n      }\n      var position = _this._getControlPosition(event);\n      if (!position) {\n        return;\n      }\n      var baseDragData = _this._createDragDataFromPosition(position);\n      // Set dragging to false and reset the lastPosition\n      _this.setState({\n        isDragging: false,\n        lastPosition: undefined\n      });\n      _this.props.onStop && _this.props.onStop(event, baseDragData);\n      if (_this.props.position) {\n        _this.setState({\n          position: _this.props.position\n        });\n      }\n      // Remove event handlers\n      _this._events.forEach(function (dispose) {\n        return dispose();\n      });\n    };\n    _this.state = {\n      isDragging: false,\n      position: _this.props.position || {\n        x: 0,\n        y: 0\n      },\n      lastPosition: undefined\n    };\n    return _this;\n  }\n  DraggableZone.prototype.componentDidUpdate = function (prevProps) {\n    if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {\n      this.setState({\n        position: this.props.position\n      });\n    }\n  };\n  DraggableZone.prototype.componentWillUnmount = function () {\n    this._events.forEach(function (dispose) {\n      return dispose();\n    });\n  };\n  DraggableZone.prototype.render = function () {\n    var child = React.Children.only(this.props.children);\n    var props = child.props;\n    var position = this.props.position;\n    var _a = this.state,\n      statePosition = _a.position,\n      isDragging = _a.isDragging;\n    var x = statePosition.x;\n    var y = statePosition.y;\n    if (position && !isDragging) {\n      x = position.x;\n      y = position.y;\n    }\n    return React.cloneElement(child, {\n      style: __assign(__assign({}, props.style), {\n        transform: \"translate(\".concat(x, \"px, \").concat(y, \"px)\")\n      }),\n      className: getClassNames(props.className, this.state.isDragging).root,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onTouchStart: this._onTouchStart,\n      onTouchEnd: this._onTouchEnd\n    });\n  };\n  /**\n   * Get the control position based off the event that fired\n   * @param event - The event to get offsets from\n   */\n  DraggableZone.prototype._getControlPosition = function (event) {\n    var touchObj = this._getActiveTouch(event);\n    // did we get the right touch?\n    if (this._touchId !== undefined && !touchObj) {\n      return undefined;\n    }\n    var eventToGetOffset = touchObj || event;\n    return {\n      x: eventToGetOffset.clientX,\n      y: eventToGetOffset.clientY\n    };\n  };\n  /**\n   * Get the active touch point that we have saved from the event's TouchList\n   * @param event - The event used to get the TouchList for the active touch point\n   */\n  DraggableZone.prototype._getActiveTouch = function (event) {\n    return event.targetTouches && this._findTouchInTouchList(event.targetTouches) || event.changedTouches && this._findTouchInTouchList(event.changedTouches);\n  };\n  /**\n   * Get the initial touch identifier associated with the given event\n   * @param event - The event that contains the TouchList\n   */\n  DraggableZone.prototype._getTouchId = function (event) {\n    var touch = event.targetTouches && event.targetTouches[0] || event.changedTouches && event.changedTouches[0];\n    if (touch) {\n      return touch.identifier;\n    }\n  };\n  /**\n   * Returns if an element (or any of the element's parents) match the given selector\n   */\n  DraggableZone.prototype._matchesSelector = function (element, selector) {\n    if (!element || element === document.body) {\n      return false;\n    }\n    var matchesSelectorFn =\n    // eslint-disable-next-line deprecation/deprecation\n    element.matches || element.webkitMatchesSelector || element.msMatchesSelector; /* for IE */\n    if (!matchesSelectorFn) {\n      return false;\n    }\n    return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);\n  };\n  /**\n   * Attempts to find the Touch that matches the identifier  we stored in dragStart\n   * @param touchList The TouchList to look for the stored identifier from dragStart\n   */\n  DraggableZone.prototype._findTouchInTouchList = function (touchList) {\n    if (this._touchId === undefined) {\n      return;\n    }\n    for (var i = 0; i < touchList.length; i++) {\n      if (touchList[i].identifier === this._touchId) {\n        return touchList[i];\n      }\n    }\n    return undefined;\n  };\n  /**\n   * Create DragData based off of the last known position and the new position passed in\n   * @param position The new position as part of the drag\n   */\n  DraggableZone.prototype._createDragDataFromPosition = function (position) {\n    var lastPosition = this.state.lastPosition;\n    // If we have no lastPosition, use the given position\n    // for last position\n    if (lastPosition === undefined) {\n      return {\n        delta: {\n          x: 0,\n          y: 0\n        },\n        lastPosition: position,\n        position: position\n      };\n    }\n    return {\n      delta: {\n        x: position.x - lastPosition.x,\n        y: position.y - lastPosition.y\n      },\n      lastPosition: lastPosition,\n      position: position\n    };\n  };\n  /**\n   * Creates an updated DragData based off the current position and given baseDragData\n   * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions\n   */\n  DraggableZone.prototype._createUpdatedDragData = function (baseDragData) {\n    var position = this.state.position;\n    return {\n      position: {\n        x: position.x + baseDragData.delta.x,\n        y: position.y + baseDragData.delta.y\n      },\n      delta: baseDragData.delta,\n      lastPosition: position\n    };\n  };\n  return DraggableZone;\n}(React.Component);\nexport { DraggableZone };","map":{"version":3,"names":["React","getClassNames","on","eventMapping","touch","start","move","stop","mouse","DraggableZone","_super","__extends","props","_this","call","_currentEventType","_events","_onMouseDown","event","onMouseDown","Children","only","children","_onDragStart","_onMouseUp","onMouseUp","_onDragStop","_onTouchStart","onTouchStart","_onTouchEnd","onTouchEnd","button","handleSelector","_matchesSelector","target","preventDragSelector","_touchId","_getTouchId","position","_getControlPosition","undefined","dragData","_createDragDataFromPosition","onStart","setState","isDragging","lastPosition","document","body","_onDrag","type","preventDefault","updatedData","_createUpdatedDragData","updatedPosition","onDragChange","state","baseDragData","onStop","forEach","dispose","x","y","prototype","componentDidUpdate","prevProps","componentWillUnmount","render","child","_a","statePosition","cloneElement","style","__assign","transform","concat","className","root","touchObj","_getActiveTouch","eventToGetOffset","clientX","clientY","targetTouches","_findTouchInTouchList","changedTouches","identifier","element","selector","matchesSelectorFn","matches","webkitMatchesSelector","msMatchesSelector","parentElement","touchList","i","length","delta","Component"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/utilities/src/utilities/DraggableZone/DraggableZone.tsx"],"sourcesContent":["import * as React from 'react';\nimport { getClassNames } from './DraggableZone.styles';\nimport { on } from '../../Utilities';\nimport type { IDraggableZoneProps, ICoordinates, IDragData } from './DraggableZone.types';\n\nexport interface IDraggableZoneState {\n  isDragging: boolean;\n  position: ICoordinates;\n  lastPosition?: ICoordinates;\n}\n\nconst eventMapping = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend',\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup',\n  },\n};\n\n// These are needed so that we can generalize the events\n// and so we have access to clientX and clientY in the touch events\ntype MouseTouchEvent<T> = React.MouseEvent<T> & React.TouchEvent<T> & Event;\n\nexport class DraggableZone extends React.Component<IDraggableZoneProps, IDraggableZoneState> {\n  private _touchId?: number;\n  private _currentEventType = eventMapping.mouse;\n  private _events: (() => void)[] = [];\n\n  constructor(props: IDraggableZoneProps) {\n    super(props);\n\n    this.state = {\n      isDragging: false,\n      position: this.props.position || { x: 0, y: 0 },\n      lastPosition: undefined,\n    };\n  }\n\n  public componentDidUpdate(prevProps: IDraggableZoneProps) {\n    if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {\n      this.setState({ position: this.props.position });\n    }\n  }\n\n  public componentWillUnmount() {\n    this._events.forEach(dispose => dispose());\n  }\n\n  public render() {\n    const child: any = React.Children.only(this.props.children);\n    const { props } = child;\n    const { position } = this.props;\n    const { position: statePosition, isDragging } = this.state;\n    let x = statePosition.x;\n    let y = statePosition.y;\n\n    if (position && !isDragging) {\n      x = position.x;\n      y = position.y;\n    }\n\n    return React.cloneElement(child, {\n      style: {\n        ...props.style,\n        transform: `translate(${x}px, ${y}px)`,\n      },\n      className: getClassNames(props.className, this.state.isDragging).root,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onTouchStart: this._onTouchStart,\n      onTouchEnd: this._onTouchEnd,\n    });\n  }\n\n  private _onMouseDown = (event: MouseTouchEvent<HTMLElement>) => {\n    const onMouseDown = (React.Children.only(this.props.children) as any).props.onMouseDown;\n    if (onMouseDown) {\n      onMouseDown(event);\n    }\n\n    this._currentEventType = eventMapping.mouse;\n    return this._onDragStart(event);\n  };\n\n  private _onMouseUp = (event: MouseTouchEvent<HTMLElement>) => {\n    const onMouseUp = (React.Children.only(this.props.children) as any).props.onMouseUp;\n    if (onMouseUp) {\n      onMouseUp(event);\n    }\n\n    this._currentEventType = eventMapping.mouse;\n    return this._onDragStop(event);\n  };\n\n  private _onTouchStart = (event: MouseTouchEvent<HTMLElement>) => {\n    const onTouchStart = (React.Children.only(this.props.children) as any).props.onTouchStart;\n    if (onTouchStart) {\n      onTouchStart(event);\n    }\n\n    this._currentEventType = eventMapping.touch;\n    return this._onDragStart(event);\n  };\n\n  private _onTouchEnd = (event: MouseTouchEvent<HTMLElement>) => {\n    const onTouchEnd = (React.Children.only(this.props.children) as any).props.onTouchEnd;\n    if (onTouchEnd) {\n      onTouchEnd(event);\n    }\n\n    this._currentEventType = eventMapping.touch;\n    this._onDragStop(event);\n  };\n\n  private _onDragStart = (event: MouseTouchEvent<HTMLElement>) => {\n    // Only handle left click for dragging\n    if (typeof event.button === 'number' && event.button !== 0) {\n      return false;\n    }\n\n    // If the target doesn't match the handleSelector OR\n    // if the target does match the preventDragSelector, bail out\n    if (\n      (this.props.handleSelector && !this._matchesSelector(event.target as HTMLElement, this.props.handleSelector)) ||\n      (this.props.preventDragSelector &&\n        this._matchesSelector(event.target as HTMLElement, this.props.preventDragSelector))\n    ) {\n      return;\n    }\n\n    // Remember the touch identifier if this is a touch event so we can\n    // distinguish between individual touches in multitouch scenarios\n    // by remembering which touch point we were given\n    this._touchId = this._getTouchId(event);\n\n    const position = this._getControlPosition(event);\n    if (position === undefined) {\n      return;\n    }\n\n    const dragData = this._createDragDataFromPosition(position);\n    this.props.onStart && this.props.onStart(event, dragData);\n\n    this.setState({\n      isDragging: true,\n      lastPosition: position,\n    });\n\n    // hook up the appropriate mouse/touch events to the body to ensure\n    // smooth dragging\n    this._events = [\n      on(document.body, this._currentEventType.move, this._onDrag, true /* use capture phase */),\n      on(document.body, this._currentEventType.stop, this._onDragStop, true /* use capture phase */),\n    ];\n  };\n\n  private _onDrag = (event: MouseTouchEvent<HTMLElement>) => {\n    // Prevent scrolling on mobile devices\n    if (event.type === 'touchmove') {\n      event.preventDefault();\n    }\n\n    const position = this._getControlPosition(event);\n    if (!position) {\n      return;\n    }\n\n    // create the updated drag data from the position data\n    const updatedData = this._createUpdatedDragData(this._createDragDataFromPosition(position));\n    const updatedPosition = updatedData.position;\n\n    this.props.onDragChange && this.props.onDragChange(event, updatedData);\n\n    this.setState({\n      position: updatedPosition,\n      lastPosition: position,\n    });\n  };\n\n  private _onDragStop = (event: MouseTouchEvent<HTMLElement>) => {\n    if (!this.state.isDragging) {\n      return;\n    }\n\n    const position = this._getControlPosition(event);\n    if (!position) {\n      return;\n    }\n\n    const baseDragData = this._createDragDataFromPosition(position);\n\n    // Set dragging to false and reset the lastPosition\n    this.setState({\n      isDragging: false,\n      lastPosition: undefined,\n    });\n\n    this.props.onStop && this.props.onStop(event, baseDragData);\n\n    if (this.props.position) {\n      this.setState({\n        position: this.props.position,\n      });\n    }\n\n    // Remove event handlers\n    this._events.forEach(dispose => dispose());\n  };\n\n  /**\n   * Get the control position based off the event that fired\n   * @param event - The event to get offsets from\n   */\n  private _getControlPosition(event: MouseTouchEvent<HTMLElement>): ICoordinates | undefined {\n    const touchObj = this._getActiveTouch(event);\n\n    // did we get the right touch?\n    if (this._touchId !== undefined && !touchObj) {\n      return undefined;\n    }\n\n    const eventToGetOffset = touchObj || event;\n    return {\n      x: eventToGetOffset.clientX,\n      y: eventToGetOffset.clientY,\n    };\n  }\n\n  /**\n   * Get the active touch point that we have saved from the event's TouchList\n   * @param event - The event used to get the TouchList for the active touch point\n   */\n  private _getActiveTouch(event: MouseTouchEvent<HTMLElement>): React.Touch | undefined {\n    return (\n      (event.targetTouches && this._findTouchInTouchList(event.targetTouches)) ||\n      (event.changedTouches && this._findTouchInTouchList(event.changedTouches))\n    );\n  }\n\n  /**\n   * Get the initial touch identifier associated with the given event\n   * @param event - The event that contains the TouchList\n   */\n  private _getTouchId(event: MouseTouchEvent<HTMLElement>): number | undefined {\n    const touch: React.Touch | undefined =\n      (event.targetTouches && event.targetTouches[0]) || (event.changedTouches && event.changedTouches[0]);\n\n    if (touch) {\n      return touch.identifier;\n    }\n  }\n\n  /**\n   * Returns if an element (or any of the element's parents) match the given selector\n   */\n  private _matchesSelector(element: HTMLElement | null, selector: string): boolean {\n    if (!element || element === document.body) {\n      return false;\n    }\n\n    const matchesSelectorFn: Function =\n      // eslint-disable-next-line deprecation/deprecation\n      element.matches || element.webkitMatchesSelector || (element as any).msMatchesSelector; /* for IE */\n\n    if (!matchesSelectorFn) {\n      return false;\n    }\n\n    return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);\n  }\n\n  /**\n   * Attempts to find the Touch that matches the identifier  we stored in dragStart\n   * @param touchList The TouchList to look for the stored identifier from dragStart\n   */\n  private _findTouchInTouchList(touchList: React.TouchList): React.Touch | undefined {\n    if (this._touchId === undefined) {\n      return;\n    }\n\n    for (let i = 0; i < touchList.length; i++) {\n      if (touchList[i].identifier === this._touchId) {\n        return touchList[i];\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Create DragData based off of the last known position and the new position passed in\n   * @param position The new position as part of the drag\n   */\n  private _createDragDataFromPosition(position: ICoordinates): IDragData {\n    const { lastPosition } = this.state;\n\n    // If we have no lastPosition, use the given position\n    // for last position\n    if (lastPosition === undefined) {\n      return {\n        delta: { x: 0, y: 0 },\n        lastPosition: position,\n        position,\n      };\n    }\n\n    return {\n      delta: {\n        x: position.x - lastPosition.x,\n        y: position.y - lastPosition.y,\n      },\n      lastPosition,\n      position,\n    };\n  }\n\n  /**\n   * Creates an updated DragData based off the current position and given baseDragData\n   * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions\n   */\n  private _createUpdatedDragData(baseDragData: IDragData): IDragData {\n    const { position } = this.state;\n    return {\n      position: {\n        x: position.x + baseDragData.delta.x,\n        y: position.y + baseDragData.delta.y,\n      },\n      delta: baseDragData.delta,\n      lastPosition: position,\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}