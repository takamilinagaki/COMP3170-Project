{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { getRTL, classNamesFunction } from '@fluentui/utilities';\nimport { FocusZone } from '../../FocusZone';\nimport { getDateRangeArray, getDayGrid, getBoundedDateRange, isRestrictedDate, DAYS_IN_WEEK, compareDates, DateRangeType } from '@fluentui/date-time-utilities';\nimport { usePrevious, useId } from '@fluentui/react-hooks';\nimport { CalendarMonthHeaderRow } from './CalendarMonthHeaderRow';\nimport { CalendarGridRow } from './CalendarGridRow';\nvar getClassNames = classNamesFunction();\nfunction useDayRefs() {\n  var daysRef = React.useRef({});\n  var getSetRefCallback = function (dayKey) {\n    return function (element) {\n      if (element === null) {\n        delete daysRef.current[dayKey];\n      } else {\n        daysRef.current[dayKey] = element;\n      }\n    };\n  };\n  return [daysRef, getSetRefCallback];\n}\nfunction useWeeks(props, onSelectDate, getSetRefCallback) {\n  /**\n   * Initial parsing of the given props to generate IDayInfo two dimensional array, which contains a representation\n   * of every day in the grid. Convenient for helping with conversions between day refs and Date objects in callbacks.\n   */\n  var weeks = React.useMemo(function () {\n    var _a;\n    var weeksGrid = getDayGrid(props);\n    var firstVisibleDay = weeksGrid[1][0].originalDate;\n    var lastVisibleDay = weeksGrid[weeksGrid.length - 1][6].originalDate;\n    var markedDays = ((_a = props.getMarkedDays) === null || _a === void 0 ? void 0 : _a.call(props, firstVisibleDay, lastVisibleDay)) || [];\n    /**\n     * Weeks is a 2D array. Weeks[0] contains the last week of the prior range,\n     * Weeks[weeks.length - 1] contains first week of next range. These are for transition states.\n     *\n     * Weeks[1... weeks.length - 2] contains the actual visible data\n     */\n    var returnValue = [];\n    for (var weekIndex = 0; weekIndex < weeksGrid.length; weekIndex++) {\n      var week = [];\n      var _loop_1 = function (dayIndex) {\n        var day = weeksGrid[weekIndex][dayIndex];\n        var dayInfo = __assign(__assign({\n          onSelected: function () {\n            return onSelectDate(day.originalDate);\n          },\n          setRef: getSetRefCallback(day.key)\n        }, day), {\n          isMarked: day.isMarked || (markedDays === null || markedDays === void 0 ? void 0 : markedDays.some(function (markedDay) {\n            return compareDates(day.originalDate, markedDay);\n          }))\n        });\n        week.push(dayInfo);\n      };\n      for (var dayIndex = 0; dayIndex < DAYS_IN_WEEK; dayIndex++) {\n        _loop_1(dayIndex);\n      }\n      returnValue.push(week);\n    }\n    return returnValue;\n    // TODO: this is missing deps on getSetRefCallback and onSelectDate (and depending on the entire\n    // props object may not be a good idea due to likely frequent mutation). It would be easy to\n    // fix getSetRefCallback to not mutate every render, but onSelectDate is passed down from\n    // Calendar and trying to fix it requires a huge cascade of changes.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [props]);\n  return weeks;\n}\n/**\n * Hook to determine whether to animate the CalendarDayGrid forwards or backwards\n * @returns true if the grid should animate backwards; false otherwise\n */\nfunction useAnimateBackwards(weeks) {\n  var previousNavigatedDate = usePrevious(weeks[0][0].originalDate);\n  if (!previousNavigatedDate || previousNavigatedDate.getTime() === weeks[0][0].originalDate.getTime()) {\n    return undefined;\n  } else if (previousNavigatedDate <= weeks[0][0].originalDate) {\n    return false;\n  } else {\n    return true;\n  }\n}\nfunction useWeekCornerStyles(props) {\n  /**\n   *\n   * Section for setting the rounded corner styles on individual day cells. Individual day cells need different\n   * corners to be rounded depending on which date range type and where the cell is located in the current grid.\n   * If we just round all of the corners, there isn't a good overlap and we get gaps between contiguous day boxes\n   * in Edge browser.\n   *\n   */\n  var getWeekCornerStyles = function (classNames, initialWeeks) {\n    var weekCornersStyled = {};\n    /* need to handle setting all of the corners on arbitrarily shaped blobs\n          __\n       __|A |\n      |B |C |__\n      |D |E |F |\n           in this case, A needs top left rounded, top right rounded\n      B needs top left rounded\n      C doesn't need any rounding\n      D needs bottom left rounded\n      E doesn't need any rounding\n      F needs top right rounding\n    */\n    // cut off the animation transition weeks\n    var weeks = initialWeeks.slice(1, initialWeeks.length - 1);\n    // if there's an item above, lose both top corners. Item below, lose both bottom corners, etc.\n    weeks.forEach(function (week, weekIndex) {\n      week.forEach(function (day, dayIndex) {\n        var above = weeks[weekIndex - 1] && weeks[weekIndex - 1][dayIndex] && isInSameHoverRange(weeks[weekIndex - 1][dayIndex].originalDate, day.originalDate, weeks[weekIndex - 1][dayIndex].isSelected, day.isSelected);\n        var below = weeks[weekIndex + 1] && weeks[weekIndex + 1][dayIndex] && isInSameHoverRange(weeks[weekIndex + 1][dayIndex].originalDate, day.originalDate, weeks[weekIndex + 1][dayIndex].isSelected, day.isSelected);\n        var left = weeks[weekIndex][dayIndex - 1] && isInSameHoverRange(weeks[weekIndex][dayIndex - 1].originalDate, day.originalDate, weeks[weekIndex][dayIndex - 1].isSelected, day.isSelected);\n        var right = weeks[weekIndex][dayIndex + 1] && isInSameHoverRange(weeks[weekIndex][dayIndex + 1].originalDate, day.originalDate, weeks[weekIndex][dayIndex + 1].isSelected, day.isSelected);\n        var style = [];\n        style.push(calculateRoundedStyles(classNames, above, below, left, right));\n        style.push(calculateBorderStyles(classNames, above, below, left, right));\n        weekCornersStyled[weekIndex + '_' + dayIndex] = style.join(' ');\n      });\n    });\n    return weekCornersStyled;\n  };\n  var calculateRoundedStyles = function (classNames, above, below, left, right) {\n    var style = [];\n    var roundedTopLeft = !above && !left;\n    var roundedTopRight = !above && !right;\n    var roundedBottomLeft = !below && !left;\n    var roundedBottomRight = !below && !right;\n    if (roundedTopLeft) {\n      style.push(getRTL() ? classNames.topRightCornerDate : classNames.topLeftCornerDate);\n    }\n    if (roundedTopRight) {\n      style.push(getRTL() ? classNames.topLeftCornerDate : classNames.topRightCornerDate);\n    }\n    if (roundedBottomLeft) {\n      style.push(getRTL() ? classNames.bottomRightCornerDate : classNames.bottomLeftCornerDate);\n    }\n    if (roundedBottomRight) {\n      style.push(getRTL() ? classNames.bottomLeftCornerDate : classNames.bottomRightCornerDate);\n    }\n    return style.join(' ');\n  };\n  var calculateBorderStyles = function (classNames, above, below, left, right) {\n    var style = [];\n    if (!above) {\n      style.push(classNames.datesAbove);\n    }\n    if (!below) {\n      style.push(classNames.datesBelow);\n    }\n    if (!left) {\n      style.push(getRTL() ? classNames.datesRight : classNames.datesLeft);\n    }\n    if (!right) {\n      style.push(getRTL() ? classNames.datesLeft : classNames.datesRight);\n    }\n    return style.join(' ');\n  };\n  var isInSameHoverRange = function (date1, date2, date1Selected, date2Selected) {\n    var dateRangeType = props.dateRangeType,\n      firstDayOfWeek = props.firstDayOfWeek,\n      workWeekDays = props.workWeekDays;\n    // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n    var dateRangeHoverType = dateRangeType === DateRangeType.WorkWeek ? DateRangeType.Week : dateRangeType;\n    // we do not pass daysToSelectInDayView because we handle setting those styles dyanamically in onMouseOver\n    var dateRange = getDateRangeArray(date1, dateRangeHoverType, firstDayOfWeek, workWeekDays);\n    if (date1Selected !== date2Selected) {\n      // if one is selected and the other is not, they can't be in the same range\n      return false;\n    } else if (date1Selected && date2Selected) {\n      // if they're both selected at the same time they must be in the same range\n      return true;\n    }\n    // otherwise, both must be unselected, so check the dateRange\n    return dateRange.filter(function (date) {\n      return date.getTime() === date2.getTime();\n    }).length > 0;\n  };\n  return [getWeekCornerStyles, calculateRoundedStyles];\n}\nexport var CalendarDayGridBase = function (props) {\n  var navigatedDayRef = React.useRef(null);\n  var activeDescendantId = useId();\n  var onSelectDate = function (selectedDate) {\n    var _a, _b;\n    var firstDayOfWeek = props.firstDayOfWeek,\n      minDate = props.minDate,\n      maxDate = props.maxDate,\n      workWeekDays = props.workWeekDays,\n      daysToSelectInDayView = props.daysToSelectInDayView,\n      restrictedDates = props.restrictedDates;\n    var restrictedDatesOptions = {\n      minDate: minDate,\n      maxDate: maxDate,\n      restrictedDates: restrictedDates\n    };\n    var dateRange = getDateRangeArray(selectedDate, dateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);\n    dateRange = getBoundedDateRange(dateRange, minDate, maxDate);\n    dateRange = dateRange.filter(function (d) {\n      return !isRestrictedDate(d, restrictedDatesOptions);\n    });\n    (_a = props.onSelectDate) === null || _a === void 0 ? void 0 : _a.call(props, selectedDate, dateRange);\n    (_b = props.onNavigateDate) === null || _b === void 0 ? void 0 : _b.call(props, selectedDate, true);\n  };\n  var _a = useDayRefs(),\n    daysRef = _a[0],\n    getSetRefCallback = _a[1];\n  var weeks = useWeeks(props, onSelectDate, getSetRefCallback);\n  var animateBackwards = useAnimateBackwards(weeks);\n  var _b = useWeekCornerStyles(props),\n    getWeekCornerStyles = _b[0],\n    calculateRoundedStyles = _b[1];\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      focus: function () {\n        var _a, _b;\n        (_b = (_a = navigatedDayRef.current) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);\n      }\n    };\n  }, []);\n  /**\n   *\n   * Section for setting hover/pressed styles. Because we want arbitrary blobs of days to be selectable, to support\n   * highlighting every day in the month for month view, css :hover style isn't enough, so we need mouse callbacks\n   * to set classnames on all relevant child refs to apply the styling\n   *\n   */\n  var getDayInfosInRangeOfDay = function (dayToCompare) {\n    // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n    var dateRangeHoverType = getDateRangeTypeToUse(props.dateRangeType, props.workWeekDays);\n    // gets all the dates for the given date range type that are in the same date range as the given day\n    var dateRange = getDateRangeArray(dayToCompare.originalDate, dateRangeHoverType, props.firstDayOfWeek, props.workWeekDays, props.daysToSelectInDayView).map(function (date) {\n      return date.getTime();\n    });\n    // gets all the day refs for the given dates\n    var dayInfosInRange = weeks.reduce(function (accumulatedValue, currentWeek) {\n      return accumulatedValue.concat(currentWeek.filter(function (weekDay) {\n        return dateRange.indexOf(weekDay.originalDate.getTime()) !== -1;\n      }));\n    }, []);\n    return dayInfosInRange;\n  };\n  var getRefsFromDayInfos = function (dayInfosInRange) {\n    var dayRefs = [];\n    dayRefs = dayInfosInRange.map(function (dayInfo) {\n      return daysRef.current[dayInfo.key];\n    });\n    return dayRefs;\n  };\n  var styles = props.styles,\n    theme = props.theme,\n    className = props.className,\n    dateRangeType = props.dateRangeType,\n    showWeekNumbers = props.showWeekNumbers,\n    labelledBy = props.labelledBy,\n    lightenDaysOutsideNavigatedMonth = props.lightenDaysOutsideNavigatedMonth,\n    animationDirection = props.animationDirection;\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    className: className,\n    dateRangeType: dateRangeType,\n    showWeekNumbers: showWeekNumbers,\n    lightenDaysOutsideNavigatedMonth: lightenDaysOutsideNavigatedMonth === undefined ? true : lightenDaysOutsideNavigatedMonth,\n    animationDirection: animationDirection,\n    animateBackwards: animateBackwards\n  });\n  // When the month is highlighted get the corner dates so that styles can be added to them\n  var weekCorners = getWeekCornerStyles(classNames, weeks);\n  var partialWeekProps = {\n    weeks: weeks,\n    navigatedDayRef: navigatedDayRef,\n    calculateRoundedStyles: calculateRoundedStyles,\n    activeDescendantId: activeDescendantId,\n    classNames: classNames,\n    weekCorners: weekCorners,\n    getDayInfosInRangeOfDay: getDayInfosInRangeOfDay,\n    getRefsFromDayInfos: getRefsFromDayInfos\n  };\n  return React.createElement(FocusZone, {\n    className: classNames.wrapper,\n    preventDefaultWhenHandled: true\n  }, React.createElement(\"table\", {\n    className: classNames.table,\n    \"aria-multiselectable\": \"false\",\n    \"aria-labelledby\": labelledBy,\n    \"aria-activedescendant\": activeDescendantId,\n    role: \"grid\"\n  }, React.createElement(\"tbody\", null, React.createElement(CalendarMonthHeaderRow, __assign({}, props, {\n    classNames: classNames,\n    weeks: weeks\n  })), React.createElement(CalendarGridRow, __assign({}, props, partialWeekProps, {\n    week: weeks[0],\n    weekIndex: -1,\n    rowClassName: classNames.firstTransitionWeek,\n    ariaRole: \"presentation\",\n    ariaHidden: true\n  })), weeks.slice(1, weeks.length - 1).map(function (week, weekIndex) {\n    return React.createElement(CalendarGridRow, __assign({}, props, partialWeekProps, {\n      key: weekIndex,\n      week: week,\n      weekIndex: weekIndex,\n      rowClassName: classNames.weekRow\n    }));\n  }), React.createElement(CalendarGridRow, __assign({}, props, partialWeekProps, {\n    week: weeks[weeks.length - 1],\n    weekIndex: -2,\n    rowClassName: classNames.lastTransitionWeek,\n    ariaRole: \"presentation\",\n    ariaHidden: true\n  })))));\n};\nCalendarDayGridBase.displayName = 'CalendarDayGridBase';\n/**\n * When given work week, if the days are non-contiguous, the hover states look really weird. So for non-contiguous\n * work weeks, we'll just show week view instead.\n */\nfunction getDateRangeTypeToUse(dateRangeType, workWeekDays) {\n  if (workWeekDays && dateRangeType === DateRangeType.WorkWeek) {\n    var sortedWWDays = workWeekDays.slice().sort();\n    var isContiguous = true;\n    for (var i = 1; i < sortedWWDays.length; i++) {\n      if (sortedWWDays[i] !== sortedWWDays[i - 1] + 1) {\n        isContiguous = false;\n        break;\n      }\n    }\n    if (!isContiguous || workWeekDays.length === 0) {\n      return DateRangeType.Week;\n    }\n  }\n  return dateRangeType;\n}","map":{"version":3,"names":["React","getRTL","classNamesFunction","FocusZone","getDateRangeArray","getDayGrid","getBoundedDateRange","isRestrictedDate","DAYS_IN_WEEK","compareDates","DateRangeType","usePrevious","useId","CalendarMonthHeaderRow","CalendarGridRow","getClassNames","useDayRefs","daysRef","useRef","getSetRefCallback","dayKey","element","current","useWeeks","props","onSelectDate","weeks","useMemo","weeksGrid","firstVisibleDay","originalDate","lastVisibleDay","length","markedDays","_a","getMarkedDays","call","returnValue","weekIndex","week","dayIndex","day","dayInfo","__assign","onSelected","setRef","key","isMarked","some","markedDay","push","useAnimateBackwards","previousNavigatedDate","getTime","undefined","useWeekCornerStyles","getWeekCornerStyles","classNames","initialWeeks","weekCornersStyled","slice","forEach","above","isInSameHoverRange","isSelected","below","left","right","style","calculateRoundedStyles","calculateBorderStyles","join","roundedTopLeft","roundedTopRight","roundedBottomLeft","roundedBottomRight","topRightCornerDate","topLeftCornerDate","bottomRightCornerDate","bottomLeftCornerDate","datesAbove","datesBelow","datesRight","datesLeft","date1","date2","date1Selected","date2Selected","dateRangeType","firstDayOfWeek","workWeekDays","dateRangeHoverType","WorkWeek","Week","dateRange","filter","date","CalendarDayGridBase","navigatedDayRef","activeDescendantId","selectedDate","minDate","maxDate","daysToSelectInDayView","restrictedDates","restrictedDatesOptions","d","_b","onNavigateDate","animateBackwards","useImperativeHandle","componentRef","focus","getDayInfosInRangeOfDay","dayToCompare","getDateRangeTypeToUse","map","dayInfosInRange","reduce","accumulatedValue","currentWeek","concat","weekDay","indexOf","getRefsFromDayInfos","dayRefs","styles","theme","className","showWeekNumbers","labelledBy","lightenDaysOutsideNavigatedMonth","animationDirection","weekCorners","partialWeekProps","createElement","wrapper","preventDefaultWhenHandled","table","role","rowClassName","firstTransitionWeek","ariaRole","ariaHidden","weekRow","lastTransitionWeek","displayName","sortedWWDays","sort","isContiguous","i"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/components/src/components/CalendarDayGrid/CalendarDayGrid.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { getRTL, classNamesFunction } from '@fluentui/utilities';\nimport { FocusZone } from '../../FocusZone';\nimport {\n  getDateRangeArray,\n  getDayGrid,\n  getBoundedDateRange,\n  isRestrictedDate,\n  DAYS_IN_WEEK,\n  compareDates,\n  DateRangeType,\n  DayOfWeek,\n} from '@fluentui/date-time-utilities';\nimport { usePrevious, useId } from '@fluentui/react-hooks';\nimport { CalendarMonthHeaderRow } from './CalendarMonthHeaderRow';\nimport { CalendarGridRow } from './CalendarGridRow';\nimport type { IDay } from '@fluentui/date-time-utilities';\nimport type {\n  ICalendarDayGridProps,\n  ICalendarDayGridStyleProps,\n  ICalendarDayGridStyles,\n} from './CalendarDayGrid.types';\nimport type { IProcessedStyleSet } from '@fluentui/style-utilities';\n\nconst getClassNames = classNamesFunction<ICalendarDayGridStyleProps, ICalendarDayGridStyles>();\n\nexport interface IWeekCorners {\n  [key: string]: string;\n}\n\nexport interface IDayInfo extends IDay {\n  onSelected: () => void;\n  setRef(element: HTMLElement | null): void;\n}\n\nfunction useDayRefs() {\n  const daysRef = React.useRef<Record<string, HTMLElement>>({});\n\n  const getSetRefCallback = (dayKey: string) => (element: HTMLElement | null) => {\n    if (element === null) {\n      delete daysRef.current[dayKey];\n    } else {\n      daysRef.current[dayKey] = element;\n    }\n  };\n\n  return [daysRef, getSetRefCallback] as const;\n}\n\nfunction useWeeks(\n  props: ICalendarDayGridProps,\n  onSelectDate: (date: Date) => void,\n  getSetRefCallback: (dayKey: string) => (element: HTMLElement | null) => void,\n): IDayInfo[][] {\n  /**\n   * Initial parsing of the given props to generate IDayInfo two dimensional array, which contains a representation\n   * of every day in the grid. Convenient for helping with conversions between day refs and Date objects in callbacks.\n   */\n  const weeks = React.useMemo((): IDayInfo[][] => {\n    const weeksGrid = getDayGrid(props);\n\n    const firstVisibleDay = weeksGrid[1][0].originalDate;\n    const lastVisibleDay = weeksGrid[weeksGrid.length - 1][6].originalDate;\n    const markedDays = props.getMarkedDays?.(firstVisibleDay, lastVisibleDay) || [];\n\n    /**\n     * Weeks is a 2D array. Weeks[0] contains the last week of the prior range,\n     * Weeks[weeks.length - 1] contains first week of next range. These are for transition states.\n     *\n     * Weeks[1... weeks.length - 2] contains the actual visible data\n     */\n    const returnValue: IDayInfo[][] = [];\n\n    for (let weekIndex = 0; weekIndex < weeksGrid.length; weekIndex++) {\n      const week: IDayInfo[] = [];\n      for (let dayIndex = 0; dayIndex < DAYS_IN_WEEK; dayIndex++) {\n        const day = weeksGrid[weekIndex][dayIndex];\n        const dayInfo: IDayInfo = {\n          onSelected: () => onSelectDate(day.originalDate),\n          setRef: getSetRefCallback(day.key),\n          ...day,\n          isMarked: day.isMarked || markedDays?.some(markedDay => compareDates(day.originalDate, markedDay)),\n        };\n\n        week.push(dayInfo);\n      }\n      returnValue.push(week);\n    }\n\n    return returnValue;\n    // TODO: this is missing deps on getSetRefCallback and onSelectDate (and depending on the entire\n    // props object may not be a good idea due to likely frequent mutation). It would be easy to\n    // fix getSetRefCallback to not mutate every render, but onSelectDate is passed down from\n    // Calendar and trying to fix it requires a huge cascade of changes.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [props]);\n\n  return weeks;\n}\n\n/**\n * Hook to determine whether to animate the CalendarDayGrid forwards or backwards\n * @returns true if the grid should animate backwards; false otherwise\n */\nfunction useAnimateBackwards(weeks: IDayInfo[][]): boolean | undefined {\n  const previousNavigatedDate = usePrevious(weeks[0][0].originalDate);\n\n  if (!previousNavigatedDate || previousNavigatedDate.getTime() === weeks[0][0].originalDate.getTime()) {\n    return undefined;\n  } else if (previousNavigatedDate <= weeks[0][0].originalDate) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction useWeekCornerStyles(props: ICalendarDayGridProps) {\n  /**\n   *\n   * Section for setting the rounded corner styles on individual day cells. Individual day cells need different\n   * corners to be rounded depending on which date range type and where the cell is located in the current grid.\n   * If we just round all of the corners, there isn't a good overlap and we get gaps between contiguous day boxes\n   * in Edge browser.\n   *\n   */\n  const getWeekCornerStyles = (\n    classNames: IProcessedStyleSet<ICalendarDayGridStyles>,\n    initialWeeks: IDayInfo[][],\n  ): IWeekCorners => {\n    const weekCornersStyled: { [key: string]: string } = {};\n    /* need to handle setting all of the corners on arbitrarily shaped blobs\n          __\n       __|A |\n      |B |C |__\n      |D |E |F |\n\n      in this case, A needs top left rounded, top right rounded\n      B needs top left rounded\n      C doesn't need any rounding\n      D needs bottom left rounded\n      E doesn't need any rounding\n      F needs top right rounding\n    */\n\n    // cut off the animation transition weeks\n    const weeks = initialWeeks.slice(1, initialWeeks.length - 1);\n\n    // if there's an item above, lose both top corners. Item below, lose both bottom corners, etc.\n    weeks.forEach((week: IDayInfo[], weekIndex: number) => {\n      week.forEach((day: IDayInfo, dayIndex: number) => {\n        const above =\n          weeks[weekIndex - 1] &&\n          weeks[weekIndex - 1][dayIndex] &&\n          isInSameHoverRange(\n            weeks[weekIndex - 1][dayIndex].originalDate,\n            day.originalDate,\n            weeks[weekIndex - 1][dayIndex].isSelected,\n            day.isSelected,\n          );\n        const below =\n          weeks[weekIndex + 1] &&\n          weeks[weekIndex + 1][dayIndex] &&\n          isInSameHoverRange(\n            weeks[weekIndex + 1][dayIndex].originalDate,\n            day.originalDate,\n            weeks[weekIndex + 1][dayIndex].isSelected,\n            day.isSelected,\n          );\n        const left =\n          weeks[weekIndex][dayIndex - 1] &&\n          isInSameHoverRange(\n            weeks[weekIndex][dayIndex - 1].originalDate,\n            day.originalDate,\n            weeks[weekIndex][dayIndex - 1].isSelected,\n            day.isSelected,\n          );\n        const right =\n          weeks[weekIndex][dayIndex + 1] &&\n          isInSameHoverRange(\n            weeks[weekIndex][dayIndex + 1].originalDate,\n            day.originalDate,\n            weeks[weekIndex][dayIndex + 1].isSelected,\n            day.isSelected,\n          );\n\n        const style = [];\n        style.push(calculateRoundedStyles(classNames, above, below, left, right));\n        style.push(calculateBorderStyles(classNames, above, below, left, right));\n\n        weekCornersStyled[weekIndex + '_' + dayIndex] = style.join(' ');\n      });\n    });\n\n    return weekCornersStyled;\n  };\n\n  const calculateRoundedStyles = (\n    classNames: IProcessedStyleSet<ICalendarDayGridStyles>,\n    above: boolean,\n    below: boolean,\n    left: boolean,\n    right: boolean,\n  ): string => {\n    const style = [];\n    const roundedTopLeft = !above && !left;\n    const roundedTopRight = !above && !right;\n    const roundedBottomLeft = !below && !left;\n    const roundedBottomRight = !below && !right;\n\n    if (roundedTopLeft) {\n      style.push(getRTL() ? classNames.topRightCornerDate : classNames.topLeftCornerDate);\n    }\n    if (roundedTopRight) {\n      style.push(getRTL() ? classNames.topLeftCornerDate : classNames.topRightCornerDate);\n    }\n    if (roundedBottomLeft) {\n      style.push(getRTL() ? classNames.bottomRightCornerDate : classNames.bottomLeftCornerDate);\n    }\n    if (roundedBottomRight) {\n      style.push(getRTL() ? classNames.bottomLeftCornerDate : classNames.bottomRightCornerDate);\n    }\n\n    return style.join(' ');\n  };\n\n  const calculateBorderStyles = (\n    classNames: IProcessedStyleSet<ICalendarDayGridStyles>,\n    above: boolean,\n    below: boolean,\n    left: boolean,\n    right: boolean,\n  ): string => {\n    const style = [];\n\n    if (!above) {\n      style.push(classNames.datesAbove);\n    }\n    if (!below) {\n      style.push(classNames.datesBelow);\n    }\n    if (!left) {\n      style.push(getRTL() ? classNames.datesRight : classNames.datesLeft);\n    }\n    if (!right) {\n      style.push(getRTL() ? classNames.datesLeft : classNames.datesRight);\n    }\n\n    return style.join(' ');\n  };\n\n  const isInSameHoverRange = (date1: Date, date2: Date, date1Selected: boolean, date2Selected: boolean): boolean => {\n    const { dateRangeType, firstDayOfWeek, workWeekDays } = props;\n\n    // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n    const dateRangeHoverType = dateRangeType === DateRangeType.WorkWeek ? DateRangeType.Week : dateRangeType;\n\n    // we do not pass daysToSelectInDayView because we handle setting those styles dyanamically in onMouseOver\n    const dateRange = getDateRangeArray(date1, dateRangeHoverType, firstDayOfWeek, workWeekDays);\n\n    if (date1Selected !== date2Selected) {\n      // if one is selected and the other is not, they can't be in the same range\n      return false;\n    } else if (date1Selected && date2Selected) {\n      // if they're both selected at the same time they must be in the same range\n      return true;\n    }\n\n    // otherwise, both must be unselected, so check the dateRange\n    return dateRange.filter((date: Date) => date.getTime() === date2.getTime()).length > 0;\n  };\n\n  return [getWeekCornerStyles, calculateRoundedStyles] as const;\n}\n\nexport const CalendarDayGridBase: React.FunctionComponent<ICalendarDayGridProps> = props => {\n  const navigatedDayRef = React.useRef<HTMLTableCellElement>(null) as React.MutableRefObject<HTMLTableCellElement>;\n\n  const activeDescendantId = useId();\n\n  const onSelectDate = (selectedDate: Date): void => {\n    const { firstDayOfWeek, minDate, maxDate, workWeekDays, daysToSelectInDayView, restrictedDates } = props;\n    const restrictedDatesOptions = { minDate, maxDate, restrictedDates };\n\n    let dateRange = getDateRangeArray(selectedDate, dateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);\n    dateRange = getBoundedDateRange(dateRange, minDate, maxDate);\n\n    dateRange = dateRange.filter((d: Date) => {\n      return !isRestrictedDate(d, restrictedDatesOptions);\n    });\n\n    props.onSelectDate?.(selectedDate, dateRange);\n    props.onNavigateDate?.(selectedDate, true);\n  };\n\n  const [daysRef, getSetRefCallback] = useDayRefs();\n\n  const weeks = useWeeks(props, onSelectDate, getSetRefCallback);\n  const animateBackwards = useAnimateBackwards(weeks);\n  const [getWeekCornerStyles, calculateRoundedStyles] = useWeekCornerStyles(props);\n\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      focus() {\n        navigatedDayRef.current?.focus?.();\n      },\n    }),\n    [],\n  );\n\n  /**\n   *\n   * Section for setting hover/pressed styles. Because we want arbitrary blobs of days to be selectable, to support\n   * highlighting every day in the month for month view, css :hover style isn't enough, so we need mouse callbacks\n   * to set classnames on all relevant child refs to apply the styling\n   *\n   */\n  const getDayInfosInRangeOfDay = (dayToCompare: IDayInfo): IDayInfo[] => {\n    // The hover state looks weird with non-contiguous days in work week view. In work week, show week hover state\n    const dateRangeHoverType = getDateRangeTypeToUse(props.dateRangeType, props.workWeekDays);\n\n    // gets all the dates for the given date range type that are in the same date range as the given day\n    const dateRange = getDateRangeArray(\n      dayToCompare.originalDate,\n      dateRangeHoverType,\n      props.firstDayOfWeek,\n      props.workWeekDays,\n      props.daysToSelectInDayView,\n    ).map((date: Date) => date.getTime());\n\n    // gets all the day refs for the given dates\n    const dayInfosInRange = weeks.reduce((accumulatedValue: IDayInfo[], currentWeek: IDayInfo[]) => {\n      return accumulatedValue.concat(\n        currentWeek.filter((weekDay: IDayInfo) => dateRange.indexOf(weekDay.originalDate.getTime()) !== -1),\n      );\n    }, []);\n\n    return dayInfosInRange;\n  };\n\n  const getRefsFromDayInfos = (dayInfosInRange: IDayInfo[]): (HTMLElement | null)[] => {\n    let dayRefs: (HTMLElement | null)[] = [];\n    dayRefs = dayInfosInRange.map((dayInfo: IDayInfo) => daysRef.current[dayInfo.key]);\n\n    return dayRefs;\n  };\n\n  const {\n    styles,\n    theme,\n    className,\n    dateRangeType,\n    showWeekNumbers,\n    labelledBy,\n    lightenDaysOutsideNavigatedMonth,\n    animationDirection,\n  } = props;\n\n  const classNames = getClassNames(styles, {\n    theme: theme!,\n    className,\n    dateRangeType,\n    showWeekNumbers,\n    lightenDaysOutsideNavigatedMonth:\n      lightenDaysOutsideNavigatedMonth === undefined ? true : lightenDaysOutsideNavigatedMonth,\n    animationDirection,\n    animateBackwards,\n  });\n\n  // When the month is highlighted get the corner dates so that styles can be added to them\n  const weekCorners: IWeekCorners = getWeekCornerStyles(classNames, weeks!);\n  const partialWeekProps = {\n    weeks,\n    navigatedDayRef,\n    calculateRoundedStyles,\n    activeDescendantId,\n    classNames,\n    weekCorners,\n    getDayInfosInRangeOfDay,\n    getRefsFromDayInfos,\n  } as const;\n\n  return (\n    <FocusZone className={classNames.wrapper} preventDefaultWhenHandled={true}>\n      <table\n        className={classNames.table}\n        aria-multiselectable=\"false\"\n        aria-labelledby={labelledBy}\n        aria-activedescendant={activeDescendantId}\n        role=\"grid\"\n      >\n        <tbody>\n          <CalendarMonthHeaderRow {...props} classNames={classNames} weeks={weeks} />\n          <CalendarGridRow\n            {...props}\n            {...partialWeekProps}\n            week={weeks[0]}\n            weekIndex={-1}\n            rowClassName={classNames.firstTransitionWeek}\n            ariaRole=\"presentation\"\n            ariaHidden={true}\n          />\n          {weeks!.slice(1, weeks!.length - 1).map((week: IDayInfo[], weekIndex: number) => (\n            <CalendarGridRow\n              {...props}\n              {...partialWeekProps}\n              key={weekIndex}\n              week={week}\n              weekIndex={weekIndex}\n              rowClassName={classNames.weekRow}\n            />\n          ))}\n          <CalendarGridRow\n            {...props}\n            {...partialWeekProps}\n            week={weeks![weeks!.length - 1]}\n            weekIndex={-2}\n            rowClassName={classNames.lastTransitionWeek}\n            ariaRole=\"presentation\"\n            ariaHidden={true}\n          />\n        </tbody>\n      </table>\n    </FocusZone>\n  );\n};\nCalendarDayGridBase.displayName = 'CalendarDayGridBase';\n\n/**\n * When given work week, if the days are non-contiguous, the hover states look really weird. So for non-contiguous\n * work weeks, we'll just show week view instead.\n */\nfunction getDateRangeTypeToUse(dateRangeType: DateRangeType, workWeekDays: DayOfWeek[] | undefined): DateRangeType {\n  if (workWeekDays && dateRangeType === DateRangeType.WorkWeek) {\n    const sortedWWDays = workWeekDays.slice().sort();\n    let isContiguous = true;\n    for (let i = 1; i < sortedWWDays.length; i++) {\n      if (sortedWWDays[i] !== sortedWWDays[i - 1] + 1) {\n        isContiguous = false;\n        break;\n      }\n    }\n\n    if (!isContiguous || workWeekDays.length === 0) {\n      return DateRangeType.Week;\n    }\n  }\n\n  return dateRangeType;\n}\n"],"mappings":";AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,MAAM,EAAEC,kBAAkB,QAAQ,qBAAqB;AAChE,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SACEC,iBAAiB,EACjBC,UAAU,EACVC,mBAAmB,EACnBC,gBAAgB,EAChBC,YAAY,EACZC,YAAY,EACZC,aAAa,QAER,+BAA+B;AACtC,SAASC,WAAW,EAAEC,KAAK,QAAQ,uBAAuB;AAC1D,SAASC,sBAAsB,QAAQ,0BAA0B;AACjE,SAASC,eAAe,QAAQ,mBAAmB;AASnD,IAAMC,aAAa,GAAGb,kBAAkB,EAAsD;AAW9F,SAASc,UAAUA,CAAA;EACjB,IAAMC,OAAO,GAAGjB,KAAK,CAACkB,MAAM,CAA8B,EAAE,CAAC;EAE7D,IAAMC,iBAAiB,GAAG,SAAAA,CAACC,MAAc;IAAK,iBAACC,OAA2B;MACxE,IAAIA,OAAO,KAAK,IAAI,EAAE;QACpB,OAAOJ,OAAO,CAACK,OAAO,CAACF,MAAM,CAAC;OAC/B,MAAM;QACLH,OAAO,CAACK,OAAO,CAACF,MAAM,CAAC,GAAGC,OAAO;;IAErC,CAAC;EAN6C,CAM7C;EAED,OAAO,CAACJ,OAAO,EAAEE,iBAAiB,CAAU;AAC9C;AAEA,SAASI,QAAQA,CACfC,KAA4B,EAC5BC,YAAkC,EAClCN,iBAA4E;EAE5E;;;;EAIA,IAAMO,KAAK,GAAG1B,KAAK,CAAC2B,OAAO,CAAC;;IAC1B,IAAMC,SAAS,GAAGvB,UAAU,CAACmB,KAAK,CAAC;IAEnC,IAAMK,eAAe,GAAGD,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACE,YAAY;IACpD,IAAMC,cAAc,GAAGH,SAAS,CAACA,SAAS,CAACI,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACF,YAAY;IACtE,IAAMG,UAAU,GAAG,EAAAC,EAAA,GAAAV,KAAK,CAACW,aAAa,cAAAD,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAAZ,KAAA,EAAGK,eAAe,EAAEE,cAAc,CAAC,KAAI,EAAE;IAE/E;;;;;;IAMA,IAAMM,WAAW,GAAiB,EAAE;IAEpC,KAAK,IAAIC,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAGV,SAAS,CAACI,MAAM,EAAEM,SAAS,EAAE,EAAE;MACjE,IAAMC,IAAI,GAAe,EAAE;8BAClBC,QAAQ;QACf,IAAMC,GAAG,GAAGb,SAAS,CAACU,SAAS,CAAC,CAACE,QAAQ,CAAC;QAC1C,IAAME,OAAO,GAAAC,QAAA,CAAAA,QAAA;UACXC,UAAU,EAAE,SAAAA,CAAA;YAAM,OAAAnB,YAAY,CAACgB,GAAG,CAACX,YAAY,CAAC;UAA9B,CAA8B;UAChDe,MAAM,EAAE1B,iBAAiB,CAACsB,GAAG,CAACK,GAAG;QAAC,GAC/BL,GAAG;UACNM,QAAQ,EAAEN,GAAG,CAACM,QAAQ,KAAId,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEe,IAAI,CAAC,UAAAC,SAAS;YAAI,OAAAxC,YAAY,CAACgC,GAAG,CAACX,YAAY,EAAEmB,SAAS,CAAC;UAAzC,CAAyC,CAAC;QAAA,EACnG;QAEDV,IAAI,CAACW,IAAI,CAACR,OAAO,CAAC;;MATpB,KAAK,IAAIF,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAGhC,YAAY,EAAEgC,QAAQ,EAAE;gBAAjDA,QAAQ;;MAWjBH,WAAW,CAACa,IAAI,CAACX,IAAI,CAAC;;IAGxB,OAAOF,WAAW;IAClB;IACA;IACA;IACA;IACA;EACF,CAAC,EAAE,CAACb,KAAK,CAAC,CAAC;EAEX,OAAOE,KAAK;AACd;AAEA;;;;AAIA,SAASyB,mBAAmBA,CAACzB,KAAmB;EAC9C,IAAM0B,qBAAqB,GAAGzC,WAAW,CAACe,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACI,YAAY,CAAC;EAEnE,IAAI,CAACsB,qBAAqB,IAAIA,qBAAqB,CAACC,OAAO,EAAE,KAAK3B,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACI,YAAY,CAACuB,OAAO,EAAE,EAAE;IACpG,OAAOC,SAAS;GACjB,MAAM,IAAIF,qBAAqB,IAAI1B,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACI,YAAY,EAAE;IAC5D,OAAO,KAAK;GACb,MAAM;IACL,OAAO,IAAI;;AAEf;AAEA,SAASyB,mBAAmBA,CAAC/B,KAA4B;EACvD;;;;;;;;EAQA,IAAMgC,mBAAmB,GAAG,SAAAA,CAC1BC,UAAsD,EACtDC,YAA0B;IAE1B,IAAMC,iBAAiB,GAA8B,EAAE;IACvD;;;;;;;;;;;;IAcA;IACA,IAAMjC,KAAK,GAAGgC,YAAY,CAACE,KAAK,CAAC,CAAC,EAAEF,YAAY,CAAC1B,MAAM,GAAG,CAAC,CAAC;IAE5D;IACAN,KAAK,CAACmC,OAAO,CAAC,UAACtB,IAAgB,EAAED,SAAiB;MAChDC,IAAI,CAACsB,OAAO,CAAC,UAACpB,GAAa,EAAED,QAAgB;QAC3C,IAAMsB,KAAK,GACTpC,KAAK,CAACY,SAAS,GAAG,CAAC,CAAC,IACpBZ,KAAK,CAACY,SAAS,GAAG,CAAC,CAAC,CAACE,QAAQ,CAAC,IAC9BuB,kBAAkB,CAChBrC,KAAK,CAACY,SAAS,GAAG,CAAC,CAAC,CAACE,QAAQ,CAAC,CAACV,YAAY,EAC3CW,GAAG,CAACX,YAAY,EAChBJ,KAAK,CAACY,SAAS,GAAG,CAAC,CAAC,CAACE,QAAQ,CAAC,CAACwB,UAAU,EACzCvB,GAAG,CAACuB,UAAU,CACf;QACH,IAAMC,KAAK,GACTvC,KAAK,CAACY,SAAS,GAAG,CAAC,CAAC,IACpBZ,KAAK,CAACY,SAAS,GAAG,CAAC,CAAC,CAACE,QAAQ,CAAC,IAC9BuB,kBAAkB,CAChBrC,KAAK,CAACY,SAAS,GAAG,CAAC,CAAC,CAACE,QAAQ,CAAC,CAACV,YAAY,EAC3CW,GAAG,CAACX,YAAY,EAChBJ,KAAK,CAACY,SAAS,GAAG,CAAC,CAAC,CAACE,QAAQ,CAAC,CAACwB,UAAU,EACzCvB,GAAG,CAACuB,UAAU,CACf;QACH,IAAME,IAAI,GACRxC,KAAK,CAACY,SAAS,CAAC,CAACE,QAAQ,GAAG,CAAC,CAAC,IAC9BuB,kBAAkB,CAChBrC,KAAK,CAACY,SAAS,CAAC,CAACE,QAAQ,GAAG,CAAC,CAAC,CAACV,YAAY,EAC3CW,GAAG,CAACX,YAAY,EAChBJ,KAAK,CAACY,SAAS,CAAC,CAACE,QAAQ,GAAG,CAAC,CAAC,CAACwB,UAAU,EACzCvB,GAAG,CAACuB,UAAU,CACf;QACH,IAAMG,KAAK,GACTzC,KAAK,CAACY,SAAS,CAAC,CAACE,QAAQ,GAAG,CAAC,CAAC,IAC9BuB,kBAAkB,CAChBrC,KAAK,CAACY,SAAS,CAAC,CAACE,QAAQ,GAAG,CAAC,CAAC,CAACV,YAAY,EAC3CW,GAAG,CAACX,YAAY,EAChBJ,KAAK,CAACY,SAAS,CAAC,CAACE,QAAQ,GAAG,CAAC,CAAC,CAACwB,UAAU,EACzCvB,GAAG,CAACuB,UAAU,CACf;QAEH,IAAMI,KAAK,GAAG,EAAE;QAChBA,KAAK,CAAClB,IAAI,CAACmB,sBAAsB,CAACZ,UAAU,EAAEK,KAAK,EAAEG,KAAK,EAAEC,IAAI,EAAEC,KAAK,CAAC,CAAC;QACzEC,KAAK,CAAClB,IAAI,CAACoB,qBAAqB,CAACb,UAAU,EAAEK,KAAK,EAAEG,KAAK,EAAEC,IAAI,EAAEC,KAAK,CAAC,CAAC;QAExER,iBAAiB,CAACrB,SAAS,GAAG,GAAG,GAAGE,QAAQ,CAAC,GAAG4B,KAAK,CAACG,IAAI,CAAC,GAAG,CAAC;MACjE,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,OAAOZ,iBAAiB;EAC1B,CAAC;EAED,IAAMU,sBAAsB,GAAG,SAAAA,CAC7BZ,UAAsD,EACtDK,KAAc,EACdG,KAAc,EACdC,IAAa,EACbC,KAAc;IAEd,IAAMC,KAAK,GAAG,EAAE;IAChB,IAAMI,cAAc,GAAG,CAACV,KAAK,IAAI,CAACI,IAAI;IACtC,IAAMO,eAAe,GAAG,CAACX,KAAK,IAAI,CAACK,KAAK;IACxC,IAAMO,iBAAiB,GAAG,CAACT,KAAK,IAAI,CAACC,IAAI;IACzC,IAAMS,kBAAkB,GAAG,CAACV,KAAK,IAAI,CAACE,KAAK;IAE3C,IAAIK,cAAc,EAAE;MAClBJ,KAAK,CAAClB,IAAI,CAACjD,MAAM,EAAE,GAAGwD,UAAU,CAACmB,kBAAkB,GAAGnB,UAAU,CAACoB,iBAAiB,CAAC;;IAErF,IAAIJ,eAAe,EAAE;MACnBL,KAAK,CAAClB,IAAI,CAACjD,MAAM,EAAE,GAAGwD,UAAU,CAACoB,iBAAiB,GAAGpB,UAAU,CAACmB,kBAAkB,CAAC;;IAErF,IAAIF,iBAAiB,EAAE;MACrBN,KAAK,CAAClB,IAAI,CAACjD,MAAM,EAAE,GAAGwD,UAAU,CAACqB,qBAAqB,GAAGrB,UAAU,CAACsB,oBAAoB,CAAC;;IAE3F,IAAIJ,kBAAkB,EAAE;MACtBP,KAAK,CAAClB,IAAI,CAACjD,MAAM,EAAE,GAAGwD,UAAU,CAACsB,oBAAoB,GAAGtB,UAAU,CAACqB,qBAAqB,CAAC;;IAG3F,OAAOV,KAAK,CAACG,IAAI,CAAC,GAAG,CAAC;EACxB,CAAC;EAED,IAAMD,qBAAqB,GAAG,SAAAA,CAC5Bb,UAAsD,EACtDK,KAAc,EACdG,KAAc,EACdC,IAAa,EACbC,KAAc;IAEd,IAAMC,KAAK,GAAG,EAAE;IAEhB,IAAI,CAACN,KAAK,EAAE;MACVM,KAAK,CAAClB,IAAI,CAACO,UAAU,CAACuB,UAAU,CAAC;;IAEnC,IAAI,CAACf,KAAK,EAAE;MACVG,KAAK,CAAClB,IAAI,CAACO,UAAU,CAACwB,UAAU,CAAC;;IAEnC,IAAI,CAACf,IAAI,EAAE;MACTE,KAAK,CAAClB,IAAI,CAACjD,MAAM,EAAE,GAAGwD,UAAU,CAACyB,UAAU,GAAGzB,UAAU,CAAC0B,SAAS,CAAC;;IAErE,IAAI,CAAChB,KAAK,EAAE;MACVC,KAAK,CAAClB,IAAI,CAACjD,MAAM,EAAE,GAAGwD,UAAU,CAAC0B,SAAS,GAAG1B,UAAU,CAACyB,UAAU,CAAC;;IAGrE,OAAOd,KAAK,CAACG,IAAI,CAAC,GAAG,CAAC;EACxB,CAAC;EAED,IAAMR,kBAAkB,GAAG,SAAAA,CAACqB,KAAW,EAAEC,KAAW,EAAEC,aAAsB,EAAEC,aAAsB;IAC1F,IAAAC,aAAa,GAAmChE,KAAK,CAAAgE,aAAxC;MAAEC,cAAc,GAAmBjE,KAAK,CAAAiE,cAAxB;MAAEC,YAAY,GAAKlE,KAAK,CAAAkE,YAAV;IAEnD;IACA,IAAMC,kBAAkB,GAAGH,aAAa,KAAK9E,aAAa,CAACkF,QAAQ,GAAGlF,aAAa,CAACmF,IAAI,GAAGL,aAAa;IAExG;IACA,IAAMM,SAAS,GAAG1F,iBAAiB,CAACgF,KAAK,EAAEO,kBAAkB,EAAEF,cAAc,EAAEC,YAAY,CAAC;IAE5F,IAAIJ,aAAa,KAAKC,aAAa,EAAE;MACnC;MACA,OAAO,KAAK;KACb,MAAM,IAAID,aAAa,IAAIC,aAAa,EAAE;MACzC;MACA,OAAO,IAAI;;IAGb;IACA,OAAOO,SAAS,CAACC,MAAM,CAAC,UAACC,IAAU;MAAK,OAAAA,IAAI,CAAC3C,OAAO,EAAE,KAAKgC,KAAK,CAAChC,OAAO,EAAE;IAAlC,CAAkC,CAAC,CAACrB,MAAM,GAAG,CAAC;EACxF,CAAC;EAED,OAAO,CAACwB,mBAAmB,EAAEa,sBAAsB,CAAU;AAC/D;AAEA,OAAO,IAAM4B,mBAAmB,GAAmD,SAAAA,CAAAzE,KAAK;EACtF,IAAM0E,eAAe,GAAGlG,KAAK,CAACkB,MAAM,CAAuB,IAAI,CAAiD;EAEhH,IAAMiF,kBAAkB,GAAGvF,KAAK,EAAE;EAElC,IAAMa,YAAY,GAAG,SAAAA,CAAC2E,YAAkB;;IAC9B,IAAAX,cAAc,GAA6EjE,KAAK,CAAAiE,cAAlF;MAAEY,OAAO,GAAoE7E,KAAK,CAAA6E,OAAzE;MAAEC,OAAO,GAA2D9E,KAAK,CAAA8E,OAAhE;MAAEZ,YAAY,GAA6ClE,KAAK,CAAAkE,YAAlD;MAAEa,qBAAqB,GAAsB/E,KAAK,CAAA+E,qBAA3B;MAAEC,eAAe,GAAKhF,KAAK,CAAAgF,eAAV;IAC9F,IAAMC,sBAAsB,GAAG;MAAEJ,OAAO,EAAAA,OAAA;MAAEC,OAAO,EAAAA,OAAA;MAAEE,eAAe,EAAAA;IAAA,CAAE;IAEpE,IAAIV,SAAS,GAAG1F,iBAAiB,CAACgG,YAAY,EAAEZ,aAAa,EAAEC,cAAc,EAAEC,YAAY,EAAEa,qBAAqB,CAAC;IACnHT,SAAS,GAAGxF,mBAAmB,CAACwF,SAAS,EAAEO,OAAO,EAAEC,OAAO,CAAC;IAE5DR,SAAS,GAAGA,SAAS,CAACC,MAAM,CAAC,UAACW,CAAO;MACnC,OAAO,CAACnG,gBAAgB,CAACmG,CAAC,EAAED,sBAAsB,CAAC;IACrD,CAAC,CAAC;IAEF,CAAAvE,EAAA,GAAAV,KAAK,CAACC,YAAY,cAAAS,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAAZ,KAAA,EAAG4E,YAAY,EAAEN,SAAS,CAAC;IAC7C,CAAAa,EAAA,GAAAnF,KAAK,CAACoF,cAAc,cAAAD,EAAA,uBAAAA,EAAA,CAAAvE,IAAA,CAAAZ,KAAA,EAAG4E,YAAY,EAAE,IAAI,CAAC;EAC5C,CAAC;EAEK,IAAAlE,EAAA,GAA+BlB,UAAU,EAAE;IAA1CC,OAAO,GAAAiB,EAAA;IAAEf,iBAAiB,GAAAe,EAAA,GAAgB;EAEjD,IAAMR,KAAK,GAAGH,QAAQ,CAACC,KAAK,EAAEC,YAAY,EAAEN,iBAAiB,CAAC;EAC9D,IAAM0F,gBAAgB,GAAG1D,mBAAmB,CAACzB,KAAK,CAAC;EAC7C,IAAAiF,EAAA,GAAgDpD,mBAAmB,CAAC/B,KAAK,CAAC;IAAzEgC,mBAAmB,GAAAmD,EAAA;IAAEtC,sBAAsB,GAAAsC,EAAA,GAA8B;EAEhF3G,KAAK,CAAC8G,mBAAmB,CACvBtF,KAAK,CAACuF,YAAY,EAClB;IAAM,OAAC;MACLC,KAAK,WAAAA,CAAA;;QACH,CAAAL,EAAA,IAAAzE,EAAA,GAAAgE,eAAe,CAAC5E,OAAO,cAAAY,EAAA,uBAAAA,EAAA,CAAE8E,KAAK,cAAAL,EAAA,uBAAAA,EAAA,CAAAvE,IAAA,CAAAF,EAAA,CAAI;MACpC;KACD;EAJK,CAIJ,EACF,EAAE,CACH;EAED;;;;;;;EAOA,IAAM+E,uBAAuB,GAAG,SAAAA,CAACC,YAAsB;IACrD;IACA,IAAMvB,kBAAkB,GAAGwB,qBAAqB,CAAC3F,KAAK,CAACgE,aAAa,EAAEhE,KAAK,CAACkE,YAAY,CAAC;IAEzF;IACA,IAAMI,SAAS,GAAG1F,iBAAiB,CACjC8G,YAAY,CAACpF,YAAY,EACzB6D,kBAAkB,EAClBnE,KAAK,CAACiE,cAAc,EACpBjE,KAAK,CAACkE,YAAY,EAClBlE,KAAK,CAAC+E,qBAAqB,CAC5B,CAACa,GAAG,CAAC,UAACpB,IAAU;MAAK,OAAAA,IAAI,CAAC3C,OAAO,EAAE;IAAd,CAAc,CAAC;IAErC;IACA,IAAMgE,eAAe,GAAG3F,KAAK,CAAC4F,MAAM,CAAC,UAACC,gBAA4B,EAAEC,WAAuB;MACzF,OAAOD,gBAAgB,CAACE,MAAM,CAC5BD,WAAW,CAACzB,MAAM,CAAC,UAAC2B,OAAiB;QAAK,OAAA5B,SAAS,CAAC6B,OAAO,CAACD,OAAO,CAAC5F,YAAY,CAACuB,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC;MAAxD,CAAwD,CAAC,CACpG;IACH,CAAC,EAAE,EAAE,CAAC;IAEN,OAAOgE,eAAe;EACxB,CAAC;EAED,IAAMO,mBAAmB,GAAG,SAAAA,CAACP,eAA2B;IACtD,IAAIQ,OAAO,GAA2B,EAAE;IACxCA,OAAO,GAAGR,eAAe,CAACD,GAAG,CAAC,UAAC1E,OAAiB;MAAK,OAAAzB,OAAO,CAACK,OAAO,CAACoB,OAAO,CAACI,GAAG,CAAC;IAA5B,CAA4B,CAAC;IAElF,OAAO+E,OAAO;EAChB,CAAC;EAGC,IAAAC,MAAM,GAQJtG,KAAK,CAAAsG,MARD;IACNC,KAAK,GAOHvG,KAAK,CAAAuG,KAPF;IACLC,SAAS,GAMPxG,KAAK,CAAAwG,SANE;IACTxC,aAAa,GAKXhE,KAAK,CAAAgE,aALM;IACbyC,eAAe,GAIbzG,KAAK,CAAAyG,eAJQ;IACfC,UAAU,GAGR1G,KAAK,CAAA0G,UAHG;IACVC,gCAAgC,GAE9B3G,KAAK,CAAA2G,gCAFyB;IAChCC,kBAAkB,GAChB5G,KAAK,CAAA4G,kBADW;EAGpB,IAAM3E,UAAU,GAAG1C,aAAa,CAAC+G,MAAM,EAAE;IACvCC,KAAK,EAAEA,KAAM;IACbC,SAAS,EAAAA,SAAA;IACTxC,aAAa,EAAAA,aAAA;IACbyC,eAAe,EAAAA,eAAA;IACfE,gCAAgC,EAC9BA,gCAAgC,KAAK7E,SAAS,GAAG,IAAI,GAAG6E,gCAAgC;IAC1FC,kBAAkB,EAAAA,kBAAA;IAClBvB,gBAAgB,EAAAA;GACjB,CAAC;EAEF;EACA,IAAMwB,WAAW,GAAiB7E,mBAAmB,CAACC,UAAU,EAAE/B,KAAM,CAAC;EACzE,IAAM4G,gBAAgB,GAAG;IACvB5G,KAAK,EAAAA,KAAA;IACLwE,eAAe,EAAAA,eAAA;IACf7B,sBAAsB,EAAAA,sBAAA;IACtB8B,kBAAkB,EAAAA,kBAAA;IAClB1C,UAAU,EAAAA,UAAA;IACV4E,WAAW,EAAAA,WAAA;IACXpB,uBAAuB,EAAAA,uBAAA;IACvBW,mBAAmB,EAAAA;GACX;EAEV,OACE5H,KAAA,CAAAuI,aAAA,CAACpI,SAAS;IAAC6H,SAAS,EAAEvE,UAAU,CAAC+E,OAAO;IAAEC,yBAAyB,EAAE;EAAI,GACvEzI,KAAA,CAAAuI,aAAA;IACEP,SAAS,EAAEvE,UAAU,CAACiF,KAAK;IAAA,wBACN,OAAO;IAAA,mBACXR,UAAU;IAAA,yBACJ/B,kBAAkB;IACzCwC,IAAI,EAAC;EAAM,GAEX3I,KAAA,CAAAuI,aAAA,gBACEvI,KAAA,CAAAuI,aAAA,CAAC1H,sBAAsB,EAAA8B,QAAA,KAAKnB,KAAK;IAAEiC,UAAU,EAAEA,UAAU;IAAE/B,KAAK,EAAEA;EAAK,GAAI,EAC3E1B,KAAA,CAAAuI,aAAA,CAACzH,eAAe,EAAA6B,QAAA,KACVnB,KAAK,EACL8G,gBAAgB;IACpB/F,IAAI,EAAEb,KAAK,CAAC,CAAC,CAAC;IACdY,SAAS,EAAE,CAAC,CAAC;IACbsG,YAAY,EAAEnF,UAAU,CAACoF,mBAAmB;IAC5CC,QAAQ,EAAC,cAAc;IACvBC,UAAU,EAAE;EAAI,GAChB,EACDrH,KAAM,CAACkC,KAAK,CAAC,CAAC,EAAElC,KAAM,CAACM,MAAM,GAAG,CAAC,CAAC,CAACoF,GAAG,CAAC,UAAC7E,IAAgB,EAAED,SAAiB;IAAK,OAC/EtC,KAAA,CAAAuI,aAAA,CAACzH,eAAe,EAAA6B,QAAA,KACVnB,KAAK,EACL8G,gBAAgB;MACpBxF,GAAG,EAAER,SAAS;MACdC,IAAI,EAAEA,IAAI;MACVD,SAAS,EAAEA,SAAS;MACpBsG,YAAY,EAAEnF,UAAU,CAACuF;IAAO,GAChC;EAR6E,CAShF,CAAC,EACFhJ,KAAA,CAAAuI,aAAA,CAACzH,eAAe,EAAA6B,QAAA,KACVnB,KAAK,EACL8G,gBAAgB;IACpB/F,IAAI,EAAEb,KAAM,CAACA,KAAM,CAACM,MAAM,GAAG,CAAC,CAAC;IAC/BM,SAAS,EAAE,CAAC,CAAC;IACbsG,YAAY,EAAEnF,UAAU,CAACwF,kBAAkB;IAC3CH,QAAQ,EAAC,cAAc;IACvBC,UAAU,EAAE;EAAI,GAChB,CACI,CACF,CACE;AAEhB,CAAC;AACD9C,mBAAmB,CAACiD,WAAW,GAAG,qBAAqB;AAEvD;;;;AAIA,SAAS/B,qBAAqBA,CAAC3B,aAA4B,EAAEE,YAAqC;EAChG,IAAIA,YAAY,IAAIF,aAAa,KAAK9E,aAAa,CAACkF,QAAQ,EAAE;IAC5D,IAAMuD,YAAY,GAAGzD,YAAY,CAAC9B,KAAK,EAAE,CAACwF,IAAI,EAAE;IAChD,IAAIC,YAAY,GAAG,IAAI;IACvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,YAAY,CAACnH,MAAM,EAAEsH,CAAC,EAAE,EAAE;MAC5C,IAAIH,YAAY,CAACG,CAAC,CAAC,KAAKH,YAAY,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE;QAC/CD,YAAY,GAAG,KAAK;QACpB;;;IAIJ,IAAI,CAACA,YAAY,IAAI3D,YAAY,CAAC1D,MAAM,KAAK,CAAC,EAAE;MAC9C,OAAOtB,aAAa,CAACmF,IAAI;;;EAI7B,OAAOL,aAAa;AACtB"},"metadata":{},"sourceType":"module","externalDependencies":[]}