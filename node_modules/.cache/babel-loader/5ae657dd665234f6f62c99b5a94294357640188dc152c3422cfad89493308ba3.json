{"ast":null,"code":"import { SELECTION_CHANGE, SelectionMode, SELECTION_ITEMS_CHANGE } from './Selection.types';\nimport { EventGroup } from '../EventGroup';\n/**\n * {@docCategory Selection}\n */\nvar Selection = /** @class */function () {\n  /**\n   * Create a new Selection. If `TItem` does not have a `key` property, you must provide an options\n   * object with a `getKey` implementation. Providing options is optional otherwise.\n   * (At most one `options` object is accepted.)\n   */\n  function Selection() {\n    var options = []; // Otherwise, arguments require options with `getKey`.\n    for (var _i = 0 // Otherwise, arguments require options with `getKey`.\n    ; _i < arguments.length // Otherwise, arguments require options with `getKey`.\n    ; _i++ // Otherwise, arguments require options with `getKey`.\n    ) {\n      options[_i] = arguments[_i]; // Otherwise, arguments require options with `getKey`.\n    }\n\n    var _a = options[0] || {},\n      onSelectionChanged = _a.onSelectionChanged,\n      onItemsChanged = _a.onItemsChanged,\n      getKey = _a.getKey,\n      _b = _a.canSelectItem,\n      canSelectItem = _b === void 0 ? function () {\n        return true;\n      } : _b,\n      items = _a.items,\n      _c = _a.selectionMode,\n      selectionMode = _c === void 0 ? SelectionMode.multiple : _c;\n    this.mode = selectionMode;\n    this._getKey = getKey || defaultGetKey;\n    this._changeEventSuppressionCount = 0;\n    this._exemptedCount = 0;\n    this._anchoredIndex = 0;\n    this._unselectableCount = 0;\n    this._onSelectionChanged = onSelectionChanged;\n    this._onItemsChanged = onItemsChanged;\n    this._canSelectItem = canSelectItem;\n    this._keyToIndexMap = {};\n    this._isModal = false;\n    this.setItems(items || [], true);\n    this.count = this.getSelectedCount();\n  }\n  Selection.prototype.canSelectItem = function (item, index) {\n    if (typeof index === 'number' && index < 0) {\n      return false;\n    }\n    return this._canSelectItem(item, index);\n  };\n  Selection.prototype.getKey = function (item, index) {\n    var key = this._getKey(item, index);\n    return typeof key === 'number' || key ? \"\".concat(key) : '';\n  };\n  Selection.prototype.setChangeEvents = function (isEnabled, suppressChange) {\n    this._changeEventSuppressionCount += isEnabled ? -1 : 1;\n    if (this._changeEventSuppressionCount === 0 && this._hasChanged) {\n      this._hasChanged = false;\n      if (!suppressChange) {\n        this._change();\n      }\n    }\n  };\n  Selection.prototype.isModal = function () {\n    return this._isModal;\n  };\n  Selection.prototype.setModal = function (isModal) {\n    if (this._isModal !== isModal) {\n      this.setChangeEvents(false);\n      this._isModal = isModal;\n      if (!isModal) {\n        this.setAllSelected(false);\n      }\n      this._change();\n      this.setChangeEvents(true);\n    }\n  };\n  /**\n   * Selection needs the items, call this method to set them. If the set\n   * of items is the same, this will re-evaluate selection and index maps.\n   * Otherwise, shouldClear should be set to true, so that selection is\n   * cleared.\n   */\n  Selection.prototype.setItems = function (items, shouldClear) {\n    if (shouldClear === void 0) {\n      shouldClear = true;\n    }\n    var newKeyToIndexMap = {};\n    var newUnselectableIndices = {};\n    var hasSelectionChanged = false;\n    this.setChangeEvents(false);\n    // Reset the unselectable count.\n    this._unselectableCount = 0;\n    var haveItemsChanged = false;\n    // Build lookup table for quick selection evaluation.\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n      if (item) {\n        var key = this.getKey(item, i);\n        if (key) {\n          if (!haveItemsChanged && (!(key in this._keyToIndexMap) || this._keyToIndexMap[key] !== i)) {\n            haveItemsChanged = true;\n          }\n          newKeyToIndexMap[key] = i;\n        }\n      }\n      newUnselectableIndices[i] = item && !this.canSelectItem(item);\n      if (newUnselectableIndices[i]) {\n        this._unselectableCount++;\n      }\n    }\n    if (shouldClear || items.length === 0) {\n      this._setAllSelected(false, true);\n    }\n    // Check the exemption list for discrepencies.\n    var newExemptedIndicies = {};\n    var newExemptedCount = 0;\n    for (var indexProperty in this._exemptedIndices) {\n      if (this._exemptedIndices.hasOwnProperty(indexProperty)) {\n        var index = Number(indexProperty);\n        var item = this._items[index];\n        var exemptKey = item ? this.getKey(item, Number(index)) : undefined;\n        var newIndex = exemptKey ? newKeyToIndexMap[exemptKey] : index;\n        if (newIndex === undefined) {\n          // The item has likely been replaced or removed.\n          hasSelectionChanged = true;\n        } else {\n          // We know the new index of the item. update the existing exemption table.\n          newExemptedIndicies[newIndex] = true;\n          newExemptedCount++;\n          hasSelectionChanged = hasSelectionChanged || newIndex !== index;\n        }\n      }\n    }\n    if (this._items && this._exemptedCount === 0 && items.length !== this._items.length && this._isAllSelected) {\n      // If everything was selected but the number of items has changed, selection has changed.\n      hasSelectionChanged = true;\n    }\n    if (!haveItemsChanged) {\n      for (var _i = 0, _a = Object.keys(this._keyToIndexMap); _i < _a.length; _i++) {\n        var key = _a[_i];\n        if (!(key in newKeyToIndexMap)) {\n          haveItemsChanged = true;\n          break;\n        }\n      }\n    }\n    this._exemptedIndices = newExemptedIndicies;\n    this._exemptedCount = newExemptedCount;\n    this._keyToIndexMap = newKeyToIndexMap;\n    this._unselectableIndices = newUnselectableIndices;\n    this._items = items;\n    this._selectedItems = null;\n    if (hasSelectionChanged) {\n      this._updateCount();\n    }\n    if (haveItemsChanged) {\n      EventGroup.raise(this, SELECTION_ITEMS_CHANGE);\n      if (this._onItemsChanged) {\n        this._onItemsChanged();\n      }\n    }\n    if (hasSelectionChanged) {\n      this._change();\n    }\n    this.setChangeEvents(true);\n  };\n  Selection.prototype.getItems = function () {\n    return this._items;\n  };\n  Selection.prototype.getSelection = function () {\n    if (!this._selectedItems) {\n      this._selectedItems = [];\n      var items = this._items;\n      if (items) {\n        for (var i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedItems.push(items[i]);\n          }\n        }\n      }\n    }\n    return this._selectedItems;\n  };\n  Selection.prototype.getSelectedCount = function () {\n    return this._isAllSelected ? this._items.length - this._exemptedCount - this._unselectableCount : this._exemptedCount;\n  };\n  Selection.prototype.getSelectedIndices = function () {\n    if (!this._selectedIndices) {\n      this._selectedIndices = [];\n      var items = this._items;\n      if (items) {\n        for (var i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedIndices.push(i);\n          }\n        }\n      }\n    }\n    return this._selectedIndices;\n  };\n  Selection.prototype.getItemIndex = function (key) {\n    var index = this._keyToIndexMap[key];\n    return index !== null && index !== void 0 ? index : -1;\n  };\n  Selection.prototype.isRangeSelected = function (fromIndex, count) {\n    if (count === 0) {\n      return false;\n    }\n    var endIndex = fromIndex + count;\n    for (var i = fromIndex; i < endIndex; i++) {\n      if (!this.isIndexSelected(i)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  Selection.prototype.isAllSelected = function () {\n    var selectableCount = this._items.length - this._unselectableCount;\n    // In single mode, we can only have a max of 1 item.\n    if (this.mode === SelectionMode.single) {\n      selectableCount = Math.min(selectableCount, 1);\n    }\n    return this.count > 0 && this._isAllSelected && this._exemptedCount === 0 || !this._isAllSelected && this._exemptedCount === selectableCount && selectableCount > 0;\n  };\n  Selection.prototype.isKeySelected = function (key) {\n    var index = this._keyToIndexMap[key];\n    return this.isIndexSelected(index);\n  };\n  Selection.prototype.isIndexSelected = function (index) {\n    return !!(this.count > 0 && this._isAllSelected && !this._exemptedIndices[index] && !this._unselectableIndices[index] || !this._isAllSelected && this._exemptedIndices[index]);\n  };\n  Selection.prototype.setAllSelected = function (isAllSelected) {\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n    var selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n    this.setChangeEvents(false);\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n        this._change();\n      }\n      this._updateCount();\n    }\n    this.setChangeEvents(true);\n  };\n  Selection.prototype.setKeySelected = function (key, isSelected, shouldAnchor) {\n    var index = this._keyToIndexMap[key];\n    if (index >= 0) {\n      this.setIndexSelected(index, isSelected, shouldAnchor);\n    }\n  };\n  Selection.prototype.setIndexSelected = function (index, isSelected, shouldAnchor) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n    // Clamp the index.\n    index = Math.min(Math.max(0, index), this._items.length - 1);\n    // No-op on out of bounds selections.\n    if (index < 0 || index >= this._items.length) {\n      return;\n    }\n    this.setChangeEvents(false);\n    var isExempt = this._exemptedIndices[index];\n    var canSelect = !this._unselectableIndices[index];\n    if (canSelect) {\n      if (isSelected && this.mode === SelectionMode.single) {\n        // If this is single-select, the previous selection should be removed.\n        this._setAllSelected(false, true);\n      }\n      // Determine if we need to remove the exemption.\n      if (isExempt && (isSelected && this._isAllSelected || !isSelected && !this._isAllSelected)) {\n        delete this._exemptedIndices[index];\n        this._exemptedCount--;\n      }\n      // Determine if we need to add the exemption.\n      if (!isExempt && (isSelected && !this._isAllSelected || !isSelected && this._isAllSelected)) {\n        this._exemptedIndices[index] = true;\n        this._exemptedCount++;\n      }\n      if (shouldAnchor) {\n        this._anchoredIndex = index;\n      }\n    }\n    this._updateCount();\n    this.setChangeEvents(true);\n  };\n  Selection.prototype.setRangeSelected = function (fromIndex, count, isSelected, shouldAnchor) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n    // Clamp the index.\n    fromIndex = Math.min(Math.max(0, fromIndex), this._items.length - 1);\n    // Clamp the range.\n    count = Math.min(Math.max(0, count), this._items.length - fromIndex);\n    // No-op on out of bounds selections.\n    if (fromIndex < 0 || fromIndex >= this._items.length || count === 0) {\n      return;\n    }\n    this.setChangeEvents(false);\n    var anchorIndex = this._anchoredIndex || 0;\n    var startIndex = fromIndex;\n    var endIndex = fromIndex + count - 1;\n    var newAnchorIndex = anchorIndex >= endIndex ? startIndex : endIndex;\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, isSelected, shouldAnchor ? startIndex === newAnchorIndex : false);\n    }\n    this.setChangeEvents(true);\n  };\n  Selection.prototype.selectToKey = function (key, clearSelection) {\n    this.selectToIndex(this._keyToIndexMap[key], clearSelection);\n  };\n  Selection.prototype.selectToRange = function (fromIndex, count, clearSelection) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n    if (this.mode === SelectionMode.single) {\n      if (count === 1) {\n        this.setIndexSelected(fromIndex, true, true);\n      }\n      return;\n    }\n    var anchorIndex = this._anchoredIndex || 0;\n    var startIndex = Math.min(fromIndex, anchorIndex);\n    var endIndex = Math.max(fromIndex + count - 1, anchorIndex);\n    this.setChangeEvents(false);\n    if (clearSelection) {\n      this._setAllSelected(false, true);\n    }\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, true, false);\n    }\n    this.setChangeEvents(true);\n  };\n  Selection.prototype.selectToIndex = function (index, clearSelection) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n    if (this.mode === SelectionMode.single) {\n      this.setIndexSelected(index, true, true);\n      return;\n    }\n    var anchorIndex = this._anchoredIndex || 0;\n    var startIndex = Math.min(index, anchorIndex);\n    var endIndex = Math.max(index, anchorIndex);\n    this.setChangeEvents(false);\n    if (clearSelection) {\n      this._setAllSelected(false, true);\n    }\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, true, false);\n    }\n    this.setChangeEvents(true);\n  };\n  Selection.prototype.toggleAllSelected = function () {\n    this.setAllSelected(!this.isAllSelected());\n  };\n  Selection.prototype.toggleKeySelected = function (key) {\n    this.setKeySelected(key, !this.isKeySelected(key), true);\n  };\n  Selection.prototype.toggleIndexSelected = function (index) {\n    this.setIndexSelected(index, !this.isIndexSelected(index), true);\n  };\n  Selection.prototype.toggleRangeSelected = function (fromIndex, count) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n    var isRangeSelected = this.isRangeSelected(fromIndex, count);\n    var endIndex = fromIndex + count;\n    if (this.mode === SelectionMode.single && count > 1) {\n      return;\n    }\n    this.setChangeEvents(false);\n    for (var i = fromIndex; i < endIndex; i++) {\n      this.setIndexSelected(i, !isRangeSelected, false);\n    }\n    this.setChangeEvents(true);\n  };\n  Selection.prototype._updateCount = function (preserveModalState) {\n    if (preserveModalState === void 0) {\n      preserveModalState = false;\n    }\n    var count = this.getSelectedCount();\n    if (count !== this.count) {\n      this.count = count;\n      this._change();\n    }\n    if (!this.count && !preserveModalState) {\n      this.setModal(false);\n    }\n  };\n  Selection.prototype._setAllSelected = function (isAllSelected, preserveModalState) {\n    if (preserveModalState === void 0) {\n      preserveModalState = false;\n    }\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n    var selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n    this.setChangeEvents(false);\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n        this._change();\n      }\n      this._updateCount(preserveModalState);\n    }\n    this.setChangeEvents(true);\n  };\n  Selection.prototype._change = function () {\n    if (this._changeEventSuppressionCount === 0) {\n      this._selectedItems = null;\n      this._selectedIndices = undefined;\n      EventGroup.raise(this, SELECTION_CHANGE);\n      if (this._onSelectionChanged) {\n        this._onSelectionChanged();\n      }\n    } else {\n      this._hasChanged = true;\n    }\n  };\n  return Selection;\n}();\nexport { Selection };\nfunction defaultGetKey(item, index) {\n  // 0 may be used as a key\n  var _a = (item || {}).key,\n    key = _a === void 0 ? \"\".concat(index) : _a;\n  return key;\n}","map":{"version":3,"names":["SELECTION_CHANGE","SelectionMode","SELECTION_ITEMS_CHANGE","EventGroup","Selection","options","_i","arguments","length","_a","onSelectionChanged","onItemsChanged","getKey","_b","canSelectItem","items","_c","selectionMode","multiple","mode","_getKey","defaultGetKey","_changeEventSuppressionCount","_exemptedCount","_anchoredIndex","_unselectableCount","_onSelectionChanged","_onItemsChanged","_canSelectItem","_keyToIndexMap","_isModal","setItems","count","getSelectedCount","prototype","item","index","key","concat","setChangeEvents","isEnabled","suppressChange","_hasChanged","_change","isModal","setModal","setAllSelected","shouldClear","newKeyToIndexMap","newUnselectableIndices","hasSelectionChanged","haveItemsChanged","i","_setAllSelected","newExemptedIndicies","newExemptedCount","indexProperty","_exemptedIndices","hasOwnProperty","Number","_items","exemptKey","undefined","newIndex","_isAllSelected","Object","keys","_unselectableIndices","_selectedItems","_updateCount","raise","getItems","getSelection","isIndexSelected","push","getSelectedIndices","_selectedIndices","getItemIndex","isRangeSelected","fromIndex","endIndex","isAllSelected","selectableCount","single","Math","min","isKeySelected","setKeySelected","isSelected","shouldAnchor","setIndexSelected","none","max","isExempt","canSelect","setRangeSelected","anchorIndex","startIndex","newAnchorIndex","selectToKey","clearSelection","selectToIndex","selectToRange","toggleAllSelected","toggleKeySelected","toggleIndexSelected","toggleRangeSelected","preserveModalState"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/utilities/lib/src/selection/Selection.ts"],"sourcesContent":["import { SELECTION_CHANGE, SelectionMode, SELECTION_ITEMS_CHANGE } from './Selection.types';\nimport { EventGroup } from '../EventGroup';\nimport type { IObjectWithKey, ISelection } from './Selection.types';\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionOptions<TItem = IObjectWithKey> {\n  onSelectionChanged?: () => void;\n  onItemsChanged?: () => void;\n  /** Custom logic to generate item keys. Required if `TItem` does not have a `key` property. */\n  getKey?: (item: TItem, index?: number) => string | number;\n  canSelectItem?: (item: TItem, index?: number) => boolean;\n  selectionMode?: SelectionMode;\n  items?: TItem[];\n}\n\n/**\n * Selection options with required `getKey` property.\n * {@docCategory Selection}\n */\nexport type ISelectionOptionsWithRequiredGetKey<TItem> = ISelectionOptions<TItem> &\n  Required<Pick<ISelectionOptions<TItem>, 'getKey'>>;\n\n/**\n * {@docCategory Selection}\n */\nexport class Selection<TItem = IObjectWithKey> implements ISelection<TItem> {\n  /** Number of items selected. Do not modify. */\n  public count!: number;\n  public readonly mode!: SelectionMode;\n\n  private _getKey!: (item: TItem, index?: number) => string | number;\n  private _canSelectItem!: (item: TItem, index?: number) => boolean;\n\n  private _changeEventSuppressionCount: number;\n  private _items!: TItem[];\n  private _selectedItems!: TItem[] | null;\n  private _selectedIndices: number[] | undefined;\n  private _isAllSelected!: boolean;\n  private _exemptedIndices!: { [index: string]: boolean };\n  private _exemptedCount: number;\n  private _keyToIndexMap!: { [key: string]: number };\n  private _anchoredIndex: number;\n  private _onSelectionChanged: (() => void) | undefined;\n  private _onItemsChanged: (() => void) | undefined;\n  private _hasChanged!: boolean;\n  private _unselectableIndices!: { [index: string]: boolean };\n  private _unselectableCount: number;\n  private _isModal: boolean;\n\n  /**\n   * Create a new Selection. If `TItem` does not have a `key` property, you must provide an options\n   * object with a `getKey` implementation. Providing options is optional otherwise.\n   * (At most one `options` object is accepted.)\n   */\n  constructor(\n    ...options: TItem extends IObjectWithKey // If the item type has a built-in key...\n      ? [] | [ISelectionOptions<TItem>] // Then the arguments can be empty or have the options without `getKey`\n      : [ISelectionOptionsWithRequiredGetKey<TItem>] // Otherwise, arguments require options with `getKey`.\n  ) {\n    const {\n      onSelectionChanged,\n      onItemsChanged,\n      getKey,\n      canSelectItem = () => true,\n      items,\n      selectionMode = SelectionMode.multiple,\n    } = options[0] || ({} as ISelectionOptions<TItem>);\n\n    this.mode = selectionMode;\n\n    this._getKey = getKey || defaultGetKey;\n\n    this._changeEventSuppressionCount = 0;\n    this._exemptedCount = 0;\n    this._anchoredIndex = 0;\n    this._unselectableCount = 0;\n\n    this._onSelectionChanged = onSelectionChanged;\n    this._onItemsChanged = onItemsChanged;\n    this._canSelectItem = canSelectItem;\n    this._keyToIndexMap = {};\n\n    this._isModal = false;\n\n    this.setItems(items || [], true);\n\n    this.count = this.getSelectedCount();\n  }\n\n  public canSelectItem(item: TItem, index?: number): boolean {\n    if (typeof index === 'number' && index < 0) {\n      return false;\n    }\n\n    return this._canSelectItem(item, index);\n  }\n\n  public getKey(item: TItem, index?: number): string {\n    const key = this._getKey(item, index);\n\n    return typeof key === 'number' || key ? `${key}` : '';\n  }\n\n  public setChangeEvents(isEnabled: boolean, suppressChange?: boolean): void {\n    this._changeEventSuppressionCount += isEnabled ? -1 : 1;\n\n    if (this._changeEventSuppressionCount === 0 && this._hasChanged) {\n      this._hasChanged = false;\n\n      if (!suppressChange) {\n        this._change();\n      }\n    }\n  }\n\n  public isModal(): boolean {\n    return this._isModal;\n  }\n\n  public setModal(isModal: boolean): void {\n    if (this._isModal !== isModal) {\n      this.setChangeEvents(false);\n\n      this._isModal = isModal;\n\n      if (!isModal) {\n        this.setAllSelected(false);\n      }\n\n      this._change();\n\n      this.setChangeEvents(true);\n    }\n  }\n\n  /**\n   * Selection needs the items, call this method to set them. If the set\n   * of items is the same, this will re-evaluate selection and index maps.\n   * Otherwise, shouldClear should be set to true, so that selection is\n   * cleared.\n   */\n  public setItems(items: TItem[], shouldClear: boolean = true): void {\n    const newKeyToIndexMap: { [key: string]: number } = {};\n    const newUnselectableIndices: { [key: string]: boolean } = {};\n    let hasSelectionChanged = false;\n\n    this.setChangeEvents(false);\n\n    // Reset the unselectable count.\n    this._unselectableCount = 0;\n\n    let haveItemsChanged = false;\n\n    // Build lookup table for quick selection evaluation.\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n\n      if (item) {\n        const key = this.getKey(item, i);\n\n        if (key) {\n          if (!haveItemsChanged && (!(key in this._keyToIndexMap) || this._keyToIndexMap[key] !== i)) {\n            haveItemsChanged = true;\n          }\n\n          newKeyToIndexMap[key] = i;\n        }\n      }\n\n      newUnselectableIndices[i] = item && !this.canSelectItem(item);\n      if (newUnselectableIndices[i]) {\n        this._unselectableCount++;\n      }\n    }\n\n    if (shouldClear || items.length === 0) {\n      this._setAllSelected(false, true);\n    }\n\n    // Check the exemption list for discrepencies.\n    const newExemptedIndicies: { [key: string]: boolean } = {};\n    let newExemptedCount = 0;\n\n    for (const indexProperty in this._exemptedIndices) {\n      if (this._exemptedIndices.hasOwnProperty(indexProperty)) {\n        const index = Number(indexProperty);\n        const item = this._items[index];\n        const exemptKey = item ? this.getKey(item, Number(index)) : undefined;\n        const newIndex = exemptKey ? newKeyToIndexMap[exemptKey] : index;\n\n        if (newIndex === undefined) {\n          // The item has likely been replaced or removed.\n          hasSelectionChanged = true;\n        } else {\n          // We know the new index of the item. update the existing exemption table.\n          newExemptedIndicies[newIndex] = true;\n          newExemptedCount++;\n          hasSelectionChanged = hasSelectionChanged || newIndex !== index;\n        }\n      }\n    }\n\n    if (this._items && this._exemptedCount === 0 && items.length !== this._items.length && this._isAllSelected) {\n      // If everything was selected but the number of items has changed, selection has changed.\n      hasSelectionChanged = true;\n    }\n\n    if (!haveItemsChanged) {\n      for (const key of Object.keys(this._keyToIndexMap)) {\n        if (!(key in newKeyToIndexMap)) {\n          haveItemsChanged = true;\n          break;\n        }\n      }\n    }\n\n    this._exemptedIndices = newExemptedIndicies;\n    this._exemptedCount = newExemptedCount;\n    this._keyToIndexMap = newKeyToIndexMap;\n    this._unselectableIndices = newUnselectableIndices;\n    this._items = items;\n    this._selectedItems = null;\n\n    if (hasSelectionChanged) {\n      this._updateCount();\n    }\n\n    if (haveItemsChanged) {\n      EventGroup.raise(this, SELECTION_ITEMS_CHANGE);\n\n      if (this._onItemsChanged) {\n        this._onItemsChanged();\n      }\n    }\n\n    if (hasSelectionChanged) {\n      this._change();\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public getItems(): TItem[] {\n    return this._items;\n  }\n\n  public getSelection(): TItem[] {\n    if (!this._selectedItems) {\n      this._selectedItems = [];\n\n      const items = this._items;\n\n      if (items) {\n        for (let i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedItems.push(items[i]);\n          }\n        }\n      }\n    }\n\n    return this._selectedItems;\n  }\n\n  public getSelectedCount(): number {\n    return this._isAllSelected\n      ? this._items.length - this._exemptedCount - this._unselectableCount\n      : this._exemptedCount;\n  }\n\n  public getSelectedIndices(): number[] {\n    if (!this._selectedIndices) {\n      this._selectedIndices = [];\n\n      const items = this._items;\n\n      if (items) {\n        for (let i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedIndices.push(i);\n          }\n        }\n      }\n    }\n\n    return this._selectedIndices;\n  }\n\n  public getItemIndex(key: string): number {\n    const index = this._keyToIndexMap[key];\n\n    return index ?? -1;\n  }\n\n  public isRangeSelected(fromIndex: number, count: number): boolean {\n    if (count === 0) {\n      return false;\n    }\n\n    const endIndex = fromIndex + count;\n\n    for (let i = fromIndex; i < endIndex; i++) {\n      if (!this.isIndexSelected(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public isAllSelected(): boolean {\n    let selectableCount = this._items.length - this._unselectableCount;\n\n    // In single mode, we can only have a max of 1 item.\n    if (this.mode === SelectionMode.single) {\n      selectableCount = Math.min(selectableCount, 1);\n    }\n\n    return (\n      (this.count > 0 && this._isAllSelected && this._exemptedCount === 0) ||\n      (!this._isAllSelected && this._exemptedCount === selectableCount && selectableCount > 0)\n    );\n  }\n\n  public isKeySelected(key: string): boolean {\n    const index = this._keyToIndexMap[key];\n\n    return this.isIndexSelected(index);\n  }\n\n  public isIndexSelected(index: number): boolean {\n    return !!(\n      (this.count > 0 && this._isAllSelected && !this._exemptedIndices[index] && !this._unselectableIndices[index]) ||\n      (!this._isAllSelected && this._exemptedIndices[index])\n    );\n  }\n\n  public setAllSelected(isAllSelected: boolean): void {\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n\n    const selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n\n    this.setChangeEvents(false);\n\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n        this._change();\n      }\n\n      this._updateCount();\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public setKeySelected(key: string, isSelected: boolean, shouldAnchor: boolean): void {\n    const index = this._keyToIndexMap[key];\n\n    if (index >= 0) {\n      this.setIndexSelected(index, isSelected, shouldAnchor);\n    }\n  }\n\n  public setIndexSelected(index: number, isSelected: boolean, shouldAnchor: boolean): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    // Clamp the index.\n    index = Math.min(Math.max(0, index), this._items.length - 1);\n\n    // No-op on out of bounds selections.\n    if (index < 0 || index >= this._items.length) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n\n    const isExempt = this._exemptedIndices[index];\n    const canSelect = !this._unselectableIndices[index];\n\n    if (canSelect) {\n      if (isSelected && this.mode === SelectionMode.single) {\n        // If this is single-select, the previous selection should be removed.\n        this._setAllSelected(false, true);\n      }\n\n      // Determine if we need to remove the exemption.\n      if (isExempt && ((isSelected && this._isAllSelected) || (!isSelected && !this._isAllSelected))) {\n        delete this._exemptedIndices[index];\n        this._exemptedCount--;\n      }\n\n      // Determine if we need to add the exemption.\n      if (!isExempt && ((isSelected && !this._isAllSelected) || (!isSelected && this._isAllSelected))) {\n        this._exemptedIndices[index] = true;\n        this._exemptedCount++;\n      }\n\n      if (shouldAnchor) {\n        this._anchoredIndex = index;\n      }\n    }\n\n    this._updateCount();\n\n    this.setChangeEvents(true);\n  }\n\n  public setRangeSelected(fromIndex: number, count: number, isSelected: boolean, shouldAnchor: boolean): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    // Clamp the index.\n    fromIndex = Math.min(Math.max(0, fromIndex), this._items.length - 1);\n\n    // Clamp the range.\n    count = Math.min(Math.max(0, count), this._items.length - fromIndex);\n\n    // No-op on out of bounds selections.\n    if (fromIndex < 0 || fromIndex >= this._items.length || count === 0) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n\n    const anchorIndex = this._anchoredIndex || 0;\n    let startIndex = fromIndex;\n    const endIndex = fromIndex + count - 1;\n\n    const newAnchorIndex = anchorIndex >= endIndex ? startIndex : endIndex;\n\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, isSelected, shouldAnchor ? startIndex === newAnchorIndex : false);\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public selectToKey(key: string, clearSelection?: boolean): void {\n    this.selectToIndex(this._keyToIndexMap[key], clearSelection);\n  }\n\n  public selectToRange(fromIndex: number, count: number, clearSelection?: boolean): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    if (this.mode === SelectionMode.single) {\n      if (count === 1) {\n        this.setIndexSelected(fromIndex, true, true);\n      }\n      return;\n    }\n\n    const anchorIndex = this._anchoredIndex || 0;\n    let startIndex = Math.min(fromIndex, anchorIndex);\n    const endIndex = Math.max(fromIndex + count - 1, anchorIndex);\n\n    this.setChangeEvents(false);\n\n    if (clearSelection) {\n      this._setAllSelected(false, true);\n    }\n\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, true, false);\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public selectToIndex(index: number, clearSelection?: boolean): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    if (this.mode === SelectionMode.single) {\n      this.setIndexSelected(index, true, true);\n      return;\n    }\n\n    const anchorIndex = this._anchoredIndex || 0;\n    let startIndex = Math.min(index, anchorIndex);\n    const endIndex = Math.max(index, anchorIndex);\n\n    this.setChangeEvents(false);\n\n    if (clearSelection) {\n      this._setAllSelected(false, true);\n    }\n\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, true, false);\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public toggleAllSelected(): void {\n    this.setAllSelected(!this.isAllSelected());\n  }\n\n  public toggleKeySelected(key: string): void {\n    this.setKeySelected(key, !this.isKeySelected(key), true);\n  }\n\n  public toggleIndexSelected(index: number): void {\n    this.setIndexSelected(index, !this.isIndexSelected(index), true);\n  }\n\n  public toggleRangeSelected(fromIndex: number, count: number): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    const isRangeSelected = this.isRangeSelected(fromIndex, count);\n    const endIndex = fromIndex + count;\n\n    if (this.mode === SelectionMode.single && count > 1) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n    for (let i = fromIndex; i < endIndex; i++) {\n      this.setIndexSelected(i, !isRangeSelected, false);\n    }\n    this.setChangeEvents(true);\n  }\n\n  private _updateCount(preserveModalState: boolean = false): void {\n    const count = this.getSelectedCount();\n\n    if (count !== this.count) {\n      this.count = count;\n      this._change();\n    }\n\n    if (!this.count && !preserveModalState) {\n      this.setModal(false);\n    }\n  }\n\n  private _setAllSelected(isAllSelected: boolean, preserveModalState: boolean = false): void {\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n\n    const selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n\n    this.setChangeEvents(false);\n\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n        this._change();\n      }\n\n      this._updateCount(preserveModalState);\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  private _change(): void {\n    if (this._changeEventSuppressionCount === 0) {\n      this._selectedItems = null;\n      this._selectedIndices = undefined;\n\n      EventGroup.raise(this, SELECTION_CHANGE);\n\n      if (this._onSelectionChanged) {\n        this._onSelectionChanged();\n      }\n    } else {\n      this._hasChanged = true;\n    }\n  }\n}\n\nfunction defaultGetKey<TItem = IObjectWithKey>(item: TItem, index?: number): string | number {\n  // 0 may be used as a key\n  const { key = `${index}` } = (item || {}) as IObjectWithKey;\n  return key;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}