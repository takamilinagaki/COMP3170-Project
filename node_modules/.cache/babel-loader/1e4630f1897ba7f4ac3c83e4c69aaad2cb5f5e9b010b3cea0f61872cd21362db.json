{"ast":null,"code":"import * as React from 'react';\n/**\n * Controlled state helper that gives priority to props value. Useful for components that have props with both\n * controlled and uncontrolled modes. Any props values will override state, but will not update internal state.\n * If prop is defined and then later undefined, state will revert to its previous value.\n *\n * @param props - The props object containing controlled prop values.\n * @param propName - The controlled prop name.\n * @param options - Options. defaultPropValue is only used if defaultPropName (or its value) is undefined.\n */\nexport function useControlledState(props, propName, options) {\n  var defaultValue;\n  if (options) {\n    if (options.defaultPropName && props[options.defaultPropName] !== undefined) {\n      // No easy way to coerce TProps[TDefaultProp] to match TProps[TProp] in generic typings, so cast it here.\n      defaultValue = props[options.defaultPropName];\n    } else {\n      defaultValue = options && options.defaultPropValue;\n    }\n  }\n  var _a = React.useState(defaultValue),\n    state = _a[0],\n    setState = _a[1];\n  if (props[propName] !== undefined) {\n    return [props[propName], setState];\n  } else {\n    return [state, setState];\n  }\n}\n/**\n * Simple controlled helper that gives priority to props value and falls back to derived value.\n *\n * @param props - The props object containing controlled prop values.\n * @param propName - The controlled prop name.\n * @param derivedValue - Derived value. Returned when controlled value is not present.\n */\nexport function getControlledDerivedProps(props, propName, derivedValue) {\n  if (props[propName] !== undefined) {\n    return props[propName];\n  } else {\n    return derivedValue;\n  }\n}","map":{"version":3,"names":["React","useControlledState","props","propName","options","defaultValue","defaultPropName","undefined","defaultPropValue","_a","useState","state","setState","getControlledDerivedProps","derivedValue"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/foundation-legacy/lib/src/hooks/controlled.ts"],"sourcesContent":["import * as React from 'react';\n\nexport interface IControlledStateOptions<TProps, TProp extends keyof TProps, TDefaultProp extends keyof TProps> {\n  defaultPropValue?: TProps[TProp];\n  defaultPropName?: TDefaultProp;\n}\n\n/**\n * Controlled state helper that gives priority to props value. Useful for components that have props with both\n * controlled and uncontrolled modes. Any props values will override state, but will not update internal state.\n * If prop is defined and then later undefined, state will revert to its previous value.\n *\n * @param props - The props object containing controlled prop values.\n * @param propName - The controlled prop name.\n * @param options - Options. defaultPropValue is only used if defaultPropName (or its value) is undefined.\n */\nexport function useControlledState<TProps, TProp extends keyof TProps, TDefaultProp extends keyof TProps>(\n  props: Readonly<TProps>,\n  propName: TProp,\n  options?: IControlledStateOptions<TProps, TProp, TDefaultProp>,\n): [TProps[TProp] | undefined, React.Dispatch<React.SetStateAction<TProps[TProp]>>] {\n  let defaultValue: TProps[TProp] | undefined;\n  if (options) {\n    if (options.defaultPropName && props[options.defaultPropName] !== undefined) {\n      // No easy way to coerce TProps[TDefaultProp] to match TProps[TProp] in generic typings, so cast it here.\n      defaultValue = props[options.defaultPropName] as unknown as TProps[TProp];\n    } else {\n      defaultValue = options && options.defaultPropValue;\n    }\n  }\n\n  const [state, setState] = React.useState(defaultValue);\n\n  if (props[propName] !== undefined) {\n    return [props[propName], setState];\n  } else {\n    return [state, setState];\n  }\n}\n\n/**\n * Simple controlled helper that gives priority to props value and falls back to derived value.\n *\n * @param props - The props object containing controlled prop values.\n * @param propName - The controlled prop name.\n * @param derivedValue - Derived value. Returned when controlled value is not present.\n */\nexport function getControlledDerivedProps<TProps, TProp extends keyof TProps>(\n  props: Readonly<TProps>,\n  propName: TProp,\n  derivedValue: TProps[TProp],\n): TProps[TProp] {\n  if (props[propName] !== undefined) {\n    return props[propName];\n  } else {\n    return derivedValue;\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAO9B;;;;;;;;;AASA,OAAM,SAAUC,kBAAkBA,CAChCC,KAAuB,EACvBC,QAAe,EACfC,OAA8D;EAE9D,IAAIC,YAAuC;EAC3C,IAAID,OAAO,EAAE;IACX,IAAIA,OAAO,CAACE,eAAe,IAAIJ,KAAK,CAACE,OAAO,CAACE,eAAe,CAAC,KAAKC,SAAS,EAAE;MAC3E;MACAF,YAAY,GAAGH,KAAK,CAACE,OAAO,CAACE,eAAe,CAA6B;KAC1E,MAAM;MACLD,YAAY,GAAGD,OAAO,IAAIA,OAAO,CAACI,gBAAgB;;;EAIhD,IAAAC,EAAA,GAAoBT,KAAK,CAACU,QAAQ,CAACL,YAAY,CAAC;IAA/CM,KAAK,GAAAF,EAAA;IAAEG,QAAQ,GAAAH,EAAA,GAAgC;EAEtD,IAAIP,KAAK,CAACC,QAAQ,CAAC,KAAKI,SAAS,EAAE;IACjC,OAAO,CAACL,KAAK,CAACC,QAAQ,CAAC,EAAES,QAAQ,CAAC;GACnC,MAAM;IACL,OAAO,CAACD,KAAK,EAAEC,QAAQ,CAAC;;AAE5B;AAEA;;;;;;;AAOA,OAAM,SAAUC,yBAAyBA,CACvCX,KAAuB,EACvBC,QAAe,EACfW,YAA2B;EAE3B,IAAIZ,KAAK,CAACC,QAAQ,CAAC,KAAKI,SAAS,EAAE;IACjC,OAAOL,KAAK,CAACC,QAAQ,CAAC;GACvB,MAAM;IACL,OAAOW,YAAY;;AAEvB"},"metadata":{},"sourceType":"module","externalDependencies":[]}