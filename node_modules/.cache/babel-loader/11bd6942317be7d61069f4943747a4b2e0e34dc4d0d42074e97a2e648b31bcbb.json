{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, getDocument, getNativeProps, initializeComponentRef, inputProperties, isIE11, KeyCodes } from '../../Utilities';\nimport { WindowContext } from '@fluentui/react-window-provider';\nvar SELECTION_FORWARD = 'forward';\nvar SELECTION_BACKWARD = 'backward';\n/**\n * {@docCategory Autofill}\n */\nvar Autofill = /** @class */function (_super) {\n  __extends(Autofill, _super);\n  function Autofill(props) {\n    var _this = _super.call(this, props) || this;\n    _this._inputElement = React.createRef();\n    _this._autoFillEnabled = true;\n    // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n    _this._onCompositionStart = function (ev) {\n      _this.setState({\n        isComposing: true\n      });\n      _this._autoFillEnabled = false;\n    };\n    // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n    _this._onCompositionUpdate = function () {\n      if (isIE11()) {\n        _this._updateValue(_this._getCurrentInputValue(), true);\n      }\n    };\n    // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n    _this._onCompositionEnd = function (ev) {\n      var inputValue = _this._getCurrentInputValue();\n      _this._tryEnableAutofill(inputValue, _this.value, false, true);\n      _this.setState({\n        isComposing: false\n      });\n      // Due to timing, this needs to be async, otherwise no text will be selected.\n      _this._async.setTimeout(function () {\n        // it's technically possible that the value of isComposing is reset during this timeout,\n        // so explicitly trigger this with composing=true here, since it is supposed to be the\n        // update for composition end\n        _this._updateValue(_this._getCurrentInputValue(), false);\n      }, 0);\n    };\n    _this._onClick = function () {\n      if (_this.value && _this.value !== '' && _this._autoFillEnabled) {\n        _this._autoFillEnabled = false;\n      }\n    };\n    _this._onKeyDown = function (ev) {\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      }\n      // If the event is actively being composed, then don't alert autofill.\n      // Right now typing does not have isComposing, once that has been fixed any should be removed.\n      if (!ev.nativeEvent.isComposing) {\n        // eslint-disable-next-line deprecation/deprecation\n        switch (ev.which) {\n          case KeyCodes.backspace:\n            _this._autoFillEnabled = false;\n            break;\n          case KeyCodes.left:\n          case KeyCodes.right:\n            if (_this._autoFillEnabled) {\n              _this.setState(function (prev) {\n                return {\n                  inputValue: _this.props.suggestedDisplayValue || prev.inputValue\n                };\n              });\n              _this._autoFillEnabled = false;\n            }\n            break;\n          default:\n            if (!_this._autoFillEnabled) {\n              // eslint-disable-next-line deprecation/deprecation\n              if (_this.props.enableAutofillOnKeyPress.indexOf(ev.which) !== -1) {\n                _this._autoFillEnabled = true;\n              }\n            }\n            break;\n        }\n      }\n    };\n    _this._onInputChanged = function (ev) {\n      var value = _this._getCurrentInputValue(ev);\n      if (!_this.state.isComposing) {\n        _this._tryEnableAutofill(value, _this.value, ev.nativeEvent.isComposing);\n      }\n      // If it is not IE11 and currently composing, update the value\n      if (!(isIE11() && _this.state.isComposing)) {\n        var nativeEventComposing = ev.nativeEvent.isComposing;\n        var isComposing = nativeEventComposing === undefined ? _this.state.isComposing : nativeEventComposing;\n        _this._updateValue(value, isComposing);\n      }\n    };\n    _this._onChanged = function () {\n      // Swallow this event, we don't care about it\n      // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n      return;\n    };\n    /**\n     * Updates the current input value as well as getting a new display value.\n     * @param newValue - The new value from the input\n     */\n    _this._updateValue = function (newValue, composing) {\n      // Only proceed if the value is nonempty and is different from the old value\n      // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n      if (!newValue && newValue === _this.value) {\n        return;\n      }\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = _this.props,\n        onInputChange = _a.onInputChange,\n        onInputValueChange = _a.onInputValueChange;\n      if (onInputChange) {\n        newValue = (onInputChange === null || onInputChange === void 0 ? void 0 : onInputChange(newValue, composing)) || '';\n      }\n      _this.setState({\n        inputValue: newValue\n      }, function () {\n        return onInputValueChange === null || onInputValueChange === void 0 ? void 0 : onInputValueChange(newValue, composing);\n      });\n    };\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this.state = {\n      inputValue: props.defaultVisibleValue || '',\n      isComposing: false\n    };\n    return _this;\n  }\n  Autofill.getDerivedStateFromProps = function (props, state) {\n    // eslint-disable-next-line deprecation/deprecation\n    if (props.updateValueInWillReceiveProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      var updatedInputValue = props.updateValueInWillReceiveProps();\n      // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n      if (updatedInputValue !== null && updatedInputValue !== state.inputValue && !state.isComposing) {\n        return __assign(__assign({}, state), {\n          inputValue: updatedInputValue\n        });\n      }\n    }\n    return null;\n  };\n  Object.defineProperty(Autofill.prototype, \"cursorLocation\", {\n    get: function () {\n      if (this._inputElement.current) {\n        var inputElement = this._inputElement.current;\n        if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n          return inputElement.selectionEnd;\n        } else {\n          return inputElement.selectionStart;\n        }\n      } else {\n        return -1;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"isValueSelected\", {\n    get: function () {\n      return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"value\", {\n    get: function () {\n      return this._getControlledValue() || this.state.inputValue || '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionStart\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionEnd\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"inputElement\", {\n    get: function () {\n      return this._inputElement.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Autofill.prototype.componentDidUpdate = function (_, _1, cursor) {\n    var _a;\n    var _b = this.props,\n      suggestedDisplayValue = _b.suggestedDisplayValue,\n      shouldSelectFullInputValueInComponentDidUpdate = _b.shouldSelectFullInputValueInComponentDidUpdate,\n      preventValueSelection = _b.preventValueSelection;\n    var differenceIndex = 0;\n    if (preventValueSelection) {\n      return;\n    }\n    var document = ((_a = this.context) === null || _a === void 0 ? void 0 : _a.window.document) || getDocument(this._inputElement.current);\n    var isFocused = this._inputElement.current && this._inputElement.current === (document === null || document === void 0 ? void 0 : document.activeElement);\n    if (isFocused && this._autoFillEnabled && this.value && suggestedDisplayValue && _doesTextStartWith(suggestedDisplayValue, this.value)) {\n      var shouldSelectFullRange = false;\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n      if (shouldSelectFullRange) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (differenceIndex < this.value.length && this.value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()) {\n          differenceIndex++;\n        }\n        if (differenceIndex > 0) {\n          this._inputElement.current.setSelectionRange(differenceIndex, suggestedDisplayValue.length, SELECTION_BACKWARD);\n        }\n      }\n    } else if (this._inputElement.current) {\n      if (cursor !== null && !this._autoFillEnabled && !this.state.isComposing) {\n        this._inputElement.current.setSelectionRange(cursor.start, cursor.end, cursor.dir);\n      }\n    }\n  };\n  Autofill.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n  Autofill.prototype.render = function () {\n    var nativeProps = getNativeProps(this.props, inputProperties);\n    var style = __assign(__assign({}, this.props.style), {\n      fontFamily: 'inherit'\n    });\n    return React.createElement(\"input\", __assign({\n      autoCapitalize: \"off\",\n      autoComplete: \"off\",\n      \"aria-autocomplete\": 'both'\n    }, nativeProps, {\n      style: style,\n      ref: this._inputElement,\n      value: this._getDisplayValue(),\n      onCompositionStart: this._onCompositionStart,\n      onCompositionUpdate: this._onCompositionUpdate,\n      onCompositionEnd: this._onCompositionEnd,\n      // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n      onChange: this._onChanged,\n      onInput: this._onInputChanged,\n      onKeyDown: this._onKeyDown,\n      onClick: this.props.onClick ? this.props.onClick : this._onClick,\n      \"data-lpignore\": true\n    }));\n  };\n  Autofill.prototype.focus = function () {\n    this._inputElement.current && this._inputElement.current.focus();\n  };\n  Autofill.prototype.clear = function () {\n    this._autoFillEnabled = true;\n    this._updateValue('', false);\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  };\n  Autofill.prototype.getSnapshotBeforeUpdate = function () {\n    var _a, _b;\n    var inel = this._inputElement.current;\n    if (inel && inel.selectionStart !== this.value.length) {\n      return {\n        start: (_a = inel.selectionStart) !== null && _a !== void 0 ? _a : inel.value.length,\n        end: (_b = inel.selectionEnd) !== null && _b !== void 0 ? _b : inel.value.length,\n        dir: inel.selectionDirection || 'backward' || 'none'\n      };\n    }\n    return null;\n  };\n  Autofill.prototype._getCurrentInputValue = function (ev) {\n    if (ev && ev.target && ev.target.value) {\n      return ev.target.value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  };\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n  Autofill.prototype._tryEnableAutofill = function (newValue, oldValue, isComposing, isComposed) {\n    if (!isComposing && newValue && this._inputElement.current && this._inputElement.current.selectionStart === newValue.length && !this._autoFillEnabled && (newValue.length > oldValue.length || isComposed)) {\n      this._autoFillEnabled = true;\n    }\n  };\n  Autofill.prototype._getDisplayValue = function () {\n    if (this._autoFillEnabled) {\n      return _getDisplayValue(this.value, this.props.suggestedDisplayValue);\n    }\n    return this.value;\n  };\n  Autofill.prototype._getControlledValue = function () {\n    var value = this.props.value;\n    if (value === undefined || typeof value === 'string') {\n      return value;\n    }\n    // eslint-disable-next-line no-console\n    console.warn(\"props.value of Autofill should be a string, but it is \".concat(value, \" with type of \").concat(typeof value));\n    return value.toString();\n  };\n  Autofill.defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up]\n  };\n  // need to check WindowContext to get the provided document\n  Autofill.contextType = WindowContext;\n  return Autofill;\n}(React.Component);\nexport { Autofill };\n/**\n * Returns a string that should be used as the display value.\n * It evaluates this based on whether or not the suggested value starts with the input value\n * and whether or not autofill is enabled.\n * @param inputValue - the value that the input currently has.\n * @param suggestedDisplayValue - the possible full value\n */\nfunction _getDisplayValue(inputValue, suggestedDisplayValue) {\n  var displayValue = inputValue;\n  if (suggestedDisplayValue && inputValue && _doesTextStartWith(suggestedDisplayValue, displayValue)) {\n    displayValue = suggestedDisplayValue;\n  }\n  return displayValue;\n}\nfunction _doesTextStartWith(text, startWith) {\n  if (!text || !startWith) {\n    return false;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    for (var _i = 0, _a = [text, startWith]; _i < _a.length; _i++) {\n      var val = _a[_i];\n      if (typeof val !== 'string') {\n        throw new Error(\"\".concat(Autofill.name\n        // eslint-disable-next-line @fluentui/max-len\n        , \" received non-string value \\\"\").concat(val, \"\\\" of type \").concat(typeof val, \" from either input's value or suggestedDisplayValue\"));\n      }\n    }\n  }\n  return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n}","map":{"version":3,"names":["React","Async","getDocument","getNativeProps","initializeComponentRef","inputProperties","isIE11","KeyCodes","WindowContext","SELECTION_FORWARD","SELECTION_BACKWARD","Autofill","_super","__extends","props","_this","call","_inputElement","createRef","_autoFillEnabled","_onCompositionStart","ev","setState","isComposing","_onCompositionUpdate","_updateValue","_getCurrentInputValue","_onCompositionEnd","inputValue","_tryEnableAutofill","value","_async","setTimeout","_onClick","_onKeyDown","onKeyDown","nativeEvent","which","backspace","left","right","prev","suggestedDisplayValue","enableAutofillOnKeyPress","indexOf","_onInputChanged","state","nativeEventComposing","undefined","_onChanged","newValue","composing","_a","onInputChange","onInputValueChange","defaultVisibleValue","getDerivedStateFromProps","updateValueInWillReceiveProps","updatedInputValue","__assign","Object","defineProperty","prototype","get","current","inputElement","selectionDirection","selectionEnd","selectionStart","Boolean","_getControlledValue","componentDidUpdate","_","_1","cursor","_b","shouldSelectFullInputValueInComponentDidUpdate","preventValueSelection","differenceIndex","document","context","window","isFocused","activeElement","_doesTextStartWith","shouldSelectFullRange","setSelectionRange","length","toLocaleLowerCase","start","end","dir","componentWillUnmount","dispose","render","nativeProps","style","fontFamily","createElement","autoCapitalize","autoComplete","ref","_getDisplayValue","onCompositionStart","onCompositionUpdate","onCompositionEnd","onChange","onInput","onClick","focus","clear","getSnapshotBeforeUpdate","inel","target","oldValue","isComposed","console","warn","concat","toString","defaultProps","down","up","contextType","Component","displayValue","text","startWith","process","env","NODE_ENV","_i","val","Error","name"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/components/src/components/Autofill/Autofill.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  getDocument,\n  getNativeProps,\n  initializeComponentRef,\n  inputProperties,\n  isIE11,\n  KeyCodes,\n} from '../../Utilities';\nimport { WindowContext } from '@fluentui/react-window-provider';\nimport type { IAutofill, IAutofillProps } from './Autofill.types';\n\nexport interface IAutofillState {\n  inputValue: string;\n  isComposing: boolean;\n}\n\ninterface ICursorLocation {\n  start: number;\n  end: number;\n  dir: 'forward' | 'backward' | 'none' | undefined;\n}\n\nconst SELECTION_FORWARD = 'forward';\nconst SELECTION_BACKWARD = 'backward';\n\n/**\n * {@docCategory Autofill}\n */\nexport class Autofill extends React.Component<IAutofillProps, IAutofillState> implements IAutofill {\n  public static defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up] as KeyCodes[],\n  };\n  // need to check WindowContext to get the provided document\n  public static contextType = WindowContext;\n\n  private _inputElement = React.createRef<HTMLInputElement>();\n  private _autoFillEnabled = true;\n  private _async: Async;\n\n  public static getDerivedStateFromProps(props: IAutofillProps, state: IAutofillState): IAutofillState | null {\n    // eslint-disable-next-line deprecation/deprecation\n    if (props.updateValueInWillReceiveProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      const updatedInputValue = props.updateValueInWillReceiveProps();\n      // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n      if (updatedInputValue !== null && updatedInputValue !== state.inputValue && !state.isComposing) {\n        return { ...state, inputValue: updatedInputValue };\n      }\n    }\n    return null;\n  }\n\n  constructor(props: IAutofillProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n\n    this.state = {\n      inputValue: props.defaultVisibleValue || '',\n      isComposing: false,\n    };\n  }\n\n  public get cursorLocation(): number | null {\n    if (this._inputElement.current) {\n      const inputElement = this._inputElement.current;\n      if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n        return inputElement.selectionEnd;\n      } else {\n        return inputElement.selectionStart;\n      }\n    } else {\n      return -1;\n    }\n  }\n\n  public get isValueSelected(): boolean {\n    return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n  }\n\n  public get value(): string {\n    return this._getControlledValue() || this.state.inputValue || '';\n  }\n\n  public get selectionStart(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n  }\n\n  public get selectionEnd(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n  }\n\n  public get inputElement(): HTMLInputElement | null {\n    return this._inputElement.current;\n  }\n\n  public componentDidUpdate(_: any, _1: any, cursor: ICursorLocation | null) {\n    const { suggestedDisplayValue, shouldSelectFullInputValueInComponentDidUpdate, preventValueSelection } = this.props;\n    let differenceIndex = 0;\n\n    if (preventValueSelection) {\n      return;\n    }\n\n    const document = this.context?.window.document || getDocument(this._inputElement.current);\n    const isFocused = this._inputElement.current && this._inputElement.current === document?.activeElement;\n\n    if (\n      isFocused &&\n      this._autoFillEnabled &&\n      this.value &&\n      suggestedDisplayValue &&\n      _doesTextStartWith(suggestedDisplayValue, this.value)\n    ) {\n      let shouldSelectFullRange = false;\n\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n\n      if (shouldSelectFullRange) {\n        this._inputElement.current!.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (\n          differenceIndex < this.value.length &&\n          this.value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()\n        ) {\n          differenceIndex++;\n        }\n        if (differenceIndex > 0) {\n          this._inputElement.current!.setSelectionRange(\n            differenceIndex,\n            suggestedDisplayValue.length,\n            SELECTION_BACKWARD,\n          );\n        }\n      }\n    } else if (this._inputElement.current) {\n      if (cursor !== null && !this._autoFillEnabled && !this.state.isComposing) {\n        this._inputElement.current.setSelectionRange(cursor.start, cursor.end, cursor.dir);\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const nativeProps = getNativeProps<React.InputHTMLAttributes<HTMLInputElement>>(this.props, inputProperties);\n    const style = { ...this.props.style, fontFamily: 'inherit' };\n    return (\n      <input\n        autoCapitalize=\"off\"\n        autoComplete=\"off\"\n        aria-autocomplete={'both'}\n        {...nativeProps}\n        style={style}\n        ref={this._inputElement}\n        value={this._getDisplayValue()}\n        onCompositionStart={this._onCompositionStart}\n        onCompositionUpdate={this._onCompositionUpdate}\n        onCompositionEnd={this._onCompositionEnd}\n        // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n        onChange={this._onChanged}\n        onInput={this._onInputChanged}\n        onKeyDown={this._onKeyDown}\n        onClick={this.props.onClick ? this.props.onClick : this._onClick}\n        data-lpignore={true}\n      />\n    );\n  }\n\n  public focus() {\n    this._inputElement.current && this._inputElement.current.focus();\n  }\n\n  public clear() {\n    this._autoFillEnabled = true;\n    this._updateValue('', false);\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  }\n\n  public getSnapshotBeforeUpdate(): ICursorLocation | null {\n    const inel = this._inputElement.current;\n\n    if (inel && inel.selectionStart !== this.value.length) {\n      return {\n        start: inel.selectionStart ?? inel.value.length,\n        end: inel.selectionEnd ?? inel.value.length,\n        dir: (inel.selectionDirection as 'forward') || 'backward' || 'none',\n      };\n    }\n    return null;\n  }\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionStart = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    this.setState({ isComposing: true });\n    this._autoFillEnabled = false;\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionUpdate = () => {\n    if (isIE11()) {\n      this._updateValue(this._getCurrentInputValue(), true);\n    }\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionEnd = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    const inputValue = this._getCurrentInputValue();\n    this._tryEnableAutofill(inputValue, this.value, false, true);\n    this.setState({ isComposing: false });\n\n    // Due to timing, this needs to be async, otherwise no text will be selected.\n    this._async.setTimeout(() => {\n      // it's technically possible that the value of isComposing is reset during this timeout,\n      // so explicitly trigger this with composing=true here, since it is supposed to be the\n      // update for composition end\n      this._updateValue(this._getCurrentInputValue(), false);\n    }, 0);\n  };\n\n  private _onClick = () => {\n    if (this.value && this.value !== '' && this._autoFillEnabled) {\n      this._autoFillEnabled = false;\n    }\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLInputElement>) => {\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // If the event is actively being composed, then don't alert autofill.\n    // Right now typing does not have isComposing, once that has been fixed any should be removed.\n\n    if (!(ev.nativeEvent as any).isComposing) {\n      // eslint-disable-next-line deprecation/deprecation\n      switch (ev.which) {\n        case KeyCodes.backspace:\n          this._autoFillEnabled = false;\n          break;\n        case KeyCodes.left:\n        case KeyCodes.right:\n          if (this._autoFillEnabled) {\n            this.setState(prev => ({\n              inputValue: this.props.suggestedDisplayValue || prev.inputValue,\n            }));\n            this._autoFillEnabled = false;\n          }\n          break;\n        default:\n          if (!this._autoFillEnabled) {\n            // eslint-disable-next-line deprecation/deprecation\n            if (this.props.enableAutofillOnKeyPress!.indexOf(ev.which) !== -1) {\n              this._autoFillEnabled = true;\n            }\n          }\n          break;\n      }\n    }\n  };\n\n  private _onInputChanged = (ev: React.FormEvent<HTMLElement>) => {\n    const value: string = this._getCurrentInputValue(ev);\n\n    if (!this.state.isComposing) {\n      this._tryEnableAutofill(value, this.value, (ev.nativeEvent as any).isComposing);\n    }\n\n    // If it is not IE11 and currently composing, update the value\n    if (!(isIE11() && this.state.isComposing)) {\n      const nativeEventComposing = (ev.nativeEvent as any).isComposing;\n      const isComposing = nativeEventComposing === undefined ? this.state.isComposing : nativeEventComposing;\n      this._updateValue(value, isComposing);\n    }\n  };\n\n  private _onChanged = (): void => {\n    // Swallow this event, we don't care about it\n    // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n    return;\n  };\n\n  private _getCurrentInputValue(ev?: React.FormEvent<HTMLElement>): string {\n    if (ev && ev.target && (ev.target as HTMLInputElement).value) {\n      return (ev.target as HTMLInputElement).value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n  private _tryEnableAutofill(newValue: string, oldValue: string, isComposing?: boolean, isComposed?: boolean): void {\n    if (\n      !isComposing &&\n      newValue &&\n      this._inputElement.current &&\n      this._inputElement.current.selectionStart === newValue.length &&\n      !this._autoFillEnabled &&\n      (newValue.length > oldValue.length || isComposed)\n    ) {\n      this._autoFillEnabled = true;\n    }\n  }\n\n  /**\n   * Updates the current input value as well as getting a new display value.\n   * @param newValue - The new value from the input\n   */\n  private _updateValue = (newValue: string, composing: boolean) => {\n    // Only proceed if the value is nonempty and is different from the old value\n    // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n    if (!newValue && newValue === this.value) {\n      return;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const { onInputChange, onInputValueChange } = this.props;\n    if (onInputChange) {\n      newValue = onInputChange?.(newValue, composing) || '';\n    }\n\n    this.setState({ inputValue: newValue }, () => onInputValueChange?.(newValue, composing));\n  };\n\n  private _getDisplayValue(): string {\n    if (this._autoFillEnabled) {\n      return _getDisplayValue(this.value, this.props.suggestedDisplayValue);\n    }\n\n    return this.value;\n  }\n\n  private _getControlledValue(): string | undefined {\n    const { value } = this.props;\n    if (value === undefined || typeof value === 'string') {\n      return value;\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn(`props.value of Autofill should be a string, but it is ${value} with type of ${typeof value}`);\n\n    return value.toString();\n  }\n}\n/**\n * Returns a string that should be used as the display value.\n * It evaluates this based on whether or not the suggested value starts with the input value\n * and whether or not autofill is enabled.\n * @param inputValue - the value that the input currently has.\n * @param suggestedDisplayValue - the possible full value\n */\nfunction _getDisplayValue(inputValue: string, suggestedDisplayValue?: string): string {\n  let displayValue = inputValue;\n  if (suggestedDisplayValue && inputValue && _doesTextStartWith(suggestedDisplayValue, displayValue)) {\n    displayValue = suggestedDisplayValue;\n  }\n  return displayValue;\n}\n\nfunction _doesTextStartWith(text: string, startWith: string): boolean {\n  if (!text || !startWith) {\n    return false;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    for (const val of [text, startWith]) {\n      if (typeof val !== 'string') {\n        throw new Error(\n          `${\n            Autofill.name\n            // eslint-disable-next-line @fluentui/max-len\n          } received non-string value \"${val}\" of type ${typeof val} from either input's value or suggestedDisplayValue`,\n        );\n      }\n    }\n  }\n\n  return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}