{"ast":null,"code":"import { __assign, __extends, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { anchorProperties, assign, buttonProperties, createMergedRef, css, getId, getNativeProps, initializeComponentRef, memoizeFunction, mergeAriaAttributeValues, nullRender, portalContainsElement, setFocusVisibility, warnConditionallyRequiredProps, warnDeprecations, Async, EventGroup, FocusRects, FocusRectsContext, KeyCodes } from '../../Utilities';\nimport { Icon, FontIcon, ImageIcon } from '../../Icon';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { ContextualMenu } from '../../ContextualMenu';\nimport { getBaseButtonClassNames } from './BaseButton.classNames';\nimport { getSplitButtonClassNames as getBaseSplitButtonClassNames } from './SplitButton/SplitButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nimport { composeComponentAs } from '../../Utilities';\nvar TouchIdleDelay = 500; /* ms */\nvar COMPONENT_NAME = 'BaseButton';\n/**\n * {@docCategory Button}\n */\nvar BaseButton = /** @class */function (_super) {\n  __extends(BaseButton, _super);\n  function BaseButton(props) {\n    var _this = _super.call(this, props) || this;\n    _this._buttonElement = React.createRef();\n    _this._splitButtonContainer = React.createRef();\n    _this._mergedRef = createMergedRef();\n    _this._renderedVisibleMenu = false;\n    _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function (keytipProps) {\n      return __assign(__assign({}, keytipProps), {\n        hasMenu: true\n      });\n    });\n    _this._onRenderIcon = function (buttonProps, defaultRender) {\n      var iconProps = _this.props.iconProps;\n      if (iconProps && (iconProps.iconName !== undefined || iconProps.imageProps)) {\n        var className = iconProps.className,\n          imageProps = iconProps.imageProps,\n          rest = __rest(iconProps, [\"className\", \"imageProps\"]);\n        // If the styles prop is specified as part of iconProps, fall back to regular Icon as FontIcon and ImageIcon\n        // do not have this prop.\n        if (iconProps.styles) {\n          return React.createElement(Icon, __assign({\n            className: css(_this._classNames.icon, className),\n            imageProps: imageProps\n          }, rest));\n        }\n        if (iconProps.iconName) {\n          return React.createElement(FontIcon, __assign({\n            className: css(_this._classNames.icon, className)\n          }, rest));\n        }\n        if (imageProps) {\n          return React.createElement(ImageIcon, __assign({\n            className: css(_this._classNames.icon, className),\n            imageProps: imageProps\n          }, rest));\n        }\n      }\n      return null;\n    };\n    _this._onRenderTextContents = function () {\n      var _a = _this.props,\n        text = _a.text,\n        children = _a.children,\n        // eslint-disable-next-line deprecation/deprecation\n        _b = _a.secondaryText,\n        // eslint-disable-next-line deprecation/deprecation\n        secondaryText = _b === void 0 ? _this.props.description : _b,\n        _c = _a.onRenderText,\n        onRenderText = _c === void 0 ? _this._onRenderText : _c,\n        _d = _a.onRenderDescription,\n        onRenderDescription = _d === void 0 ? _this._onRenderDescription : _d;\n      if (text || typeof children === 'string' || secondaryText) {\n        return React.createElement(\"span\", {\n          className: _this._classNames.textContainer\n        }, onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription));\n      }\n      return [onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription)];\n    };\n    _this._onRenderText = function () {\n      var text = _this.props.text;\n      var children = _this.props.children;\n      // For backwards compat, we should continue to take in the text content from children.\n      if (text === undefined && typeof children === 'string') {\n        text = children;\n      }\n      if (_this._hasText()) {\n        return React.createElement(\"span\", {\n          key: _this._labelId,\n          className: _this._classNames.label,\n          id: _this._labelId\n        }, text);\n      }\n      return null;\n    };\n    _this._onRenderChildren = function () {\n      var children = _this.props.children;\n      // If children is just a string, either it or the text will be rendered via onRenderLabel\n      // If children is another component, it will be rendered after text\n      if (typeof children === 'string') {\n        return null;\n      }\n      return children;\n    };\n    _this._onRenderDescription = function (props) {\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = props.secondaryText,\n        secondaryText = _a === void 0 ? _this.props.description : _a;\n      // ms-Button-description is only shown when the button type is compound.\n      // In other cases it will not be displayed.\n      return secondaryText ? React.createElement(\"span\", {\n        key: _this._descriptionId,\n        className: _this._classNames.description,\n        id: _this._descriptionId\n      }, secondaryText) : null;\n    };\n    _this._onRenderAriaDescription = function () {\n      var ariaDescription = _this.props.ariaDescription;\n      // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,\n      // otherwise it will be assigned to descriptionSpan.\n      return ariaDescription ? React.createElement(\"span\", {\n        className: _this._classNames.screenReaderText,\n        id: _this._ariaDescriptionId\n      }, ariaDescription) : null;\n    };\n    _this._onRenderMenuIcon = function (props) {\n      var menuIconProps = _this.props.menuIconProps;\n      return React.createElement(FontIcon, __assign({\n        iconName: \"ChevronDown\"\n      }, menuIconProps, {\n        className: _this._classNames.menuIcon\n      }));\n    };\n    _this._onRenderMenu = function (menuProps) {\n      var MenuType = _this.props.menuAs ? composeComponentAs(_this.props.menuAs, ContextualMenu) : ContextualMenu;\n      return React.createElement(MenuType, __assign({}, menuProps));\n    };\n    _this._onDismissMenu = function (ev) {\n      var menuProps = _this.props.menuProps;\n      if (menuProps && menuProps.onDismiss) {\n        menuProps.onDismiss(ev);\n      }\n      if (!ev || !ev.defaultPrevented) {\n        _this._dismissMenu();\n      }\n    };\n    _this._dismissMenu = function () {\n      _this._menuShouldFocusOnMount = undefined;\n      _this._menuShouldFocusOnContainer = undefined;\n      _this.setState({\n        menuHidden: true\n      });\n    };\n    _this._openMenu = function (shouldFocusOnContainer, shouldFocusOnMount) {\n      if (shouldFocusOnMount === void 0) {\n        shouldFocusOnMount = true;\n      }\n      if (_this.props.menuProps) {\n        _this._menuShouldFocusOnContainer = shouldFocusOnContainer;\n        _this._menuShouldFocusOnMount = shouldFocusOnMount;\n        _this._renderedVisibleMenu = true;\n        _this.setState({\n          menuHidden: false\n        });\n      }\n    };\n    _this._onToggleMenu = function (shouldFocusOnContainer) {\n      var shouldFocusOnMount = true;\n      if (_this.props.menuProps && _this.props.menuProps.shouldFocusOnMount === false) {\n        shouldFocusOnMount = false;\n      }\n      _this.state.menuHidden ? _this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : _this._dismissMenu();\n    };\n    _this._onSplitContainerFocusCapture = function (ev) {\n      var container = _this._splitButtonContainer.current;\n      // If the target is coming from the portal we do not need to set focus on the container.\n      if (!container || ev.target && portalContainsElement(ev.target, container)) {\n        return;\n      }\n      // We should never be able to focus the individual buttons in a split button. Focus\n      // should always remain on the container.\n      container.focus();\n    };\n    _this._onSplitButtonPrimaryClick = function (ev) {\n      if (!_this.state.menuHidden) {\n        _this._dismissMenu();\n      }\n      // toggle split buttons need two separate targets, even for touch\n      var singleTouchTarget = _this._processingTouch && !_this.props.toggle;\n      if (!singleTouchTarget && _this.props.onClick) {\n        _this.props.onClick(ev);\n      } else if (singleTouchTarget) {\n        _this._onMenuClick(ev);\n      }\n    };\n    _this._onKeyDown = function (ev) {\n      // explicity cancelling event so click won't fire after this\n      // eslint-disable-next-line deprecation/deprecation\n      if (_this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {\n        ev.preventDefault();\n        ev.stopPropagation();\n      } else if (!_this.props.disabled) {\n        if (_this.props.menuProps) {\n          _this._onMenuKeyDown(ev);\n        } else if (_this.props.onKeyDown !== undefined) {\n          _this.props.onKeyDown(ev); // not cancelling event because it's not disabled\n        }\n      }\n    };\n\n    _this._onKeyUp = function (ev) {\n      if (!_this.props.disabled && _this.props.onKeyUp !== undefined) {\n        _this.props.onKeyUp(ev); // not cancelling event because it's not disabled\n      }\n    };\n\n    _this._onKeyPress = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      if (!_this.props.disabled && _this.props.onKeyPress !== undefined) {\n        // eslint-disable-next-line deprecation/deprecation\n        _this.props.onKeyPress(ev); // not cancelling event because it's not disabled\n      }\n    };\n\n    _this._onMouseUp = function (ev) {\n      if (!_this.props.disabled && _this.props.onMouseUp !== undefined) {\n        _this.props.onMouseUp(ev); // not cancelling event because it's not disabled\n      }\n    };\n\n    _this._onMouseDown = function (ev) {\n      if (!_this.props.disabled && _this.props.onMouseDown !== undefined) {\n        _this.props.onMouseDown(ev); // not cancelling event because it's not disabled\n      }\n    };\n\n    _this._onClick = function (ev) {\n      if (!_this.props.disabled) {\n        if (_this.props.menuProps) {\n          _this._onMenuClick(ev);\n        } else if (_this.props.onClick !== undefined) {\n          _this.props.onClick(ev); // not cancelling event because it's not disabled\n        }\n      }\n    };\n\n    _this._onSplitButtonContainerKeyDown = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n        if (_this._buttonElement.current) {\n          _this._buttonElement.current.click();\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      } else {\n        _this._onMenuKeyDown(ev);\n      }\n    };\n    _this._onMenuKeyDown = function (ev) {\n      var _a;\n      if (_this.props.disabled) {\n        return;\n      }\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      }\n      // eslint-disable-next-line deprecation/deprecation\n      var isUp = ev.which === KeyCodes.up;\n      // eslint-disable-next-line deprecation/deprecation\n      var isDown = ev.which === KeyCodes.down;\n      if (!ev.defaultPrevented && _this._isValidMenuOpenKey(ev)) {\n        var onMenuClick = _this.props.onMenuClick;\n        if (onMenuClick) {\n          onMenuClick(ev, _this.props);\n        }\n        _this._onToggleMenu(false);\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n      // eslint-disable-next-line deprecation/deprecation\n      if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n        // We manually set the focus visibility to true if opening via Enter or Space to account for the scenario where\n        // a user clicks on the button, closes the menu and then opens it via keyboard. In this scenario our default logic\n        // for setting focus visibility is not triggered since there is no keyboard navigation present beforehand.\n        setFocusVisibility(true, ev.target, (_a = _this.context) === null || _a === void 0 ? void 0 : _a.registeredProviders);\n      }\n      if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {\n        // Suppose a menu, with shouldFocusOnMount: false, is open, and user wants to keyboard to the menu items\n        // We need to re-render the menu with shouldFocusOnMount as true.\n        if (!_this.state.menuHidden && _this.props.menuProps) {\n          var currentShouldFocusOnMount = _this._menuShouldFocusOnMount !== undefined ? _this._menuShouldFocusOnMount : _this.props.menuProps.shouldFocusOnMount;\n          if (!currentShouldFocusOnMount) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            _this._menuShouldFocusOnMount = true;\n            _this.forceUpdate();\n          }\n        }\n      }\n    };\n    _this._onTouchStart = function () {\n      if (_this._isSplitButton && _this._splitButtonContainer.current && !('onpointerdown' in _this._splitButtonContainer.current)) {\n        _this._handleTouchAndPointerEvent();\n      }\n    };\n    _this._onMenuClick = function (ev) {\n      var _a = _this.props,\n        onMenuClick = _a.onMenuClick,\n        menuProps = _a.menuProps;\n      if (onMenuClick) {\n        onMenuClick(ev, _this.props);\n      }\n      // focus on the container by default when the menu is opened with a click event\n      // this differentiates from a keyboard interaction triggering the click event\n      var shouldFocusOnContainer = typeof (menuProps === null || menuProps === void 0 ? void 0 : menuProps.shouldFocusOnContainer) === 'boolean' ? menuProps.shouldFocusOnContainer : ev.nativeEvent.pointerType === 'mouse';\n      if (!ev.defaultPrevented) {\n        _this._onToggleMenu(shouldFocusOnContainer);\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    };\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    warnConditionallyRequiredProps(COMPONENT_NAME, props, ['menuProps', 'onClick'], 'split', _this.props.split);\n    warnDeprecations(COMPONENT_NAME, props, {\n      rootProps: undefined,\n      description: 'secondaryText',\n      toggled: 'checked'\n    });\n    _this._labelId = getId();\n    _this._descriptionId = getId();\n    _this._ariaDescriptionId = getId();\n    _this.state = {\n      menuHidden: true\n    };\n    return _this;\n  }\n  Object.defineProperty(BaseButton.prototype, \"_isSplitButton\", {\n    get: function () {\n      return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  BaseButton.prototype.render = function () {\n    var _a;\n    var _b = this.props,\n      ariaDescription = _b.ariaDescription,\n      ariaLabel = _b.ariaLabel,\n      ariaHidden = _b.ariaHidden,\n      className = _b.className,\n      disabled = _b.disabled,\n      allowDisabledFocus = _b.allowDisabledFocus,\n      primaryDisabled = _b.primaryDisabled,\n      // eslint-disable-next-line deprecation/deprecation\n      _c = _b.secondaryText,\n      // eslint-disable-next-line deprecation/deprecation\n      secondaryText = _c === void 0 ? this.props.description : _c,\n      href = _b.href,\n      iconProps = _b.iconProps,\n      menuIconProps = _b.menuIconProps,\n      styles = _b.styles,\n      checked = _b.checked,\n      variantClassName = _b.variantClassName,\n      theme = _b.theme,\n      toggle = _b.toggle,\n      getClassNames = _b.getClassNames,\n      role = _b.role;\n    var menuHidden = this.state.menuHidden;\n    // Button is disabled if the whole button (in case of splitButton is disabled) or if the primary action is disabled\n    var isPrimaryButtonDisabled = disabled || primaryDisabled;\n    this._classNames = getClassNames ? getClassNames(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !menuHidden, !!this.props.menuProps, this.props.split, !!allowDisabledFocus) : getBaseButtonClassNames(theme, styles, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, !!this.props.menuProps, checked, !menuHidden, this.props.split);\n    var _d = this,\n      _ariaDescriptionId = _d._ariaDescriptionId,\n      _labelId = _d._labelId,\n      _descriptionId = _d._descriptionId;\n    // Anchor tag cannot be disabled hence in disabled state rendering\n    // anchor button as normal button\n    var renderAsAnchor = !isPrimaryButtonDisabled && !!href;\n    var tag = renderAsAnchor ? 'a' : 'button';\n    var nativeProps = getNativeProps(\n    // eslint-disable-next-line deprecation/deprecation\n    assign(renderAsAnchor ? {} : {\n      type: 'button'\n    }, this.props.rootProps, this.props), renderAsAnchor ? anchorProperties : buttonProperties, ['disabled' // let disabled buttons be focused and styled as disabled.\n    ]);\n    // Check for ariaLabel passed in via Button props, and fall back to aria-label passed in via native props\n    var resolvedAriaLabel = ariaLabel || nativeProps['aria-label'];\n    // Check for ariaDescription, secondaryText or aria-describedby in the native props to determine source of\n    // aria-describedby. Otherwise default to undefined so property does not appear in output.\n    var ariaDescribedBy = undefined;\n    if (ariaDescription) {\n      ariaDescribedBy = _ariaDescriptionId;\n    } else if (secondaryText && this.props.onRenderDescription !== nullRender) {\n      // for buttons like CompoundButton with a valid onRenderDescription, we need to set an ariaDescribedBy\n      // for buttons that do not render anything (via nullRender), we should not set an ariaDescribedBy\n      ariaDescribedBy = _descriptionId;\n    } else if (nativeProps['aria-describedby']) {\n      ariaDescribedBy = nativeProps['aria-describedby'];\n    }\n    // If an explicit aria-labelledby is given, use that and we're done.\n    // If any kind of description is given (which will end up as an aria-describedby attribute)\n    // and no ariaLabel is specified, set the labelledby element.\n    // Otherwise, the button is labeled implicitly by the descendent text on the button (if it exists).\n    var ariaLabelledBy = undefined;\n    if (nativeProps['aria-labelledby']) {\n      ariaLabelledBy = nativeProps['aria-labelledby'];\n    } else if (ariaDescribedBy && !resolvedAriaLabel) {\n      ariaLabelledBy = this._hasText() ? _labelId : undefined;\n    }\n    var dataIsFocusable = this.props['data-is-focusable'] === false || disabled && !allowDisabledFocus || this._isSplitButton ? false : true;\n    var isCheckboxTypeRole = role === 'menuitemcheckbox' || role === 'checkbox';\n    // if isCheckboxTypeRole, always return a checked value.\n    // Otherwise only return checked value if toggle is set to true.\n    // This is because role=\"checkbox\" always needs to have an aria-checked value\n    // but our checked prop only sets aria-pressed if we mark the button as a toggle=\"true\"\n    var checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : undefined;\n    var buttonProps = assign(nativeProps, (_a = {\n      className: this._classNames.root,\n      // eslint-disable-next-line deprecation/deprecation\n      ref: this._mergedRef(this.props.elementRef, this._buttonElement),\n      disabled: isPrimaryButtonDisabled && !allowDisabledFocus,\n      onKeyDown: this._onKeyDown,\n      onKeyPress: this._onKeyPress,\n      onKeyUp: this._onKeyUp,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onClick: this._onClick,\n      'aria-label': resolvedAriaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      'aria-disabled': isPrimaryButtonDisabled,\n      'data-is-focusable': dataIsFocusable\n    },\n    // aria-pressed attribute should only be present for toggle buttons\n    // aria-checked attribute should only be present for toggle buttons with checkbox type role\n    _a[isCheckboxTypeRole ? 'aria-checked' : 'aria-pressed'] = checkedOrPressedValue, _a));\n    if (ariaHidden) {\n      buttonProps['aria-hidden'] = true;\n    }\n    if (this._isSplitButton) {\n      return this._onRenderSplitButtonContent(tag, buttonProps);\n    } else if (this.props.menuProps) {\n      var _e = this.props.menuProps.id,\n        id = _e === void 0 ? \"\".concat(this._labelId, \"-menu\") : _e;\n      assign(buttonProps, {\n        'aria-expanded': !menuHidden,\n        'aria-controls': !menuHidden ? id : null,\n        'aria-haspopup': true\n      });\n    }\n    return this._onRenderContent(tag, buttonProps);\n  };\n  BaseButton.prototype.componentDidMount = function () {\n    // For split buttons, touching anywhere in the button should drop the dropdown, which should contain the\n    // primary action. This gives more hit target space for touch environments. We're setting the onpointerdown here,\n    // because React does not support Pointer events yet.\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      if ('onpointerdown' in this._splitButtonContainer.current) {\n        this._events.on(this._splitButtonContainer.current, 'pointerdown', this._onPointerDown, true);\n      }\n      if ('onpointerup' in this._splitButtonContainer.current && this.props.onPointerUp) {\n        this._events.on(this._splitButtonContainer.current, 'pointerup', this.props.onPointerUp, true);\n      }\n    }\n  };\n  BaseButton.prototype.componentDidUpdate = function (prevProps, prevState) {\n    // If Button's menu was closed, run onAfterMenuDismiss.\n    if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {\n      this.props.onAfterMenuDismiss();\n    }\n  };\n  BaseButton.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n    this._events.dispose();\n  };\n  BaseButton.prototype.focus = function () {\n    var _a, _b;\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      setFocusVisibility(true, undefined, (_a = this.context) === null || _a === void 0 ? void 0 : _a.registeredProviders);\n      this._splitButtonContainer.current.focus();\n    } else if (this._buttonElement.current) {\n      setFocusVisibility(true, undefined, (_b = this.context) === null || _b === void 0 ? void 0 : _b.registeredProviders);\n      this._buttonElement.current.focus();\n    }\n  };\n  BaseButton.prototype.dismissMenu = function () {\n    this._dismissMenu();\n  };\n  BaseButton.prototype.openMenu = function (shouldFocusOnContainer, shouldFocusOnMount) {\n    this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);\n  };\n  BaseButton.prototype._onRenderContent = function (tag, buttonProps) {\n    var _this = this;\n    var props = this.props;\n    var Tag = tag;\n    var menuIconProps = props.menuIconProps,\n      menuProps = props.menuProps,\n      _a = props.onRenderIcon,\n      onRenderIcon = _a === void 0 ? this._onRenderIcon : _a,\n      _b = props.onRenderAriaDescription,\n      onRenderAriaDescription = _b === void 0 ? this._onRenderAriaDescription : _b,\n      _c = props.onRenderChildren,\n      onRenderChildren = _c === void 0 ? this._onRenderChildren : _c,\n      // eslint-disable-next-line deprecation/deprecation\n      _d = props.onRenderMenu,\n      // eslint-disable-next-line deprecation/deprecation\n      onRenderMenu = _d === void 0 ? this._onRenderMenu : _d,\n      _e = props.onRenderMenuIcon,\n      onRenderMenuIcon = _e === void 0 ? this._onRenderMenuIcon : _e,\n      disabled = props.disabled;\n    var keytipProps = props.keytipProps;\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n    var Button = function (keytipAttributes) {\n      return React.createElement(Tag, __assign({}, buttonProps, keytipAttributes), React.createElement(\"span\", {\n        className: _this._classNames.flexContainer,\n        \"data-automationid\": \"splitbuttonprimary\"\n      }, onRenderIcon(props, _this._onRenderIcon), _this._onRenderTextContents(), onRenderAriaDescription(props, _this._onRenderAriaDescription), onRenderChildren(props, _this._onRenderChildren), !_this._isSplitButton && (menuProps || menuIconProps || _this.props.onRenderMenuIcon) && onRenderMenuIcon(_this.props, _this._onRenderMenuIcon), menuProps && !menuProps.doNotLayer && _this._shouldRenderMenu() && onRenderMenu(_this._getMenuProps(menuProps), _this._onRenderMenu)));\n    };\n    var Content = keytipProps ?\n    // If we're making a split button, we won't put the keytip here\n    React.createElement(KeytipData, {\n      keytipProps: !this._isSplitButton ? keytipProps : undefined,\n      ariaDescribedBy: buttonProps['aria-describedby'],\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return Button(keytipAttributes);\n    }) : Button();\n    if (menuProps && menuProps.doNotLayer) {\n      return React.createElement(React.Fragment, null, Content, this._shouldRenderMenu() && onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu));\n    }\n    return React.createElement(React.Fragment, null, Content, React.createElement(FocusRects, null));\n  };\n  /**\n   * Method to help determine if the menu's component tree should\n   * be rendered. It takes into account whether the menu is expanded,\n   * whether it is a persisted menu and whether it has been shown to the user.\n   */\n  BaseButton.prototype._shouldRenderMenu = function () {\n    var menuHidden = this.state.menuHidden;\n    // eslint-disable-next-line deprecation/deprecation\n    var _a = this.props,\n      persistMenu = _a.persistMenu,\n      renderPersistedMenuHiddenOnMount = _a.renderPersistedMenuHiddenOnMount;\n    if (!menuHidden) {\n      // Always should render a menu when it is expanded\n      return true;\n    } else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {\n      // _renderedVisibleMenu ensures that the first rendering of\n      // the menu happens on-screen, as edge's scrollbar calculations are off if done while hidden.\n      return true;\n    }\n    return false;\n  };\n  BaseButton.prototype._hasText = function () {\n    // _onRenderTextContents and _onRenderText do not perform the same checks. Below is parity with what _onRenderText\n    // used to have before the refactor that introduced this function. _onRenderTextContents does not require props.\n    // text to be undefined in order for props.children to be used as a fallback.\n    // Purely a code maintainability/reuse issue, but logged as Issue #4979.\n    return this.props.text !== null && (this.props.text !== undefined || typeof this.props.children === 'string');\n  };\n  BaseButton.prototype._getMenuProps = function (menuProps) {\n    var persistMenu = this.props.persistMenu;\n    var menuHidden = this.state.menuHidden;\n    // the accessible menu label (accessible name) has a relationship to the button.\n    // If the menu props do not specify an explicit value for aria-label or aria-labelledBy,\n    // AND the button has text, we'll set the menu aria-labelledBy to the text element id.\n    if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {\n      menuProps = __assign(__assign({}, menuProps), {\n        labelElementId: this._labelId\n      });\n    }\n    return __assign(__assign({\n      id: this._labelId + '-menu',\n      directionalHint: DirectionalHint.bottomLeftEdge\n    }, menuProps), {\n      shouldFocusOnContainer: this._menuShouldFocusOnContainer,\n      shouldFocusOnMount: this._menuShouldFocusOnMount,\n      hidden: persistMenu ? menuHidden : undefined,\n      className: css('ms-BaseButton-menuhost', menuProps.className),\n      target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current,\n      onDismiss: this._onDismissMenu\n    });\n  };\n  BaseButton.prototype._onRenderSplitButtonContent = function (tag, buttonProps) {\n    var _this = this;\n    var _a = this.props,\n      _b = _a.styles,\n      styles = _b === void 0 ? {} : _b,\n      disabled = _a.disabled,\n      allowDisabledFocus = _a.allowDisabledFocus,\n      checked = _a.checked,\n      getSplitButtonClassNames = _a.getSplitButtonClassNames,\n      primaryDisabled = _a.primaryDisabled,\n      menuProps = _a.menuProps,\n      toggle = _a.toggle,\n      role = _a.role,\n      primaryActionButtonProps = _a.primaryActionButtonProps;\n    var keytipProps = this.props.keytipProps;\n    var menuHidden = this.state.menuHidden;\n    var classNames = getSplitButtonClassNames ? getSplitButtonClassNames(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus) : styles && getBaseSplitButtonClassNames(styles, !!disabled, !menuHidden, !!checked, !!primaryDisabled);\n    assign(buttonProps, {\n      onClick: undefined,\n      onPointerDown: undefined,\n      onPointerUp: undefined,\n      tabIndex: -1,\n      'data-is-focusable': false\n    });\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n    var containerProps = getNativeProps(buttonProps, [], ['disabled']);\n    // Add additional props to apply on primary action button\n    if (primaryActionButtonProps) {\n      assign(buttonProps, primaryActionButtonProps);\n    }\n    var SplitButton = function (keytipAttributes) {\n      return React.createElement(\"div\", __assign({}, containerProps, {\n        \"data-ktp-target\": keytipAttributes ? keytipAttributes['data-ktp-target'] : undefined,\n        role: role ? role : 'button',\n        \"aria-disabled\": disabled,\n        \"aria-haspopup\": true,\n        \"aria-expanded\": !menuHidden,\n        \"aria-pressed\": toggle ? !!checked : undefined,\n        \"aria-describedby\": mergeAriaAttributeValues(buttonProps['aria-describedby'], keytipAttributes ? keytipAttributes['aria-describedby'] : undefined),\n        className: classNames && classNames.splitButtonContainer,\n        onKeyDown: _this._onSplitButtonContainerKeyDown,\n        onTouchStart: _this._onTouchStart,\n        ref: _this._splitButtonContainer,\n        \"data-is-focusable\": true,\n        onClick: !disabled && !primaryDisabled ? _this._onSplitButtonPrimaryClick : undefined,\n        tabIndex: !disabled && !primaryDisabled || allowDisabledFocus ? 0 : undefined,\n        \"aria-roledescription\": buttonProps['aria-roledescription'],\n        onFocusCapture: _this._onSplitContainerFocusCapture\n      }), React.createElement(\"span\", {\n        style: {\n          display: 'flex',\n          width: '100%'\n        }\n      }, _this._onRenderContent(tag, buttonProps), _this._onRenderSplitButtonMenuButton(classNames, keytipAttributes), _this._onRenderSplitButtonDivider(classNames)));\n    };\n    return keytipProps ? React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return SplitButton(keytipAttributes);\n    }) : SplitButton();\n  };\n  BaseButton.prototype._onRenderSplitButtonDivider = function (classNames) {\n    if (classNames && classNames.divider) {\n      var onClick = function (ev) {\n        ev.stopPropagation();\n      };\n      return React.createElement(\"span\", {\n        className: classNames.divider,\n        \"aria-hidden\": true,\n        onClick: onClick\n      });\n    }\n    return null;\n  };\n  BaseButton.prototype._onRenderSplitButtonMenuButton = function (classNames, keytipAttributes) {\n    var _a = this.props,\n      allowDisabledFocus = _a.allowDisabledFocus,\n      checked = _a.checked,\n      disabled = _a.disabled,\n      splitButtonMenuProps = _a.splitButtonMenuProps,\n      splitButtonAriaLabel = _a.splitButtonAriaLabel,\n      primaryDisabled = _a.primaryDisabled;\n    var menuHidden = this.state.menuHidden;\n    var menuIconProps = this.props.menuIconProps;\n    if (menuIconProps === undefined) {\n      menuIconProps = {\n        iconName: 'ChevronDown'\n      };\n    }\n    var splitButtonProps = __assign(__assign({}, splitButtonMenuProps), {\n      styles: classNames,\n      checked: checked,\n      disabled: disabled,\n      allowDisabledFocus: allowDisabledFocus,\n      onClick: this._onMenuClick,\n      menuProps: undefined,\n      iconProps: __assign(__assign({}, menuIconProps), {\n        className: this._classNames.menuIcon\n      }),\n      ariaLabel: splitButtonAriaLabel,\n      'aria-haspopup': true,\n      'aria-expanded': !menuHidden,\n      'data-is-focusable': false\n    });\n    // Add data-ktp-execute-target to the split button if the keytip is defined\n    return React.createElement(BaseButton, __assign({}, splitButtonProps, {\n      \"data-ktp-execute-target\": keytipAttributes ? keytipAttributes['data-ktp-execute-target'] : keytipAttributes,\n      onMouseDown: this._onMouseDown,\n      tabIndex: primaryDisabled && !allowDisabledFocus ? 0 : -1\n    }));\n  };\n  BaseButton.prototype._onPointerDown = function (ev) {\n    var onPointerDown = this.props.onPointerDown;\n    if (onPointerDown) {\n      onPointerDown(ev);\n    }\n    if (ev.pointerType === 'touch') {\n      this._handleTouchAndPointerEvent();\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n    }\n  };\n  BaseButton.prototype._handleTouchAndPointerEvent = function () {\n    var _this = this;\n    // If we already have an existing timeout from a previous touch and pointer event\n    // cancel that timeout so we can set a new one.\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n      this._lastTouchTimeoutId = undefined;\n    }\n    this._processingTouch = true;\n    this._lastTouchTimeoutId = this._async.setTimeout(function () {\n      _this._processingTouch = false;\n      _this._lastTouchTimeoutId = undefined;\n      // Touch and pointer events don't focus the button naturally,\n      // so adding an imperative focus call to guarantee this behavior.\n      // Only focus the button if a splitbutton menu is not open\n      if (_this.state.menuHidden) {\n        _this.focus();\n      }\n    }, TouchIdleDelay);\n  };\n  /**\n   * Returns if the user hits a valid keyboard key to open the menu\n   * @param ev - the keyboard event\n   * @returns True if user clicks on custom trigger key if enabled or alt + down arrow if not. False otherwise.\n   */\n  BaseButton.prototype._isValidMenuOpenKey = function (ev) {\n    if (this.props.menuTriggerKeyCode) {\n      // eslint-disable-next-line deprecation/deprecation\n      return ev.which === this.props.menuTriggerKeyCode;\n    } else if (this.props.menuProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);\n    }\n    // Note: When enter is pressed, we will let the event continue to propagate\n    // to trigger the onClick event on the button\n    return false;\n  };\n  BaseButton.defaultProps = {\n    baseClassName: 'ms-Button',\n    styles: {},\n    split: false\n  };\n  // needed to access registeredProviders when manually setting focus visibility\n  BaseButton.contextType = FocusRectsContext;\n  return BaseButton;\n}(React.Component);\nexport { BaseButton };","map":{"version":3,"names":["React","anchorProperties","assign","buttonProperties","createMergedRef","css","getId","getNativeProps","initializeComponentRef","memoizeFunction","mergeAriaAttributeValues","nullRender","portalContainsElement","setFocusVisibility","warnConditionallyRequiredProps","warnDeprecations","Async","EventGroup","FocusRects","FocusRectsContext","KeyCodes","Icon","FontIcon","ImageIcon","DirectionalHint","ContextualMenu","getBaseButtonClassNames","getSplitButtonClassNames","getBaseSplitButtonClassNames","KeytipData","composeComponentAs","TouchIdleDelay","COMPONENT_NAME","BaseButton","_super","__extends","props","_this","call","_buttonElement","createRef","_splitButtonContainer","_mergedRef","_renderedVisibleMenu","_getMemoizedMenuButtonKeytipProps","keytipProps","__assign","hasMenu","_onRenderIcon","buttonProps","defaultRender","iconProps","iconName","undefined","imageProps","className","rest","__rest","styles","createElement","_classNames","icon","_onRenderTextContents","_a","text","children","_b","secondaryText","description","_c","onRenderText","_onRenderText","_d","onRenderDescription","_onRenderDescription","textContainer","_hasText","key","_labelId","label","id","_onRenderChildren","_descriptionId","_onRenderAriaDescription","ariaDescription","screenReaderText","_ariaDescriptionId","_onRenderMenuIcon","menuIconProps","menuIcon","_onRenderMenu","menuProps","MenuType","menuAs","_onDismissMenu","ev","onDismiss","defaultPrevented","_dismissMenu","_menuShouldFocusOnMount","_menuShouldFocusOnContainer","setState","menuHidden","_openMenu","shouldFocusOnContainer","shouldFocusOnMount","_onToggleMenu","state","_onSplitContainerFocusCapture","container","current","target","focus","_onSplitButtonPrimaryClick","singleTouchTarget","_processingTouch","toggle","onClick","_onMenuClick","_onKeyDown","disabled","which","enter","space","preventDefault","stopPropagation","_onMenuKeyDown","onKeyDown","_onKeyUp","onKeyUp","_onKeyPress","onKeyPress","_onMouseUp","onMouseUp","_onMouseDown","onMouseDown","_onClick","_onSplitButtonContainerKeyDown","click","isUp","up","isDown","down","_isValidMenuOpenKey","onMenuClick","context","registeredProviders","altKey","metaKey","currentShouldFocusOnMount","forceUpdate","_onTouchStart","_isSplitButton","_handleTouchAndPointerEvent","nativeEvent","pointerType","_async","_events","split","rootProps","toggled","Object","defineProperty","prototype","get","render","ariaLabel","ariaHidden","allowDisabledFocus","primaryDisabled","href","checked","variantClassName","theme","getClassNames","role","isPrimaryButtonDisabled","renderAsAnchor","tag","nativeProps","type","resolvedAriaLabel","ariaDescribedBy","ariaLabelledBy","dataIsFocusable","isCheckboxTypeRole","checkedOrPressedValue","root","ref","elementRef","_onRenderSplitButtonContent","_e","concat","_onRenderContent","componentDidMount","on","_onPointerDown","onPointerUp","componentDidUpdate","prevProps","prevState","onAfterMenuDismiss","componentWillUnmount","dispose","dismissMenu","openMenu","Tag","onRenderIcon","onRenderAriaDescription","onRenderChildren","onRenderMenu","onRenderMenuIcon","Button","keytipAttributes","flexContainer","doNotLayer","_shouldRenderMenu","_getMenuProps","Content","Fragment","persistMenu","renderPersistedMenuHiddenOnMount","labelElementId","directionalHint","bottomLeftEdge","hidden","primaryActionButtonProps","classNames","onPointerDown","tabIndex","containerProps","SplitButton","splitButtonContainer","onTouchStart","onFocusCapture","style","display","width","_onRenderSplitButtonMenuButton","_onRenderSplitButtonDivider","divider","splitButtonMenuProps","splitButtonAriaLabel","splitButtonProps","stopImmediatePropagation","_lastTouchTimeoutId","clearTimeout","setTimeout","menuTriggerKeyCode","defaultProps","baseClassName","contextType","Component"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/components/src/components/Button/BaseButton.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  anchorProperties,\n  assign,\n  buttonProperties,\n  createMergedRef,\n  css,\n  getId,\n  getNativeProps,\n  initializeComponentRef,\n  memoizeFunction,\n  mergeAriaAttributeValues,\n  nullRender,\n  portalContainsElement,\n  setFocusVisibility,\n  warnConditionallyRequiredProps,\n  warnDeprecations,\n  Async,\n  EventGroup,\n  FocusRects,\n  FocusRectsContext,\n  KeyCodes,\n} from '../../Utilities';\nimport { Icon, FontIcon, ImageIcon } from '../../Icon';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { ContextualMenu } from '../../ContextualMenu';\nimport { getBaseButtonClassNames } from './BaseButton.classNames';\nimport { getSplitButtonClassNames as getBaseSplitButtonClassNames } from './SplitButton/SplitButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nimport type { IFocusRectsContext, IRenderFunction } from '../../Utilities';\nimport type { IContextualMenuProps } from '../../ContextualMenu';\nimport type { IButtonProps, IButton } from './Button.types';\nimport type { IButtonClassNames } from './BaseButton.classNames';\nimport type { ISplitButtonClassNames } from './SplitButton/SplitButton.classNames';\nimport type { IKeytipProps } from '../../Keytip';\nimport { composeComponentAs } from '../../Utilities';\n\n/**\n * {@docCategory Button}\n */\nexport interface IBaseButtonProps extends IButtonProps {\n  baseClassName?: string;\n  variantClassName?: string;\n}\n\n/**\n * {@docCategory Button}\n */\nexport interface IBaseButtonState {\n  menuHidden: boolean;\n}\n\nconst TouchIdleDelay = 500; /* ms */\nconst COMPONENT_NAME = 'BaseButton';\n\n/**\n * {@docCategory Button}\n */\nexport class BaseButton extends React.Component<IBaseButtonProps, IBaseButtonState> implements IButton {\n  private get _isSplitButton(): boolean {\n    return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;\n  }\n\n  public static defaultProps: Partial<IBaseButtonProps> = {\n    baseClassName: 'ms-Button',\n    styles: {},\n    split: false,\n  };\n\n  // needed to access registeredProviders when manually setting focus visibility\n  public static contextType = FocusRectsContext;\n  public context: IFocusRectsContext;\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _buttonElement = React.createRef<HTMLElement>();\n  private _splitButtonContainer = React.createRef<HTMLDivElement>();\n  private _mergedRef = createMergedRef<HTMLElement>();\n  private _labelId: string;\n  private _descriptionId: string;\n  private _ariaDescriptionId: string;\n  private _classNames: IButtonClassNames;\n  private _processingTouch: boolean;\n  private _lastTouchTimeoutId: number | undefined;\n  private _renderedVisibleMenu: boolean = false;\n\n  // These fields will be used to set corresponding props on the menu.\n  private _menuShouldFocusOnContainer: boolean | undefined;\n  private _menuShouldFocusOnMount: boolean | undefined;\n\n  private _getMemoizedMenuButtonKeytipProps = memoizeFunction((keytipProps: IKeytipProps) => {\n    return {\n      ...keytipProps,\n      hasMenu: true,\n    };\n  });\n\n  constructor(props: IBaseButtonProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    warnConditionallyRequiredProps(COMPONENT_NAME, props, ['menuProps', 'onClick'], 'split', this.props.split!);\n\n    warnDeprecations(COMPONENT_NAME, props, {\n      rootProps: undefined,\n      description: 'secondaryText',\n      toggled: 'checked',\n    });\n    this._labelId = getId();\n    this._descriptionId = getId();\n    this._ariaDescriptionId = getId();\n\n    this.state = {\n      menuHidden: true,\n    };\n  }\n\n  public render(): JSX.Element {\n    const {\n      ariaDescription,\n      ariaLabel,\n      ariaHidden,\n      className,\n      disabled,\n      allowDisabledFocus,\n      primaryDisabled,\n      // eslint-disable-next-line deprecation/deprecation\n      secondaryText = this.props.description,\n      href,\n      iconProps,\n      menuIconProps,\n      styles,\n      checked,\n      variantClassName,\n      theme,\n      toggle,\n      getClassNames,\n      role,\n    } = this.props;\n\n    const { menuHidden } = this.state;\n\n    // Button is disabled if the whole button (in case of splitButton is disabled) or if the primary action is disabled\n    const isPrimaryButtonDisabled = disabled || primaryDisabled;\n\n    this._classNames = getClassNames\n      ? getClassNames(\n          theme!,\n          className!,\n          variantClassName!,\n          iconProps && iconProps.className,\n          menuIconProps && menuIconProps.className,\n          isPrimaryButtonDisabled!,\n          checked!,\n          !menuHidden,\n          !!this.props.menuProps,\n          this.props.split,\n          !!allowDisabledFocus,\n        )\n      : getBaseButtonClassNames(\n          theme!,\n          styles!,\n          className!,\n          variantClassName!,\n          iconProps && iconProps.className,\n          menuIconProps && menuIconProps.className,\n          isPrimaryButtonDisabled!,\n          !!this.props.menuProps,\n          checked!,\n          !menuHidden,\n          this.props.split,\n        );\n\n    const { _ariaDescriptionId, _labelId, _descriptionId } = this;\n    // Anchor tag cannot be disabled hence in disabled state rendering\n    // anchor button as normal button\n    const renderAsAnchor: boolean = !isPrimaryButtonDisabled && !!href;\n    const tag = renderAsAnchor ? 'a' : 'button';\n\n    const nativeProps = getNativeProps(\n      // eslint-disable-next-line deprecation/deprecation\n      assign(renderAsAnchor ? {} : { type: 'button' }, this.props.rootProps, this.props),\n      renderAsAnchor ? anchorProperties : buttonProperties,\n      [\n        'disabled', // let disabled buttons be focused and styled as disabled.\n      ],\n    );\n\n    // Check for ariaLabel passed in via Button props, and fall back to aria-label passed in via native props\n    const resolvedAriaLabel = ariaLabel || (nativeProps as any)['aria-label'];\n\n    // Check for ariaDescription, secondaryText or aria-describedby in the native props to determine source of\n    // aria-describedby. Otherwise default to undefined so property does not appear in output.\n    let ariaDescribedBy = undefined;\n    if (ariaDescription) {\n      ariaDescribedBy = _ariaDescriptionId;\n    } else if (secondaryText && this.props.onRenderDescription !== nullRender) {\n      // for buttons like CompoundButton with a valid onRenderDescription, we need to set an ariaDescribedBy\n      // for buttons that do not render anything (via nullRender), we should not set an ariaDescribedBy\n      ariaDescribedBy = _descriptionId;\n    } else if ((nativeProps as any)['aria-describedby']) {\n      ariaDescribedBy = (nativeProps as any)['aria-describedby'];\n    }\n\n    // If an explicit aria-labelledby is given, use that and we're done.\n    // If any kind of description is given (which will end up as an aria-describedby attribute)\n    // and no ariaLabel is specified, set the labelledby element.\n    // Otherwise, the button is labeled implicitly by the descendent text on the button (if it exists).\n    let ariaLabelledBy = undefined;\n    if ((nativeProps as any)['aria-labelledby']) {\n      ariaLabelledBy = (nativeProps as any)['aria-labelledby'];\n    } else if (ariaDescribedBy && !resolvedAriaLabel) {\n      ariaLabelledBy = this._hasText() ? _labelId : undefined;\n    }\n\n    const dataIsFocusable =\n      (this.props as any)['data-is-focusable'] === false || (disabled && !allowDisabledFocus) || this._isSplitButton\n        ? false\n        : true;\n\n    const isCheckboxTypeRole = role === 'menuitemcheckbox' || role === 'checkbox';\n    // if isCheckboxTypeRole, always return a checked value.\n    // Otherwise only return checked value if toggle is set to true.\n    // This is because role=\"checkbox\" always needs to have an aria-checked value\n    // but our checked prop only sets aria-pressed if we mark the button as a toggle=\"true\"\n    const checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : undefined;\n\n    const buttonProps = assign(nativeProps, {\n      className: this._classNames.root,\n      // eslint-disable-next-line deprecation/deprecation\n      ref: this._mergedRef(this.props.elementRef, this._buttonElement),\n      disabled: isPrimaryButtonDisabled && !allowDisabledFocus,\n      onKeyDown: this._onKeyDown,\n      onKeyPress: this._onKeyPress,\n      onKeyUp: this._onKeyUp,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onClick: this._onClick,\n      'aria-label': resolvedAriaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      'aria-disabled': isPrimaryButtonDisabled,\n      'data-is-focusable': dataIsFocusable,\n      // aria-pressed attribute should only be present for toggle buttons\n      // aria-checked attribute should only be present for toggle buttons with checkbox type role\n      [isCheckboxTypeRole ? 'aria-checked' : 'aria-pressed']: checkedOrPressedValue,\n    });\n\n    if (ariaHidden) {\n      buttonProps['aria-hidden'] = true;\n    }\n\n    if (this._isSplitButton) {\n      return this._onRenderSplitButtonContent(tag, buttonProps);\n    } else if (this.props.menuProps) {\n      const { id = `${this._labelId}-menu` } = this.props.menuProps;\n      assign(buttonProps, {\n        'aria-expanded': !menuHidden,\n        'aria-controls': !menuHidden ? id : null,\n        'aria-haspopup': true,\n      });\n    }\n\n    return this._onRenderContent(tag, buttonProps);\n  }\n\n  public componentDidMount() {\n    // For split buttons, touching anywhere in the button should drop the dropdown, which should contain the\n    // primary action. This gives more hit target space for touch environments. We're setting the onpointerdown here,\n    // because React does not support Pointer events yet.\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      if ('onpointerdown' in this._splitButtonContainer.current) {\n        this._events.on(this._splitButtonContainer.current, 'pointerdown', this._onPointerDown, true);\n      }\n      if ('onpointerup' in this._splitButtonContainer.current && this.props.onPointerUp) {\n        this._events.on(this._splitButtonContainer.current, 'pointerup', this.props.onPointerUp, true);\n      }\n    }\n  }\n\n  public componentDidUpdate(prevProps: IBaseButtonProps, prevState: IBaseButtonState) {\n    // If Button's menu was closed, run onAfterMenuDismiss.\n    if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {\n      this.props.onAfterMenuDismiss();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  public focus(): void {\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      setFocusVisibility(true, undefined, this.context?.registeredProviders);\n      this._splitButtonContainer.current.focus();\n    } else if (this._buttonElement.current) {\n      setFocusVisibility(true, undefined, this.context?.registeredProviders);\n      this._buttonElement.current.focus();\n    }\n  }\n\n  public dismissMenu(): void {\n    this._dismissMenu();\n  }\n\n  public openMenu(shouldFocusOnContainer?: boolean, shouldFocusOnMount?: boolean): void {\n    this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);\n  }\n\n  private _onRenderContent(tag: any, buttonProps: IButtonProps): JSX.Element {\n    const props = this.props;\n    const Tag = tag;\n    const {\n      menuIconProps,\n      menuProps,\n      onRenderIcon = this._onRenderIcon,\n      onRenderAriaDescription = this._onRenderAriaDescription,\n      onRenderChildren = this._onRenderChildren,\n      // eslint-disable-next-line deprecation/deprecation\n      onRenderMenu = this._onRenderMenu,\n      onRenderMenuIcon = this._onRenderMenuIcon,\n      disabled,\n    } = props;\n    let { keytipProps } = props;\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    const Button = (keytipAttributes?: any): JSX.Element => (\n      <Tag {...buttonProps} {...keytipAttributes}>\n        <span className={this._classNames.flexContainer} data-automationid=\"splitbuttonprimary\">\n          {onRenderIcon(props, this._onRenderIcon)}\n          {this._onRenderTextContents()}\n          {onRenderAriaDescription(props, this._onRenderAriaDescription)}\n          {onRenderChildren(props, this._onRenderChildren)}\n          {!this._isSplitButton &&\n            (menuProps || menuIconProps || this.props.onRenderMenuIcon) &&\n            onRenderMenuIcon(this.props, this._onRenderMenuIcon)}\n          {menuProps &&\n            !menuProps.doNotLayer &&\n            this._shouldRenderMenu() &&\n            onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu)}\n        </span>\n      </Tag>\n    );\n\n    const Content = keytipProps ? (\n      // If we're making a split button, we won't put the keytip here\n      <KeytipData\n        keytipProps={!this._isSplitButton ? keytipProps : undefined}\n        ariaDescribedBy={(buttonProps as any)['aria-describedby']}\n        disabled={disabled}\n      >\n        {(keytipAttributes: any): JSX.Element => Button(keytipAttributes)}\n      </KeytipData>\n    ) : (\n      Button()\n    );\n\n    if (menuProps && menuProps.doNotLayer) {\n      return (\n        <>\n          {Content}\n          {this._shouldRenderMenu() && onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu)}\n        </>\n      );\n    }\n\n    return (\n      <>\n        {Content}\n        <FocusRects />\n      </>\n    );\n  }\n\n  /**\n   * Method to help determine if the menu's component tree should\n   * be rendered. It takes into account whether the menu is expanded,\n   * whether it is a persisted menu and whether it has been shown to the user.\n   */\n  private _shouldRenderMenu() {\n    const { menuHidden } = this.state;\n    // eslint-disable-next-line deprecation/deprecation\n    const { persistMenu, renderPersistedMenuHiddenOnMount } = this.props;\n\n    if (!menuHidden) {\n      // Always should render a menu when it is expanded\n      return true;\n    } else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {\n      // _renderedVisibleMenu ensures that the first rendering of\n      // the menu happens on-screen, as edge's scrollbar calculations are off if done while hidden.\n      return true;\n    }\n\n    return false;\n  }\n\n  private _onRenderIcon = (\n    buttonProps?: IButtonProps,\n    defaultRender?: IRenderFunction<IButtonProps>,\n  ): JSX.Element | null => {\n    const { iconProps } = this.props;\n\n    if (iconProps && (iconProps.iconName !== undefined || iconProps.imageProps)) {\n      const { className, imageProps, ...rest } = iconProps;\n\n      // If the styles prop is specified as part of iconProps, fall back to regular Icon as FontIcon and ImageIcon\n      // do not have this prop.\n      if (iconProps.styles) {\n        return <Icon className={css(this._classNames.icon, className)} imageProps={imageProps} {...rest} />;\n      }\n      if (iconProps.iconName) {\n        return <FontIcon className={css(this._classNames.icon, className)} {...rest} />;\n      }\n      if (imageProps) {\n        return <ImageIcon className={css(this._classNames.icon, className)} imageProps={imageProps} {...rest} />;\n      }\n    }\n    return null;\n  };\n\n  private _onRenderTextContents = (): JSX.Element | (JSX.Element | null)[] => {\n    const {\n      text,\n      children,\n      // eslint-disable-next-line deprecation/deprecation\n      secondaryText = this.props.description,\n      onRenderText = this._onRenderText,\n      onRenderDescription = this._onRenderDescription,\n    } = this.props;\n\n    if (text || typeof children === 'string' || secondaryText) {\n      return (\n        <span className={this._classNames.textContainer}>\n          {onRenderText(this.props, this._onRenderText)}\n          {onRenderDescription(this.props, this._onRenderDescription)}\n        </span>\n      );\n    }\n    return [onRenderText(this.props, this._onRenderText), onRenderDescription(this.props, this._onRenderDescription)];\n  };\n\n  private _onRenderText = (): JSX.Element | null => {\n    let { text } = this.props;\n    const { children } = this.props;\n\n    // For backwards compat, we should continue to take in the text content from children.\n    if (text === undefined && typeof children === 'string') {\n      text = children;\n    }\n\n    if (this._hasText()) {\n      return (\n        <span key={this._labelId} className={this._classNames.label} id={this._labelId}>\n          {text}\n        </span>\n      );\n    }\n\n    return null;\n  };\n\n  private _hasText(): boolean {\n    // _onRenderTextContents and _onRenderText do not perform the same checks. Below is parity with what _onRenderText\n    // used to have before the refactor that introduced this function. _onRenderTextContents does not require props.\n    // text to be undefined in order for props.children to be used as a fallback.\n    // Purely a code maintainability/reuse issue, but logged as Issue #4979.\n    return this.props.text !== null && (this.props.text !== undefined || typeof this.props.children === 'string');\n  }\n\n  private _onRenderChildren = (): JSX.Element | null => {\n    const { children } = this.props;\n\n    // If children is just a string, either it or the text will be rendered via onRenderLabel\n    // If children is another component, it will be rendered after text\n    if (typeof children === 'string') {\n      return null;\n    }\n\n    return children as any;\n  };\n\n  private _onRenderDescription = (props: IButtonProps) => {\n    // eslint-disable-next-line deprecation/deprecation\n    const { secondaryText = this.props.description } = props;\n\n    // ms-Button-description is only shown when the button type is compound.\n    // In other cases it will not be displayed.\n    return secondaryText ? (\n      <span key={this._descriptionId} className={this._classNames.description} id={this._descriptionId}>\n        {secondaryText}\n      </span>\n    ) : null;\n  };\n\n  private _onRenderAriaDescription = () => {\n    const { ariaDescription } = this.props;\n\n    // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,\n    // otherwise it will be assigned to descriptionSpan.\n    return ariaDescription ? (\n      <span className={this._classNames.screenReaderText} id={this._ariaDescriptionId}>\n        {ariaDescription}\n      </span>\n    ) : null;\n  };\n\n  private _onRenderMenuIcon = (props: IButtonProps): JSX.Element | null => {\n    const { menuIconProps } = this.props;\n\n    return <FontIcon iconName=\"ChevronDown\" {...menuIconProps} className={this._classNames.menuIcon} />;\n  };\n\n  private _getMenuProps(menuProps: IContextualMenuProps): IContextualMenuProps {\n    const { persistMenu } = this.props;\n    const { menuHidden } = this.state;\n\n    // the accessible menu label (accessible name) has a relationship to the button.\n    // If the menu props do not specify an explicit value for aria-label or aria-labelledBy,\n    // AND the button has text, we'll set the menu aria-labelledBy to the text element id.\n    if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {\n      menuProps = { ...menuProps, labelElementId: this._labelId };\n    }\n\n    return {\n      id: this._labelId + '-menu',\n      directionalHint: DirectionalHint.bottomLeftEdge,\n      ...menuProps,\n      shouldFocusOnContainer: this._menuShouldFocusOnContainer,\n      shouldFocusOnMount: this._menuShouldFocusOnMount,\n      hidden: persistMenu ? menuHidden : undefined,\n      className: css('ms-BaseButton-menuhost', menuProps.className),\n      target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current,\n      onDismiss: this._onDismissMenu,\n    };\n  }\n\n  private _onRenderMenu = (menuProps: IContextualMenuProps): JSX.Element => {\n    const MenuType = this.props.menuAs ? composeComponentAs(this.props.menuAs, ContextualMenu) : ContextualMenu;\n\n    return <MenuType {...menuProps} />;\n  };\n\n  private _onDismissMenu: IContextualMenuProps['onDismiss'] = ev => {\n    const { menuProps } = this.props;\n\n    if (menuProps && menuProps.onDismiss) {\n      menuProps.onDismiss(ev);\n    }\n    if (!ev || !ev.defaultPrevented) {\n      this._dismissMenu();\n    }\n  };\n\n  private _dismissMenu = (): void => {\n    this._menuShouldFocusOnMount = undefined;\n    this._menuShouldFocusOnContainer = undefined;\n    this.setState({ menuHidden: true });\n  };\n\n  private _openMenu = (shouldFocusOnContainer?: boolean, shouldFocusOnMount: boolean = true): void => {\n    if (this.props.menuProps) {\n      this._menuShouldFocusOnContainer = shouldFocusOnContainer;\n      this._menuShouldFocusOnMount = shouldFocusOnMount;\n      this._renderedVisibleMenu = true;\n      this.setState({ menuHidden: false });\n    }\n  };\n\n  private _onToggleMenu = (shouldFocusOnContainer: boolean): void => {\n    let shouldFocusOnMount = true;\n    if (this.props.menuProps && this.props.menuProps.shouldFocusOnMount === false) {\n      shouldFocusOnMount = false;\n    }\n\n    this.state.menuHidden ? this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : this._dismissMenu();\n  };\n\n  private _onRenderSplitButtonContent(tag: any, buttonProps: IButtonProps): JSX.Element {\n    const {\n      styles = {},\n      disabled,\n      allowDisabledFocus,\n      checked,\n      getSplitButtonClassNames,\n      primaryDisabled,\n      menuProps,\n      toggle,\n      role,\n      primaryActionButtonProps,\n    } = this.props;\n    let { keytipProps } = this.props;\n    const { menuHidden } = this.state;\n\n    const classNames = getSplitButtonClassNames\n      ? getSplitButtonClassNames(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus)\n      : styles && getBaseSplitButtonClassNames(styles!, !!disabled, !menuHidden, !!checked, !!primaryDisabled);\n\n    assign(buttonProps, {\n      onClick: undefined,\n      onPointerDown: undefined,\n      onPointerUp: undefined,\n      tabIndex: -1,\n      'data-is-focusable': false,\n    });\n\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    const containerProps = getNativeProps<React.HTMLAttributes<HTMLSpanElement>>(buttonProps, [], ['disabled']);\n\n    // Add additional props to apply on primary action button\n    if (primaryActionButtonProps) {\n      assign(buttonProps, primaryActionButtonProps);\n    }\n\n    const SplitButton = (keytipAttributes?: any): JSX.Element => (\n      <div\n        {...containerProps}\n        data-ktp-target={keytipAttributes ? keytipAttributes['data-ktp-target'] : undefined}\n        role={role ? role : 'button'}\n        aria-disabled={disabled}\n        aria-haspopup={true}\n        aria-expanded={!menuHidden}\n        aria-pressed={toggle ? !!checked : undefined} // should only be present for toggle buttons\n        aria-describedby={mergeAriaAttributeValues(\n          buttonProps['aria-describedby'],\n          keytipAttributes ? keytipAttributes['aria-describedby'] : undefined,\n        )}\n        className={classNames && classNames.splitButtonContainer}\n        onKeyDown={this._onSplitButtonContainerKeyDown}\n        onTouchStart={this._onTouchStart}\n        ref={this._splitButtonContainer}\n        data-is-focusable={true}\n        onClick={!disabled && !primaryDisabled ? this._onSplitButtonPrimaryClick : undefined}\n        tabIndex={(!disabled && !primaryDisabled) || allowDisabledFocus ? 0 : undefined}\n        aria-roledescription={buttonProps['aria-roledescription']}\n        onFocusCapture={this._onSplitContainerFocusCapture}\n      >\n        <span style={{ display: 'flex', width: '100%' }}>\n          {this._onRenderContent(tag, buttonProps)}\n          {this._onRenderSplitButtonMenuButton(classNames, keytipAttributes)}\n          {this._onRenderSplitButtonDivider(classNames)}\n        </span>\n      </div>\n    );\n\n    return keytipProps ? (\n      <KeytipData keytipProps={keytipProps} disabled={disabled}>\n        {(keytipAttributes: any): JSX.Element => SplitButton(keytipAttributes)}\n      </KeytipData>\n    ) : (\n      SplitButton()\n    );\n  }\n\n  private _onSplitContainerFocusCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    const container = this._splitButtonContainer.current;\n\n    // If the target is coming from the portal we do not need to set focus on the container.\n    if (!container || (ev.target && portalContainsElement(ev.target, container))) {\n      return;\n    }\n\n    // We should never be able to focus the individual buttons in a split button. Focus\n    // should always remain on the container.\n    container.focus();\n  };\n\n  private _onSplitButtonPrimaryClick = (ev: React.MouseEvent<HTMLDivElement>) => {\n    if (!this.state.menuHidden) {\n      this._dismissMenu();\n    }\n\n    // toggle split buttons need two separate targets, even for touch\n    const singleTouchTarget = this._processingTouch && !this.props.toggle;\n\n    if (!singleTouchTarget && this.props.onClick) {\n      this.props.onClick(ev);\n    } else if (singleTouchTarget) {\n      this._onMenuClick(ev);\n    }\n  };\n\n  private _onRenderSplitButtonDivider(classNames: ISplitButtonClassNames | undefined): JSX.Element | null {\n    if (classNames && classNames.divider) {\n      const onClick = (ev: React.MouseEvent<HTMLSpanElement, MouseEvent>) => {\n        ev.stopPropagation();\n      };\n      return <span className={classNames.divider} aria-hidden={true} onClick={onClick} />;\n    }\n    return null;\n  }\n\n  private _onRenderSplitButtonMenuButton(\n    classNames: ISplitButtonClassNames | undefined,\n    keytipAttributes: any,\n  ): JSX.Element {\n    const { allowDisabledFocus, checked, disabled, splitButtonMenuProps, splitButtonAriaLabel, primaryDisabled } =\n      this.props;\n    const { menuHidden } = this.state;\n    let menuIconProps = this.props.menuIconProps;\n\n    if (menuIconProps === undefined) {\n      menuIconProps = {\n        iconName: 'ChevronDown',\n      };\n    }\n\n    const splitButtonProps = {\n      ...splitButtonMenuProps,\n      styles: classNames,\n      checked,\n      disabled,\n      allowDisabledFocus,\n      onClick: this._onMenuClick,\n      menuProps: undefined,\n      iconProps: { ...menuIconProps, className: this._classNames.menuIcon },\n      ariaLabel: splitButtonAriaLabel,\n      'aria-haspopup': true,\n      'aria-expanded': !menuHidden,\n      'data-is-focusable': false,\n    };\n\n    // Add data-ktp-execute-target to the split button if the keytip is defined\n    return (\n      <BaseButton\n        {...splitButtonProps}\n        data-ktp-execute-target={keytipAttributes ? keytipAttributes['data-ktp-execute-target'] : keytipAttributes}\n        onMouseDown={this._onMouseDown}\n        tabIndex={primaryDisabled && !allowDisabledFocus ? 0 : -1}\n      />\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>) => {\n    // explicity cancelling event so click won't fire after this\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    } else if (!this.props.disabled) {\n      if (this.props.menuProps) {\n        this._onMenuKeyDown(ev);\n      } else if (this.props.onKeyDown !== undefined) {\n        this.props.onKeyDown(ev); // not cancelling event because it's not disabled\n      }\n    }\n  };\n\n  private _onKeyUp = (\n    ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled && this.props.onKeyUp !== undefined) {\n      this.props.onKeyUp(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onKeyPress = (\n    ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    // eslint-disable-next-line deprecation/deprecation\n    if (!this.props.disabled && this.props.onKeyPress !== undefined) {\n      // eslint-disable-next-line deprecation/deprecation\n      this.props.onKeyPress(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onMouseUp = (\n    ev: React.MouseEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled && this.props.onMouseUp !== undefined) {\n      this.props.onMouseUp(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onMouseDown = (\n    ev: React.MouseEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled && this.props.onMouseDown !== undefined) {\n      this.props.onMouseDown(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onClick = (\n    ev: React.MouseEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement | HTMLSpanElement>,\n  ) => {\n    if (!this.props.disabled) {\n      if (this.props.menuProps) {\n        this._onMenuClick(ev);\n      } else if (this.props.onClick !== undefined) {\n        this.props.onClick(ev); // not cancelling event because it's not disabled\n      }\n    }\n  };\n\n  private _onSplitButtonContainerKeyDown = (ev: React.KeyboardEvent<HTMLDivElement>) => {\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n      if (this._buttonElement.current) {\n        this._buttonElement.current.click();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    } else {\n      this._onMenuKeyDown(ev);\n    }\n  };\n\n  private _onMenuKeyDown = (ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>) => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const isUp = ev.which === KeyCodes.up;\n    // eslint-disable-next-line deprecation/deprecation\n    const isDown = ev.which === KeyCodes.down;\n\n    if (!ev.defaultPrevented && this._isValidMenuOpenKey(ev)) {\n      const { onMenuClick } = this.props;\n      if (onMenuClick) {\n        onMenuClick(ev, this.props);\n      }\n\n      this._onToggleMenu(false);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n      // We manually set the focus visibility to true if opening via Enter or Space to account for the scenario where\n      // a user clicks on the button, closes the menu and then opens it via keyboard. In this scenario our default logic\n      // for setting focus visibility is not triggered since there is no keyboard navigation present beforehand.\n      setFocusVisibility(true, ev.target as Element, this.context?.registeredProviders);\n    }\n\n    if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {\n      // Suppose a menu, with shouldFocusOnMount: false, is open, and user wants to keyboard to the menu items\n      // We need to re-render the menu with shouldFocusOnMount as true.\n\n      if (!this.state.menuHidden && this.props.menuProps) {\n        const currentShouldFocusOnMount =\n          this._menuShouldFocusOnMount !== undefined\n            ? this._menuShouldFocusOnMount\n            : this.props.menuProps.shouldFocusOnMount;\n        if (!currentShouldFocusOnMount) {\n          ev.preventDefault();\n          ev.stopPropagation();\n          this._menuShouldFocusOnMount = true;\n          this.forceUpdate();\n        }\n      }\n    }\n  };\n\n  private _onTouchStart: () => void = () => {\n    if (\n      this._isSplitButton &&\n      this._splitButtonContainer.current &&\n      !('onpointerdown' in this._splitButtonContainer.current)\n    ) {\n      this._handleTouchAndPointerEvent();\n    }\n  };\n\n  private _onPointerDown(\n    ev: PointerEvent &\n      React.PointerEvent<HTMLAnchorElement | HTMLButtonElement | HTMLDivElement | BaseButton | HTMLSpanElement>,\n  ) {\n    const { onPointerDown } = this.props;\n    if (onPointerDown) {\n      onPointerDown(ev);\n    }\n\n    if (ev.pointerType === 'touch') {\n      this._handleTouchAndPointerEvent();\n\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n    }\n  }\n\n  private _handleTouchAndPointerEvent() {\n    // If we already have an existing timeout from a previous touch and pointer event\n    // cancel that timeout so we can set a new one.\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n      this._lastTouchTimeoutId = undefined;\n    }\n    this._processingTouch = true;\n\n    this._lastTouchTimeoutId = this._async.setTimeout(() => {\n      this._processingTouch = false;\n      this._lastTouchTimeoutId = undefined;\n\n      // Touch and pointer events don't focus the button naturally,\n      // so adding an imperative focus call to guarantee this behavior.\n      // Only focus the button if a splitbutton menu is not open\n      if (this.state.menuHidden) {\n        this.focus();\n      }\n    }, TouchIdleDelay);\n  }\n\n  /**\n   * Returns if the user hits a valid keyboard key to open the menu\n   * @param ev - the keyboard event\n   * @returns True if user clicks on custom trigger key if enabled or alt + down arrow if not. False otherwise.\n   */\n  private _isValidMenuOpenKey(\n    ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>,\n  ): boolean {\n    if (this.props.menuTriggerKeyCode) {\n      // eslint-disable-next-line deprecation/deprecation\n      return ev.which === this.props.menuTriggerKeyCode;\n    } else if (this.props.menuProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);\n    }\n\n    // Note: When enter is pressed, we will let the event continue to propagate\n    // to trigger the onClick event on the button\n    return false;\n  }\n\n  private _onMenuClick = (\n    ev: React.MouseEvent<HTMLDivElement | HTMLButtonElement | HTMLAnchorElement | HTMLSpanElement>,\n  ) => {\n    const { onMenuClick, menuProps } = this.props;\n    if (onMenuClick) {\n      onMenuClick(ev, this.props);\n    }\n\n    // focus on the container by default when the menu is opened with a click event\n    // this differentiates from a keyboard interaction triggering the click event\n    const shouldFocusOnContainer =\n      typeof menuProps?.shouldFocusOnContainer === 'boolean'\n        ? menuProps.shouldFocusOnContainer\n        : (ev.nativeEvent as PointerEvent).pointerType === 'mouse';\n\n    if (!ev.defaultPrevented) {\n      this._onToggleMenu(shouldFocusOnContainer);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}