{"ast":null,"code":"import * as React from 'react';\nimport { useConst } from './useConst';\nexport function useControllableValue(controlledValue, defaultUncontrolledValue, onChange) {\n  var _a = React.useState(defaultUncontrolledValue),\n    value = _a[0],\n    setValue = _a[1];\n  var isControlled = useConst(controlledValue !== undefined);\n  var currentValue = isControlled ? controlledValue : value;\n  // Duplicate the current value and onChange in refs so they're accessible from\n  // setValueOrCallOnChange without creating a new callback every time\n  var valueRef = React.useRef(currentValue);\n  var onChangeRef = React.useRef(onChange);\n  React.useEffect(function () {\n    valueRef.current = currentValue;\n    onChangeRef.current = onChange;\n  });\n  // To match the behavior of the setter returned by React.useState, this callback's identity\n  // should never change. This means it MUST NOT directly reference variables that can change.\n  var setValueOrCallOnChange = useConst(function () {\n    return function (update, ev) {\n      // Assuming here that TValue is not a function, because a controllable value will typically\n      // be something a user can enter as input\n      var newValue = typeof update === 'function' ? update(valueRef.current) : update;\n      if (onChangeRef.current) {\n        onChangeRef.current(ev, newValue);\n      }\n      if (!isControlled) {\n        setValue(newValue);\n      }\n    };\n  });\n  return [currentValue, setValueOrCallOnChange];\n}","map":{"version":3,"names":["React","useConst","useControllableValue","controlledValue","defaultUncontrolledValue","onChange","_a","useState","value","setValue","isControlled","undefined","currentValue","valueRef","useRef","onChangeRef","useEffect","current","setValueOrCallOnChange","update","ev","newValue"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react-hooks/src/useControllableValue.ts"],"sourcesContent":["import * as React from 'react';\nimport { useConst } from './useConst';\n\nexport type ChangeCallback<\n  TElement extends HTMLElement,\n  TValue,\n  TEvent extends React.SyntheticEvent<TElement> | undefined,\n> = (ev: TEvent, newValue: TValue | undefined) => void;\n\n/**\n * Hook to manage a value that could be either controlled or uncontrolled, such as a checked state or\n * text box string.\n * @param controlledValue - The controlled value passed in the props. This value will always be used if provided,\n * and the internal state will be updated to reflect it.\n * @param defaultUncontrolledValue - Initial value for the internal state in the uncontrolled case.\n * @returns An array of the current value and an updater callback. Like `React.useState`, the updater\n * callback always has the same identity, and it can take either a new value, or a function which\n * is passed the previous value and returns the new value.\n * @see https://reactjs.org/docs/uncontrolled-components.html\n */\nexport function useControllableValue<TValue, TElement extends HTMLElement>(\n  controlledValue: TValue | undefined,\n  defaultUncontrolledValue: TValue | undefined,\n): Readonly<[TValue | undefined, (update: React.SetStateAction<TValue | undefined>) => void]>;\nexport function useControllableValue<\n  TValue,\n  TElement extends HTMLElement,\n  TEvent extends React.SyntheticEvent<TElement> | undefined,\n>(\n  controlledValue: TValue | undefined,\n  defaultUncontrolledValue: TValue | undefined,\n  onChange: ChangeCallback<TElement, TValue, TEvent> | undefined,\n): Readonly<\n  [TValue | undefined, (update: React.SetStateAction<TValue | undefined>, ev?: React.FormEvent<TElement>) => void]\n>;\nexport function useControllableValue<\n  TValue,\n  TElement extends HTMLElement,\n  TEvent extends React.SyntheticEvent<TElement> | undefined,\n>(\n  controlledValue: TValue | undefined,\n  defaultUncontrolledValue: TValue | undefined,\n  onChange?: ChangeCallback<TElement, TValue, TEvent>,\n) {\n  const [value, setValue] = React.useState<TValue | undefined>(defaultUncontrolledValue);\n  const isControlled = useConst<boolean>(controlledValue !== undefined);\n  const currentValue = isControlled ? controlledValue : value;\n\n  // Duplicate the current value and onChange in refs so they're accessible from\n  // setValueOrCallOnChange without creating a new callback every time\n  const valueRef = React.useRef(currentValue);\n  const onChangeRef = React.useRef(onChange);\n  React.useEffect(() => {\n    valueRef.current = currentValue;\n    onChangeRef.current = onChange;\n  });\n\n  // To match the behavior of the setter returned by React.useState, this callback's identity\n  // should never change. This means it MUST NOT directly reference variables that can change.\n  const setValueOrCallOnChange = useConst(() => (update: React.SetStateAction<TValue | undefined>, ev?: TEvent) => {\n    // Assuming here that TValue is not a function, because a controllable value will typically\n    // be something a user can enter as input\n    const newValue = typeof update === 'function' ? (update as Function)(valueRef.current) : update;\n\n    if (onChangeRef.current) {\n      onChangeRef.current(ev!, newValue);\n    }\n\n    if (!isControlled) {\n      setValue(newValue);\n    }\n  });\n\n  return [currentValue, setValueOrCallOnChange] as const;\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,QAAQ,QAAQ,YAAY;AAkCrC,OAAM,SAAUC,oBAAoBA,CAKlCC,eAAmC,EACnCC,wBAA4C,EAC5CC,QAAmD;EAE7C,IAAAC,EAAA,GAAoBN,KAAK,CAACO,QAAQ,CAAqBH,wBAAwB,CAAC;IAA/EI,KAAK,GAAAF,EAAA;IAAEG,QAAQ,GAAAH,EAAA,GAAgE;EACtF,IAAMI,YAAY,GAAGT,QAAQ,CAAUE,eAAe,KAAKQ,SAAS,CAAC;EACrE,IAAMC,YAAY,GAAGF,YAAY,GAAGP,eAAe,GAAGK,KAAK;EAE3D;EACA;EACA,IAAMK,QAAQ,GAAGb,KAAK,CAACc,MAAM,CAACF,YAAY,CAAC;EAC3C,IAAMG,WAAW,GAAGf,KAAK,CAACc,MAAM,CAACT,QAAQ,CAAC;EAC1CL,KAAK,CAACgB,SAAS,CAAC;IACdH,QAAQ,CAACI,OAAO,GAAGL,YAAY;IAC/BG,WAAW,CAACE,OAAO,GAAGZ,QAAQ;EAChC,CAAC,CAAC;EAEF;EACA;EACA,IAAMa,sBAAsB,GAAGjB,QAAQ,CAAC;IAAM,iBAACkB,MAAgD,EAAEC,EAAW;MAC1G;MACA;MACA,IAAMC,QAAQ,GAAG,OAAOF,MAAM,KAAK,UAAU,GAAIA,MAAmB,CAACN,QAAQ,CAACI,OAAO,CAAC,GAAGE,MAAM;MAE/F,IAAIJ,WAAW,CAACE,OAAO,EAAE;QACvBF,WAAW,CAACE,OAAO,CAACG,EAAG,EAAEC,QAAQ,CAAC;;MAGpC,IAAI,CAACX,YAAY,EAAE;QACjBD,QAAQ,CAACY,QAAQ,CAAC;;IAEtB,CAAC;EAZ6C,CAY7C,CAAC;EAEF,OAAO,CAACT,YAAY,EAAEM,sBAAsB,CAAU;AACxD"},"metadata":{},"sourceType":"module","externalDependencies":[]}