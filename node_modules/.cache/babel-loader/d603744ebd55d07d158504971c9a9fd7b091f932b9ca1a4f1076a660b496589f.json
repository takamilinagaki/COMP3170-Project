{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async } from './Async';\nimport { EventGroup } from './EventGroup';\nimport { warnConditionallyRequiredProps } from './warn/warnConditionallyRequiredProps';\nimport { warnMutuallyExclusive } from './warn/warnMutuallyExclusive';\nimport { warnDeprecations } from './warn/warnDeprecations';\n/**\n * BaseComponent class, which provides basic helpers for all components.\n *\n * @public\n * {@docCategory BaseComponent}\n *\n * @deprecated Do not use. We are moving away from class component.\n */\nvar BaseComponent = /** @class */function (_super) {\n  __extends(BaseComponent, _super);\n  /**\n   * BaseComponent constructor\n   * @param props - The props for the component.\n   * @param context - The context for the component.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function BaseComponent(props, context) {\n    var _this = _super.call(this, props, context) || this;\n    // eslint-disable-next-line deprecation/deprecation\n    _makeAllSafe(_this, BaseComponent.prototype, ['componentDidMount', 'shouldComponentUpdate', 'getSnapshotBeforeUpdate', 'render', 'componentDidUpdate', 'componentWillUnmount']);\n    return _this;\n  }\n  /**\n   * When the component receives props, make sure the componentRef is updated.\n   */\n  BaseComponent.prototype.componentDidUpdate = function (prevProps, prevState) {\n    this._updateComponentRef(prevProps, this.props);\n  };\n  /**\n   * When the component has mounted, update the componentRef.\n   */\n  BaseComponent.prototype.componentDidMount = function () {\n    this._setComponentRef(this.props.componentRef, this);\n  };\n  /**\n   * If we have disposables, dispose them automatically on unmount.\n   */\n  BaseComponent.prototype.componentWillUnmount = function () {\n    this._setComponentRef(this.props.componentRef, null);\n    if (this.__disposables) {\n      for (var i = 0, len = this._disposables.length; i < len; i++) {\n        var disposable = this.__disposables[i];\n        if (disposable.dispose) {\n          disposable.dispose();\n        }\n      }\n      this.__disposables = null;\n    }\n  };\n  Object.defineProperty(BaseComponent.prototype, \"className\", {\n    /**\n     * Gets the object's class name.\n     */\n    get: function () {\n      if (!this.__className) {\n        var funcNameRegex = /function (.{1,})\\(/;\n        var results = funcNameRegex.exec(this.constructor.toString());\n        this.__className = results && results.length > 1 ? results[1] : '';\n      }\n      return this.__className;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseComponent.prototype, \"_disposables\", {\n    /**\n     * Allows subclasses to push things to this._disposables to be auto disposed.\n     */\n    get: function () {\n      if (!this.__disposables) {\n        this.__disposables = [];\n      }\n      return this.__disposables;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseComponent.prototype, \"_async\", {\n    /**\n     * Gets the async instance associated with the component, created on demand. The async instance gives\n     * subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks\n     * will be cleared/ignored automatically after unmounting. The helpers within the async object also\n     * preserve the this pointer so that you don't need to \"bind\" the callbacks.\n     */\n    get: function () {\n      if (!this.__async) {\n        this.__async = new Async(this);\n        this._disposables.push(this.__async);\n      }\n      return this.__async;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseComponent.prototype, \"_events\", {\n    /**\n     * Gets the event group instance assocaited with the component, created on demand. The event instance\n     * provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks\n     * will be automatically disconnected after unmounting. The helpers within the events object also\n     * preserve the this reference so that you don't need to \"bind\" the callbacks.\n     */\n    get: function () {\n      if (!this.__events) {\n        this.__events = new EventGroup(this);\n        this._disposables.push(this.__events);\n      }\n      return this.__events;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Helper to return a memoized ref resolver function.\n   * @param refName - Name of the member to assign the ref to.\n   * @returns A function instance keyed from the given refname.\n   * @deprecated Use `createRef` from React.createRef.\n   */\n  BaseComponent.prototype._resolveRef = function (refName) {\n    var _this = this;\n    if (!this.__resolves) {\n      this.__resolves = {};\n    }\n    if (!this.__resolves[refName]) {\n      this.__resolves[refName] = function (ref) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return _this[refName] = ref;\n      };\n    }\n    return this.__resolves[refName];\n  };\n  /**\n   * Updates the componentRef (by calling it with \"this\" when necessary.)\n   */\n  BaseComponent.prototype._updateComponentRef = function (currentProps, newProps) {\n    if (newProps === void 0) {\n      newProps = {};\n    }\n    // currentProps *should* always be defined, but verify that just in case a subclass is manually\n    // calling a lifecycle method with no parameters (which has happened) or other odd usage.\n    if (currentProps && newProps && currentProps.componentRef !== newProps.componentRef) {\n      this._setComponentRef(currentProps.componentRef, null);\n      this._setComponentRef(newProps.componentRef, this);\n    }\n  };\n  /**\n   * Warns when a deprecated props are being used.\n   *\n   * @param deprecationMap - The map of deprecations, where key is the prop name and the value is\n   * either null or a replacement prop name.\n   */\n  BaseComponent.prototype._warnDeprecations = function (deprecationMap) {\n    warnDeprecations(this.className, this.props, deprecationMap);\n  };\n  /**\n   * Warns when props which are mutually exclusive with each other are both used.\n   *\n   * @param mutuallyExclusiveMap - The map of mutually exclusive props.\n   */\n  BaseComponent.prototype._warnMutuallyExclusive = function (mutuallyExclusiveMap) {\n    warnMutuallyExclusive(this.className, this.props, mutuallyExclusiveMap);\n  };\n  /**\n   * Warns when props are required if a condition is met.\n   *\n   * @param requiredProps - The name of the props that are required when the condition is met.\n   * @param conditionalPropName - The name of the prop that the condition is based on.\n   * @param condition - Whether the condition is met.\n   */\n  BaseComponent.prototype._warnConditionallyRequiredProps = function (requiredProps, conditionalPropName, condition) {\n    warnConditionallyRequiredProps(this.className, this.props, requiredProps, conditionalPropName, condition);\n  };\n  BaseComponent.prototype._setComponentRef = function (ref, value) {\n    if (!this._skipComponentRefResolution && ref) {\n      if (typeof ref === 'function') {\n        ref(value);\n      }\n      if (typeof ref === 'object') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ref.current = value;\n      }\n    }\n  };\n  return BaseComponent;\n}(React.Component);\nexport { BaseComponent };\n/**\n * Helper to override a given method with a wrapper method that can try/catch the original, but also\n * ensures that the BaseComponent's methods are called before the subclass's. This ensures that\n * componentWillUnmount in the base is called and that things in the _disposables array are disposed.\n */\n// eslint-disable-next-line deprecation/deprecation\nfunction _makeAllSafe(obj, prototype, methodNames) {\n  for (var i = 0, len = methodNames.length; i < len; i++) {\n    _makeSafe(obj, prototype, methodNames[i]);\n  }\n}\n// eslint-disable-next-line deprecation/deprecation\nfunction _makeSafe(obj, prototype, methodName) {\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  var classMethod = obj[methodName];\n  var prototypeMethod = prototype[methodName];\n  if (classMethod || prototypeMethod) {\n    obj[methodName] = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      /* eslint-enable @typescript-eslint/no-explicit-any */\n      var retVal;\n      if (prototypeMethod) {\n        retVal = prototypeMethod.apply(this, args);\n      }\n      if (classMethod !== prototypeMethod) {\n        retVal = classMethod.apply(this, args);\n      }\n      return retVal;\n    };\n  }\n}\n/**\n * Simple constant function for returning null, used to render empty templates in JSX.\n *\n * @public\n */\nexport function nullRender() {\n  return null;\n}","map":{"version":3,"names":["React","Async","EventGroup","warnConditionallyRequiredProps","warnMutuallyExclusive","warnDeprecations","BaseComponent","_super","__extends","props","context","_this","call","_makeAllSafe","prototype","componentDidUpdate","prevProps","prevState","_updateComponentRef","componentDidMount","_setComponentRef","componentRef","componentWillUnmount","__disposables","i","len","_disposables","length","disposable","dispose","Object","defineProperty","get","__className","funcNameRegex","results","exec","constructor","toString","__async","push","__events","_resolveRef","refName","__resolves","ref","currentProps","newProps","_warnDeprecations","deprecationMap","className","_warnMutuallyExclusive","mutuallyExclusiveMap","_warnConditionallyRequiredProps","requiredProps","conditionalPropName","condition","value","_skipComponentRefResolution","current","Component","obj","methodNames","_makeSafe","methodName","classMethod","prototypeMethod","args","_i","arguments","retVal","apply","nullRender"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/utilities/src/BaseComponent.ts"],"sourcesContent":["import * as React from 'react';\nimport { Async } from './Async';\nimport { EventGroup } from './EventGroup';\nimport { warnConditionallyRequiredProps } from './warn/warnConditionallyRequiredProps';\nimport { warnMutuallyExclusive } from './warn/warnMutuallyExclusive';\nimport { warnDeprecations } from './warn/warnDeprecations';\nimport type { IDisposable } from './IDisposable';\nimport type { ISettingsMap } from './warn/warn';\nimport type { IRefObject } from './createRef';\nimport type { IBaseProps } from './BaseComponent.types';\n\n/**\n * BaseComponent class, which provides basic helpers for all components.\n *\n * @public\n * {@docCategory BaseComponent}\n *\n * @deprecated Do not use. We are moving away from class component.\n */\nexport class BaseComponent<TProps extends IBaseProps = {}, TState = {}> extends React.Component<TProps, TState> {\n  /**\n   * @deprecated Use React's error boundaries instead.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public static onError: (errorMessage?: string, ex?: any) => void;\n\n  /**\n   * Controls whether the componentRef prop will be resolved by this component instance. If you are\n   * implementing a passthrough (higher-order component), you would set this to false and pass through\n   * the props to the inner component, allowing it to resolve the componentRef.\n   */\n  protected _skipComponentRefResolution!: boolean;\n\n  private __async!: Async;\n  private __events!: EventGroup;\n  private __disposables!: IDisposable[] | null;\n  private __resolves!: { [name: string]: (ref: React.ReactNode) => React.ReactNode };\n  private __className!: string;\n\n  /**\n   * BaseComponent constructor\n   * @param props - The props for the component.\n   * @param context - The context for the component.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(props: TProps, context?: any) {\n    super(props, context);\n\n    // eslint-disable-next-line deprecation/deprecation\n    _makeAllSafe(this, BaseComponent.prototype, [\n      'componentDidMount',\n      'shouldComponentUpdate',\n      'getSnapshotBeforeUpdate',\n      'render',\n      'componentDidUpdate',\n      'componentWillUnmount',\n    ]);\n  }\n\n  /**\n   * When the component receives props, make sure the componentRef is updated.\n   */\n  public componentDidUpdate(prevProps: TProps, prevState: TState): void {\n    this._updateComponentRef(prevProps, this.props);\n  }\n\n  /**\n   * When the component has mounted, update the componentRef.\n   */\n  public componentDidMount(): void {\n    this._setComponentRef(this.props.componentRef, this);\n  }\n\n  /**\n   * If we have disposables, dispose them automatically on unmount.\n   */\n  public componentWillUnmount(): void {\n    this._setComponentRef(this.props.componentRef, null);\n\n    if (this.__disposables) {\n      for (let i = 0, len = this._disposables.length; i < len; i++) {\n        let disposable = this.__disposables[i];\n\n        if (disposable.dispose) {\n          disposable.dispose();\n        }\n      }\n      this.__disposables = null;\n    }\n  }\n\n  /**\n   * Gets the object's class name.\n   */\n  public get className(): string {\n    if (!this.__className) {\n      let funcNameRegex = /function (.{1,})\\(/;\n      let results = funcNameRegex.exec(this.constructor.toString());\n\n      this.__className = results && results.length > 1 ? results[1] : '';\n    }\n\n    return this.__className;\n  }\n\n  /**\n   * Allows subclasses to push things to this._disposables to be auto disposed.\n   */\n  protected get _disposables(): IDisposable[] {\n    if (!this.__disposables) {\n      this.__disposables = [];\n    }\n    return this.__disposables;\n  }\n\n  /**\n   * Gets the async instance associated with the component, created on demand. The async instance gives\n   * subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks\n   * will be cleared/ignored automatically after unmounting. The helpers within the async object also\n   * preserve the this pointer so that you don't need to \"bind\" the callbacks.\n   */\n  protected get _async(): Async {\n    if (!this.__async) {\n      this.__async = new Async(this);\n      this._disposables.push(this.__async);\n    }\n\n    return this.__async;\n  }\n\n  /**\n   * Gets the event group instance assocaited with the component, created on demand. The event instance\n   * provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks\n   * will be automatically disconnected after unmounting. The helpers within the events object also\n   * preserve the this reference so that you don't need to \"bind\" the callbacks.\n   */\n  protected get _events(): EventGroup {\n    if (!this.__events) {\n      this.__events = new EventGroup(this);\n      this._disposables.push(this.__events);\n    }\n\n    return this.__events;\n  }\n\n  /**\n   * Helper to return a memoized ref resolver function.\n   * @param refName - Name of the member to assign the ref to.\n   * @returns A function instance keyed from the given refname.\n   * @deprecated Use `createRef` from React.createRef.\n   */\n  protected _resolveRef(refName: string): (ref: React.ReactNode) => React.ReactNode {\n    if (!this.__resolves) {\n      this.__resolves = {};\n    }\n\n    if (!this.__resolves[refName]) {\n      this.__resolves[refName] = (ref: React.ReactNode) => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return ((this as any)[refName] = ref);\n      };\n    }\n\n    return this.__resolves[refName];\n  }\n\n  /**\n   * Updates the componentRef (by calling it with \"this\" when necessary.)\n   */\n  protected _updateComponentRef(currentProps: IBaseProps, newProps: IBaseProps = {}): void {\n    // currentProps *should* always be defined, but verify that just in case a subclass is manually\n    // calling a lifecycle method with no parameters (which has happened) or other odd usage.\n    if (currentProps && newProps && currentProps.componentRef !== newProps.componentRef) {\n      this._setComponentRef(currentProps.componentRef, null);\n      this._setComponentRef(newProps.componentRef, this);\n    }\n  }\n\n  /**\n   * Warns when a deprecated props are being used.\n   *\n   * @param deprecationMap - The map of deprecations, where key is the prop name and the value is\n   * either null or a replacement prop name.\n   */\n  protected _warnDeprecations(deprecationMap: ISettingsMap<TProps>): void {\n    warnDeprecations(this.className, this.props, deprecationMap);\n  }\n\n  /**\n   * Warns when props which are mutually exclusive with each other are both used.\n   *\n   * @param mutuallyExclusiveMap - The map of mutually exclusive props.\n   */\n  protected _warnMutuallyExclusive(mutuallyExclusiveMap: ISettingsMap<TProps>): void {\n    warnMutuallyExclusive(this.className, this.props, mutuallyExclusiveMap);\n  }\n\n  /**\n   * Warns when props are required if a condition is met.\n   *\n   * @param requiredProps - The name of the props that are required when the condition is met.\n   * @param conditionalPropName - The name of the prop that the condition is based on.\n   * @param condition - Whether the condition is met.\n   */\n  protected _warnConditionallyRequiredProps(\n    requiredProps: string[],\n    conditionalPropName: string,\n    condition: boolean,\n  ): void {\n    warnConditionallyRequiredProps(this.className, this.props, requiredProps, conditionalPropName, condition);\n  }\n\n  private _setComponentRef<TRefInterface>(\n    ref: IRefObject<TRefInterface> | undefined,\n    value: TRefInterface | null,\n  ): void {\n    if (!this._skipComponentRefResolution && ref) {\n      if (typeof ref === 'function') {\n        ref(value);\n      }\n\n      if (typeof ref === 'object') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (ref as any).current = value;\n      }\n    }\n  }\n}\n\n/**\n * Helper to override a given method with a wrapper method that can try/catch the original, but also\n * ensures that the BaseComponent's methods are called before the subclass's. This ensures that\n * componentWillUnmount in the base is called and that things in the _disposables array are disposed.\n */\n// eslint-disable-next-line deprecation/deprecation\nfunction _makeAllSafe(obj: BaseComponent<{}, {}>, prototype: Object, methodNames: string[]): void {\n  for (let i = 0, len = methodNames.length; i < len; i++) {\n    _makeSafe(obj, prototype, methodNames[i]);\n  }\n}\n\n// eslint-disable-next-line deprecation/deprecation\nfunction _makeSafe(obj: BaseComponent<{}, {}>, prototype: Object, methodName: string): void {\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  let classMethod = (obj as any)[methodName];\n  let prototypeMethod = (prototype as any)[methodName];\n\n  if (classMethod || prototypeMethod) {\n    (obj as any)[methodName] = function (...args: any[]): any {\n      /* eslint-enable @typescript-eslint/no-explicit-any */\n      let retVal;\n\n      if (prototypeMethod) {\n        retVal = prototypeMethod.apply(this, args);\n      }\n      if (classMethod !== prototypeMethod) {\n        retVal = classMethod.apply(this, args);\n      }\n\n      return retVal;\n    };\n  }\n}\n\n/**\n * Simple constant function for returning null, used to render empty templates in JSX.\n *\n * @public\n */\nexport function nullRender(): JSX.Element | null {\n  return null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}