{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, css, allowScrollOnElement, allowOverscrollOnElement, getPropsWithDefaults, KeyCodes, elementContains, EventGroup } from '../../Utilities';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nimport { animationDuration } from './Modal.styles';\nimport { Overlay } from '../../Overlay';\nimport { Layer } from '../../Layer';\nimport { Popup } from '../../Popup';\nimport { ResponsiveMode, useResponsiveMode } from '../../ResponsiveMode';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Icon } from '../../Icon';\nimport { DraggableZone } from '../../utilities/DraggableZone/index';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport { useBoolean, useMergedRefs, useWarnings, useConst, useSetTimeout, useId, useUnmount } from '@fluentui/react-hooks';\nvar ZERO = {\n  x: 0,\n  y: 0\n};\nvar DEFAULT_PROPS = {\n  isOpen: false,\n  isDarkOverlay: true,\n  className: '',\n  containerClassName: '',\n  enableAriaHiddenSiblings: true\n};\nvar getClassNames = classNamesFunction();\nvar getMoveDelta = function (ev) {\n  var delta = 10;\n  if (ev.shiftKey) {\n    if (!ev.ctrlKey) {\n      delta = 50;\n    }\n  } else if (ev.ctrlKey) {\n    delta = 1;\n  }\n  return delta;\n};\nvar useComponentRef = function (props, focusTrapZone) {\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      focus: function () {\n        if (focusTrapZone.current) {\n          focusTrapZone.current.focus();\n        }\n      }\n    };\n  }, [focusTrapZone]);\n};\nexport var ModalBase = React.forwardRef(function (propsWithoutDefaults, ref) {\n  var _a, _b, _c, _d, _e;\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var allowTouchBodyScroll = props.allowTouchBodyScroll,\n    className = props.className,\n    children = props.children,\n    containerClassName = props.containerClassName,\n    scrollableContentClassName = props.scrollableContentClassName,\n    elementToFocusOnDismiss = props.elementToFocusOnDismiss,\n    firstFocusableSelector = props.firstFocusableSelector,\n    focusTrapZoneProps = props.focusTrapZoneProps,\n    forceFocusInsideTrap = props.forceFocusInsideTrap,\n    // eslint-disable-next-line deprecation/deprecation\n    _f = props.disableRestoreFocus,\n    // eslint-disable-next-line deprecation/deprecation\n    disableRestoreFocus = _f === void 0 ? props.ignoreExternalFocusing : _f,\n    isBlocking = props.isBlocking,\n    isAlert = props.isAlert,\n    isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap,\n    isDarkOverlay = props.isDarkOverlay,\n    onDismiss = props.onDismiss,\n    layerProps = props.layerProps,\n    overlay = props.overlay,\n    isOpen = props.isOpen,\n    titleAriaId = props.titleAriaId,\n    styles = props.styles,\n    subtitleAriaId = props.subtitleAriaId,\n    theme = props.theme,\n    topOffsetFixed = props.topOffsetFixed,\n    responsiveMode = props.responsiveMode,\n    // eslint-disable-next-line deprecation/deprecation\n    onLayerDidMount = props.onLayerDidMount,\n    isModeless = props.isModeless,\n    dragOptions = props.dragOptions,\n    onDismissed = props.onDismissed,\n    // eslint-disable-next-line deprecation/deprecation\n    enableAriaHiddenSiblings = props.enableAriaHiddenSiblings,\n    popupProps = props.popupProps;\n  var rootRef = React.useRef(null);\n  var focusTrapZone = React.useRef(null);\n  var focusTrapZoneRef = useMergedRefs(focusTrapZone, focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.componentRef);\n  var focusTrapZoneElm = React.useRef(null);\n  var mergedRef = useMergedRefs(rootRef, ref);\n  var modalResponsiveMode = useResponsiveMode(mergedRef);\n  var focusTrapZoneId = useId('ModalFocusTrapZone', focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.id);\n  var win = useWindow();\n  var _g = useSetTimeout(),\n    setTimeout = _g.setTimeout,\n    clearTimeout = _g.clearTimeout;\n  var _h = React.useState(isOpen),\n    isModalOpen = _h[0],\n    setIsModalOpen = _h[1];\n  var _j = React.useState(isOpen),\n    isVisible = _j[0],\n    setIsVisible = _j[1];\n  var _k = React.useState(ZERO),\n    coordinates = _k[0],\n    setCoordinates = _k[1];\n  var _l = React.useState(),\n    modalRectangleTop = _l[0],\n    setModalRectangleTop = _l[1];\n  var _m = useBoolean(false),\n    isModalMenuOpen = _m[0],\n    _o = _m[1],\n    toggleModalMenuOpen = _o.toggle,\n    setModalMenuClose = _o.setFalse;\n  var internalState = useConst(function () {\n    return {\n      onModalCloseTimer: 0,\n      allowTouchBodyScroll: allowTouchBodyScroll,\n      scrollableContent: null,\n      lastSetCoordinates: ZERO,\n      events: new EventGroup({})\n    };\n  });\n  var keepInBounds = (dragOptions || {}).keepInBounds;\n  var isAlertRole = isAlert !== null && isAlert !== void 0 ? isAlert : isBlocking && !isModeless;\n  var layerClassName = layerProps === undefined ? '' : layerProps.className;\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    className: className,\n    containerClassName: containerClassName,\n    scrollableContentClassName: scrollableContentClassName,\n    isOpen: isOpen,\n    isVisible: isVisible,\n    hasBeenOpened: internalState.hasBeenOpened,\n    modalRectangleTop: modalRectangleTop,\n    topOffsetFixed: topOffsetFixed,\n    isModeless: isModeless,\n    layerClassName: layerClassName,\n    windowInnerHeight: win === null || win === void 0 ? void 0 : win.innerHeight,\n    isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector\n  });\n  var mergedLayerProps = __assign(__assign({\n    eventBubblingEnabled: false\n  }, layerProps), {\n    onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n    insertFirst: (layerProps === null || layerProps === void 0 ? void 0 : layerProps.insertFirst) || isModeless,\n    className: classNames.layer\n  });\n  // Allow the user to scroll within the modal but not on the body\n  var allowScrollOnModal = React.useCallback(function (elt) {\n    if (elt) {\n      if (internalState.allowTouchBodyScroll) {\n        allowOverscrollOnElement(elt, internalState.events);\n      } else {\n        allowScrollOnElement(elt, internalState.events);\n      }\n    } else {\n      internalState.events.off(internalState.scrollableContent);\n    }\n    internalState.scrollableContent = elt;\n  }, [internalState]);\n  var registerInitialModalPosition = function () {\n    var dialogMain = focusTrapZoneElm.current;\n    var modalRectangle = dialogMain === null || dialogMain === void 0 ? void 0 : dialogMain.getBoundingClientRect();\n    if (modalRectangle) {\n      if (topOffsetFixed) {\n        setModalRectangleTop(modalRectangle.top);\n      }\n      if (keepInBounds) {\n        // x/y are unavailable in IE, so use the equivalent left/top\n        internalState.minPosition = {\n          x: -modalRectangle.left,\n          y: -modalRectangle.top\n        };\n        internalState.maxPosition = {\n          x: modalRectangle.left,\n          y: modalRectangle.top\n        };\n      }\n    }\n  };\n  /**\n   * Clamps an axis to a specified min and max position.\n   *\n   * @param axis A string that represents the axis (x/y).\n   * @param position The position on the axis.\n   */\n  var getClampedAxis = React.useCallback(function (axis, position) {\n    var minPosition = internalState.minPosition,\n      maxPosition = internalState.maxPosition;\n    if (keepInBounds && minPosition && maxPosition) {\n      position = Math.max(minPosition[axis], position);\n      position = Math.min(maxPosition[axis], position);\n    }\n    return position;\n  }, [keepInBounds, internalState]);\n  var handleModalClose = function () {\n    var _a;\n    internalState.lastSetCoordinates = ZERO;\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = false;\n    setIsModalOpen(false);\n    setCoordinates(ZERO);\n    (_a = internalState.disposeOnKeyUp) === null || _a === void 0 ? void 0 : _a.call(internalState);\n    onDismissed === null || onDismissed === void 0 ? void 0 : onDismissed();\n  };\n  var handleDragStart = React.useCallback(function () {\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = false;\n  }, [internalState, setModalMenuClose]);\n  var handleDrag = React.useCallback(function (ev, dragData) {\n    setCoordinates(function (prevValue) {\n      return {\n        x: getClampedAxis('x', prevValue.x + dragData.delta.x),\n        y: getClampedAxis('y', prevValue.y + dragData.delta.y)\n      };\n    });\n  }, [getClampedAxis]);\n  var handleDragStop = React.useCallback(function () {\n    if (focusTrapZone.current) {\n      focusTrapZone.current.focus();\n    }\n  }, []);\n  var handleEnterKeyboardMoveMode = function () {\n    // We need a global handleKeyDown event when we are in the move mode so that we can\n    // handle the key presses and the components inside the modal do not get the events\n    var handleKeyDown = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n        // CTRL + ALT + SPACE is handled during keyUp\n        ev.preventDefault();\n        ev.stopPropagation();\n        return;\n      }\n      // eslint-disable-next-line deprecation/deprecation\n      var newLocal = ev.altKey || ev.keyCode === KeyCodes.escape;\n      if (isModalMenuOpen && newLocal) {\n        setModalMenuClose();\n      }\n      // eslint-disable-next-line deprecation/deprecation\n      if (internalState.isInKeyboardMoveMode && (ev.keyCode === KeyCodes.escape || ev.keyCode === KeyCodes.enter)) {\n        internalState.isInKeyboardMoveMode = false;\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n      if (internalState.isInKeyboardMoveMode) {\n        var handledEvent = true;\n        var delta_1 = getMoveDelta(ev);\n        // eslint-disable-next-line deprecation/deprecation\n        switch (ev.keyCode) {\n          /* eslint-disable no-fallthrough */\n          case KeyCodes.escape:\n            setCoordinates(internalState.lastSetCoordinates);\n          case KeyCodes.enter:\n            {\n              // TODO: determine if fallthrough was intentional\n              /* eslint-enable no-fallthrough */\n              internalState.lastSetCoordinates = ZERO;\n              // setIsInKeyboardMoveMode(false);\n              break;\n            }\n          case KeyCodes.up:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: prevValue.x,\n                  y: getClampedAxis('y', prevValue.y - delta_1)\n                };\n              });\n              break;\n            }\n          case KeyCodes.down:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: prevValue.x,\n                  y: getClampedAxis('y', prevValue.y + delta_1)\n                };\n              });\n              break;\n            }\n          case KeyCodes.left:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: getClampedAxis('x', prevValue.x - delta_1),\n                  y: prevValue.y\n                };\n              });\n              break;\n            }\n          case KeyCodes.right:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: getClampedAxis('x', prevValue.x + delta_1),\n                  y: prevValue.y\n                };\n              });\n              break;\n            }\n          default:\n            {\n              handledEvent = false;\n            }\n        }\n        if (handledEvent) {\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n    internalState.lastSetCoordinates = coordinates;\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = true;\n    internalState.events.on(win, 'keydown', handleKeyDown, true /* useCapture */);\n    internalState.disposeOnKeyDown = function () {\n      internalState.events.off(win, 'keydown', handleKeyDown, true /* useCapture */);\n      internalState.disposeOnKeyDown = undefined;\n    };\n  };\n  var handleExitKeyboardMoveMode = function (ev) {\n    var _a, _b;\n    (_a = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(focusTrapZoneProps, ev);\n    internalState.lastSetCoordinates = ZERO;\n    internalState.isInKeyboardMoveMode = false;\n    (_b = internalState.disposeOnKeyDown) === null || _b === void 0 ? void 0 : _b.call(internalState);\n  };\n  var registerForKeyUp = function () {\n    var handleKeyUp = function (ev) {\n      // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n      // eslint-disable-next-line deprecation/deprecation\n      if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n        if (elementContains(internalState.scrollableContent, ev.target)) {\n          toggleModalMenuOpen();\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n    if (!internalState.disposeOnKeyUp) {\n      internalState.events.on(win, 'keyup', handleKeyUp, true /* useCapture */);\n      internalState.disposeOnKeyUp = function () {\n        internalState.events.off(win, 'keyup', handleKeyUp, true /* useCapture */);\n        internalState.disposeOnKeyUp = undefined;\n      };\n    }\n  };\n  React.useEffect(function () {\n    clearTimeout(internalState.onModalCloseTimer);\n    // Opening the dialog\n    if (isOpen) {\n      // This must be done after the modal content has rendered\n      requestAnimationFrame(function () {\n        return setTimeout(registerInitialModalPosition, 0);\n      });\n      setIsModalOpen(true);\n      // Add a keyUp handler for all key up events once the dialog is open.\n      if (dragOptions) {\n        registerForKeyUp();\n      }\n      internalState.hasBeenOpened = true;\n      setIsVisible(true);\n    }\n    // Closing the dialog\n    if (!isOpen && isModalOpen) {\n      internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);\n      setIsVisible(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates.\n  }, [isModalOpen, isOpen]);\n  useUnmount(function () {\n    internalState.events.dispose();\n  });\n  useComponentRef(props, focusTrapZone);\n  useDebugWarnings(props);\n  var modalContent = React.createElement(FocusTrapZone, __assign({}, focusTrapZoneProps, {\n    id: focusTrapZoneId,\n    ref: focusTrapZoneElm,\n    componentRef: focusTrapZoneRef,\n    className: css(classNames.main, focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.className),\n    elementToFocusOnDismiss: (_a = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.elementToFocusOnDismiss) !== null && _a !== void 0 ? _a : elementToFocusOnDismiss,\n    isClickableOutsideFocusTrap: (_b = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.isClickableOutsideFocusTrap) !== null && _b !== void 0 ? _b : isModeless || isClickableOutsideFocusTrap || !isBlocking,\n    disableRestoreFocus: (_c = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.disableRestoreFocus) !== null && _c !== void 0 ? _c : disableRestoreFocus,\n    forceFocusInsideTrap: ((_d = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.forceFocusInsideTrap) !== null && _d !== void 0 ? _d : forceFocusInsideTrap) && !isModeless,\n    // eslint-disable-next-line deprecation/deprecation\n    firstFocusableSelector: (focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.firstFocusableSelector) || firstFocusableSelector,\n    focusPreviouslyFocusedInnerElement: (_e = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.focusPreviouslyFocusedInnerElement) !== null && _e !== void 0 ? _e : true,\n    onBlur: internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined\n  }), dragOptions && internalState.isInKeyboardMoveMode && React.createElement(\"div\", {\n    className: classNames.keyboardMoveIconContainer\n  }, dragOptions.keyboardMoveIconProps ? React.createElement(Icon, __assign({}, dragOptions.keyboardMoveIconProps)) : React.createElement(Icon, {\n    iconName: \"move\",\n    className: classNames.keyboardMoveIcon\n  })), React.createElement(\"div\", {\n    ref: allowScrollOnModal,\n    className: classNames.scrollableContent,\n    \"data-is-scrollable\": true\n  }, dragOptions && isModalMenuOpen && React.createElement(dragOptions.menu, {\n    items: [{\n      key: 'move',\n      text: dragOptions.moveMenuItemText,\n      onClick: handleEnterKeyboardMoveMode\n    }, {\n      key: 'close',\n      text: dragOptions.closeMenuItemText,\n      onClick: handleModalClose\n    }],\n    onDismiss: setModalMenuClose,\n    alignTargetEdge: true,\n    coverTarget: true,\n    directionalHint: DirectionalHint.topLeftEdge,\n    directionalHintFixed: true,\n    shouldFocusOnMount: true,\n    target: internalState.scrollableContent\n  }), children));\n  return isModalOpen && modalResponsiveMode >= (responsiveMode || ResponsiveMode.small) && React.createElement(Layer, __assign({\n    ref: mergedRef\n  }, mergedLayerProps), React.createElement(Popup, __assign({\n    role: isAlertRole ? 'alertdialog' : 'dialog',\n    ariaLabelledBy: titleAriaId,\n    ariaDescribedBy: subtitleAriaId,\n    onDismiss: onDismiss,\n    shouldRestoreFocus: !disableRestoreFocus,\n    // Modeless modals shouldn't hide siblings.\n    // Popup will automatically handle this based on the aria-modal setting.\n    enableAriaHiddenSiblings: enableAriaHiddenSiblings,\n    \"aria-modal\": !isModeless\n  }, popupProps), React.createElement(\"div\", {\n    className: classNames.root,\n    role: !isModeless ? 'document' : undefined\n  }, !isModeless && React.createElement(Overlay, __assign({\n    \"aria-hidden\": true,\n    isDarkThemed: isDarkOverlay,\n    onClick: isBlocking ? undefined : onDismiss,\n    allowTouchBodyScroll: allowTouchBodyScroll\n  }, overlay)), dragOptions ? React.createElement(DraggableZone, {\n    handleSelector: dragOptions.dragHandleSelector || \"#\".concat(focusTrapZoneId),\n    preventDragSelector: \"button\",\n    onStart: handleDragStart,\n    onDragChange: handleDrag,\n    onStop: handleDragStop,\n    position: coordinates\n  }, modalContent) : modalContent))) || null;\n});\nModalBase.displayName = 'Modal';\nfunction useDebugWarnings(props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: 'Modal',\n      props: props,\n      deprecations: {\n        onLayerDidMount: 'layerProps.onLayerDidMount'\n      }\n    });\n  }\n}","map":{"version":3,"names":["React","classNamesFunction","css","allowScrollOnElement","allowOverscrollOnElement","getPropsWithDefaults","KeyCodes","elementContains","EventGroup","FocusTrapZone","animationDuration","Overlay","Layer","Popup","ResponsiveMode","useResponsiveMode","DirectionalHint","Icon","DraggableZone","useWindow","useBoolean","useMergedRefs","useWarnings","useConst","useSetTimeout","useId","useUnmount","ZERO","x","y","DEFAULT_PROPS","isOpen","isDarkOverlay","className","containerClassName","enableAriaHiddenSiblings","getClassNames","getMoveDelta","ev","delta","shiftKey","ctrlKey","useComponentRef","props","focusTrapZone","useImperativeHandle","componentRef","focus","current","ModalBase","forwardRef","propsWithoutDefaults","ref","allowTouchBodyScroll","children","scrollableContentClassName","elementToFocusOnDismiss","firstFocusableSelector","focusTrapZoneProps","forceFocusInsideTrap","_f","disableRestoreFocus","ignoreExternalFocusing","isBlocking","isAlert","isClickableOutsideFocusTrap","onDismiss","layerProps","overlay","titleAriaId","styles","subtitleAriaId","theme","topOffsetFixed","responsiveMode","onLayerDidMount","isModeless","dragOptions","onDismissed","popupProps","rootRef","useRef","focusTrapZoneRef","focusTrapZoneElm","mergedRef","modalResponsiveMode","focusTrapZoneId","id","win","_g","setTimeout","clearTimeout","_h","useState","isModalOpen","setIsModalOpen","_j","isVisible","setIsVisible","_k","coordinates","setCoordinates","_l","modalRectangleTop","setModalRectangleTop","_m","isModalMenuOpen","_o","toggleModalMenuOpen","toggle","setModalMenuClose","setFalse","internalState","onModalCloseTimer","scrollableContent","lastSetCoordinates","events","keepInBounds","isAlertRole","layerClassName","undefined","classNames","hasBeenOpened","windowInnerHeight","innerHeight","isDefaultDragHandle","dragHandleSelector","mergedLayerProps","__assign","eventBubblingEnabled","insertFirst","layer","allowScrollOnModal","useCallback","elt","off","registerInitialModalPosition","dialogMain","modalRectangle","getBoundingClientRect","top","minPosition","left","maxPosition","getClampedAxis","axis","position","Math","max","min","handleModalClose","isInKeyboardMoveMode","_a","disposeOnKeyUp","call","handleDragStart","handleDrag","dragData","prevValue","handleDragStop","handleEnterKeyboardMoveMode","handleKeyDown","altKey","keyCode","space","preventDefault","stopPropagation","newLocal","escape","enter","handledEvent","delta_1","up","down","right","on","disposeOnKeyDown","handleExitKeyboardMoveMode","onBlur","_b","registerForKeyUp","handleKeyUp","target","useEffect","requestAnimationFrame","parseFloat","dispose","useDebugWarnings","modalContent","createElement","main","_c","_d","focusPreviouslyFocusedInnerElement","_e","keyboardMoveIconContainer","keyboardMoveIconProps","iconName","keyboardMoveIcon","menu","items","key","text","moveMenuItemText","onClick","closeMenuItemText","alignTargetEdge","coverTarget","directionalHint","topLeftEdge","directionalHintFixed","shouldFocusOnMount","small","role","ariaLabelledBy","ariaDescribedBy","shouldRestoreFocus","root","isDarkThemed","handleSelector","concat","preventDragSelector","onStart","onDragChange","onStop","displayName","process","env","NODE_ENV","name","deprecations"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/components/src/components/Modal/Modal.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  classNamesFunction,\n  css,\n  allowScrollOnElement,\n  allowOverscrollOnElement,\n  getPropsWithDefaults,\n  KeyCodes,\n  elementContains,\n  EventGroup,\n} from '../../Utilities';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nimport { animationDuration } from './Modal.styles';\nimport { Overlay } from '../../Overlay';\nimport { Layer } from '../../Layer';\nimport { Popup } from '../../Popup';\nimport { ResponsiveMode, useResponsiveMode } from '../../ResponsiveMode';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Icon } from '../../Icon';\nimport { DraggableZone } from '../../utilities/DraggableZone/index';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport {\n  useBoolean,\n  useMergedRefs,\n  useWarnings,\n  useConst,\n  useSetTimeout,\n  useId,\n  useUnmount,\n} from '@fluentui/react-hooks';\nimport type { IFocusTrapZone } from '../../FocusTrapZone';\nimport type { IDragOptions, IModalProps, IModalStyleProps, IModalStyles } from './Modal.types';\nimport type { ILayerProps } from '../../Layer';\nimport type { ICoordinates, IDragData } from '../../utilities/DraggableZone/index';\n\n// @TODO - need to change this to a panel whenever the breakpoint is under medium (verify the spec)\n\ninterface IModalInternalState {\n  onModalCloseTimer: number;\n  allowTouchBodyScroll?: boolean;\n  scrollableContent: HTMLDivElement | null;\n  lastSetCoordinates: ICoordinates;\n  /** Minimum clamped position, if dragging and clamping (`dragOptions.keepInBounds`) are enabled */\n  minPosition?: ICoordinates;\n  /** Maximum clamped position, if dragging and clamping (`dragOptions.keepInBounds`) are enabled */\n  maxPosition?: ICoordinates;\n  events: EventGroup;\n  /** Ensures we dispose the same keydown callback as was registered */\n  disposeOnKeyDown?: () => void;\n  /** Ensures we dispose the same keyup callback as was registered (also tracks whether keyup has been registered) */\n  disposeOnKeyUp?: () => void;\n  isInKeyboardMoveMode?: boolean;\n  hasBeenOpened?: boolean;\n}\n\nconst ZERO: ICoordinates = { x: 0, y: 0 };\n\nconst DEFAULT_PROPS: Partial<IModalProps> = {\n  isOpen: false,\n  isDarkOverlay: true,\n  className: '',\n  containerClassName: '',\n  enableAriaHiddenSiblings: true,\n};\n\nconst getClassNames = classNamesFunction<IModalStyleProps, IModalStyles>();\n\nconst getMoveDelta = (ev: React.KeyboardEvent<HTMLElement>): number => {\n  let delta = 10;\n  if (ev.shiftKey) {\n    if (!ev.ctrlKey) {\n      delta = 50;\n    }\n  } else if (ev.ctrlKey) {\n    delta = 1;\n  }\n\n  return delta;\n};\n\nconst useComponentRef = (props: IModalProps, focusTrapZone: React.RefObject<IFocusTrapZone>) => {\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      focus() {\n        if (focusTrapZone.current) {\n          focusTrapZone.current.focus();\n        }\n      },\n    }),\n    [focusTrapZone],\n  );\n};\n\nexport const ModalBase: React.FunctionComponent<IModalProps> = React.forwardRef<HTMLDivElement, IModalProps>(\n  (propsWithoutDefaults, ref) => {\n    const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n    const {\n      allowTouchBodyScroll,\n      className,\n      children,\n      containerClassName,\n      scrollableContentClassName,\n      elementToFocusOnDismiss,\n      firstFocusableSelector,\n      focusTrapZoneProps,\n      forceFocusInsideTrap,\n      // eslint-disable-next-line deprecation/deprecation\n      disableRestoreFocus = props.ignoreExternalFocusing,\n      isBlocking,\n      isAlert,\n      isClickableOutsideFocusTrap,\n      isDarkOverlay,\n      onDismiss,\n      layerProps,\n      overlay,\n      isOpen,\n      titleAriaId,\n      styles,\n      subtitleAriaId,\n      theme,\n      topOffsetFixed,\n      responsiveMode,\n      // eslint-disable-next-line deprecation/deprecation\n      onLayerDidMount,\n      isModeless,\n      dragOptions,\n      onDismissed,\n      // eslint-disable-next-line deprecation/deprecation\n      enableAriaHiddenSiblings,\n      popupProps,\n    } = props;\n\n    const rootRef = React.useRef<HTMLDivElement>(null);\n    const focusTrapZone = React.useRef<IFocusTrapZone>(null);\n    const focusTrapZoneRef = useMergedRefs(focusTrapZone, focusTrapZoneProps?.componentRef);\n    const focusTrapZoneElm = React.useRef<HTMLDivElement>(null);\n    const mergedRef = useMergedRefs(rootRef, ref);\n\n    const modalResponsiveMode = useResponsiveMode(mergedRef);\n\n    const focusTrapZoneId = useId('ModalFocusTrapZone', focusTrapZoneProps?.id);\n\n    const win = useWindow();\n\n    const { setTimeout, clearTimeout } = useSetTimeout();\n\n    const [isModalOpen, setIsModalOpen] = React.useState(isOpen);\n    const [isVisible, setIsVisible] = React.useState(isOpen);\n    const [coordinates, setCoordinates] = React.useState<ICoordinates>(ZERO);\n    const [modalRectangleTop, setModalRectangleTop] = React.useState<number | undefined>();\n\n    const [isModalMenuOpen, { toggle: toggleModalMenuOpen, setFalse: setModalMenuClose }] = useBoolean(false);\n\n    const internalState = useConst<IModalInternalState>(() => ({\n      onModalCloseTimer: 0,\n      allowTouchBodyScroll,\n      scrollableContent: null,\n      lastSetCoordinates: ZERO,\n      events: new EventGroup({}),\n    }));\n\n    const { keepInBounds } = dragOptions || ({} as IDragOptions);\n    const isAlertRole = isAlert ?? (isBlocking && !isModeless);\n\n    const layerClassName = layerProps === undefined ? '' : layerProps.className;\n    const classNames = getClassNames(styles, {\n      theme: theme!,\n      className,\n      containerClassName,\n      scrollableContentClassName,\n      isOpen,\n      isVisible,\n      hasBeenOpened: internalState.hasBeenOpened,\n      modalRectangleTop,\n      topOffsetFixed,\n      isModeless,\n      layerClassName,\n      windowInnerHeight: win?.innerHeight,\n      isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector,\n    });\n\n    const mergedLayerProps: ILayerProps = {\n      eventBubblingEnabled: false,\n      ...layerProps,\n      onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n      insertFirst: layerProps?.insertFirst || isModeless,\n      className: classNames.layer,\n    };\n\n    // Allow the user to scroll within the modal but not on the body\n    const allowScrollOnModal = React.useCallback(\n      (elt: HTMLDivElement | null): void => {\n        if (elt) {\n          if (internalState.allowTouchBodyScroll) {\n            allowOverscrollOnElement(elt, internalState.events);\n          } else {\n            allowScrollOnElement(elt, internalState.events);\n          }\n        } else {\n          internalState.events.off(internalState.scrollableContent);\n        }\n        internalState.scrollableContent = elt;\n      },\n      [internalState],\n    );\n\n    const registerInitialModalPosition = (): void => {\n      const dialogMain = focusTrapZoneElm.current;\n      const modalRectangle = dialogMain?.getBoundingClientRect();\n\n      if (modalRectangle) {\n        if (topOffsetFixed) {\n          setModalRectangleTop(modalRectangle.top);\n        }\n\n        if (keepInBounds) {\n          // x/y are unavailable in IE, so use the equivalent left/top\n          internalState.minPosition = { x: -modalRectangle.left, y: -modalRectangle.top };\n          internalState.maxPosition = { x: modalRectangle.left, y: modalRectangle.top };\n        }\n      }\n    };\n\n    /**\n     * Clamps an axis to a specified min and max position.\n     *\n     * @param axis A string that represents the axis (x/y).\n     * @param position The position on the axis.\n     */\n    const getClampedAxis = React.useCallback(\n      (axis: keyof ICoordinates, position: number) => {\n        const { minPosition, maxPosition } = internalState;\n        if (keepInBounds && minPosition && maxPosition) {\n          position = Math.max(minPosition[axis], position);\n          position = Math.min(maxPosition[axis], position);\n        }\n        return position;\n      },\n      [keepInBounds, internalState],\n    );\n\n    const handleModalClose = (): void => {\n      internalState.lastSetCoordinates = ZERO;\n\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = false;\n      setIsModalOpen(false);\n      setCoordinates(ZERO);\n\n      internalState.disposeOnKeyUp?.();\n\n      onDismissed?.();\n    };\n\n    const handleDragStart = React.useCallback((): void => {\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = false;\n    }, [internalState, setModalMenuClose]);\n\n    const handleDrag = React.useCallback(\n      (ev: React.MouseEvent<HTMLElement> & React.TouchEvent<HTMLElement>, dragData: IDragData): void => {\n        setCoordinates(prevValue => ({\n          x: getClampedAxis('x', prevValue.x + dragData.delta.x),\n          y: getClampedAxis('y', prevValue.y + dragData.delta.y),\n        }));\n      },\n      [getClampedAxis],\n    );\n\n    const handleDragStop = React.useCallback((): void => {\n      if (focusTrapZone.current) {\n        focusTrapZone.current.focus();\n      }\n    }, []);\n\n    const handleEnterKeyboardMoveMode = () => {\n      // We need a global handleKeyDown event when we are in the move mode so that we can\n      // handle the key presses and the components inside the modal do not get the events\n      const handleKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n        // eslint-disable-next-line deprecation/deprecation\n        if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n          // CTRL + ALT + SPACE is handled during keyUp\n          ev.preventDefault();\n          ev.stopPropagation();\n          return;\n        }\n\n        // eslint-disable-next-line deprecation/deprecation\n        const newLocal = ev.altKey || ev.keyCode === KeyCodes.escape;\n        if (isModalMenuOpen && newLocal) {\n          setModalMenuClose();\n        }\n\n        // eslint-disable-next-line deprecation/deprecation\n        if (internalState.isInKeyboardMoveMode && (ev.keyCode === KeyCodes.escape || ev.keyCode === KeyCodes.enter)) {\n          internalState.isInKeyboardMoveMode = false;\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n\n        if (internalState.isInKeyboardMoveMode) {\n          let handledEvent = true;\n          const delta = getMoveDelta(ev);\n\n          // eslint-disable-next-line deprecation/deprecation\n          switch (ev.keyCode) {\n            /* eslint-disable no-fallthrough */\n            case KeyCodes.escape:\n              setCoordinates(internalState.lastSetCoordinates);\n            case KeyCodes.enter: {\n              // TODO: determine if fallthrough was intentional\n              /* eslint-enable no-fallthrough */\n              internalState.lastSetCoordinates = ZERO;\n              // setIsInKeyboardMoveMode(false);\n              break;\n            }\n            case KeyCodes.up: {\n              setCoordinates(prevValue => ({ x: prevValue.x, y: getClampedAxis('y', prevValue.y - delta) }));\n              break;\n            }\n            case KeyCodes.down: {\n              setCoordinates(prevValue => ({ x: prevValue.x, y: getClampedAxis('y', prevValue.y + delta) }));\n              break;\n            }\n            case KeyCodes.left: {\n              setCoordinates(prevValue => ({ x: getClampedAxis('x', prevValue.x - delta), y: prevValue.y }));\n              break;\n            }\n            case KeyCodes.right: {\n              setCoordinates(prevValue => ({ x: getClampedAxis('x', prevValue.x + delta), y: prevValue.y }));\n              break;\n            }\n            default: {\n              handledEvent = false;\n            }\n          }\n          if (handledEvent) {\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n        }\n      };\n\n      internalState.lastSetCoordinates = coordinates;\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = true;\n\n      internalState.events.on(win, 'keydown', handleKeyDown, true /* useCapture */);\n      internalState.disposeOnKeyDown = () => {\n        internalState.events.off(win, 'keydown', handleKeyDown, true /* useCapture */);\n        internalState.disposeOnKeyDown = undefined;\n      };\n    };\n\n    const handleExitKeyboardMoveMode = (ev: React.FocusEvent<HTMLDivElement>) => {\n      focusTrapZoneProps?.onBlur?.(ev);\n      internalState.lastSetCoordinates = ZERO;\n      internalState.isInKeyboardMoveMode = false;\n      internalState.disposeOnKeyDown?.();\n    };\n\n    const registerForKeyUp = (): void => {\n      const handleKeyUp = (ev: React.KeyboardEvent<HTMLElement>): void => {\n        // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n        // eslint-disable-next-line deprecation/deprecation\n        if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n          if (elementContains(internalState.scrollableContent, ev.target as HTMLElement)) {\n            toggleModalMenuOpen();\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n        }\n      };\n\n      if (!internalState.disposeOnKeyUp) {\n        internalState.events.on(win, 'keyup', handleKeyUp, true /* useCapture */);\n        internalState.disposeOnKeyUp = () => {\n          internalState.events.off(win, 'keyup', handleKeyUp, true /* useCapture */);\n          internalState.disposeOnKeyUp = undefined;\n        };\n      }\n    };\n\n    React.useEffect(() => {\n      clearTimeout(internalState.onModalCloseTimer);\n      // Opening the dialog\n      if (isOpen) {\n        // This must be done after the modal content has rendered\n        requestAnimationFrame(() => setTimeout(registerInitialModalPosition, 0));\n\n        setIsModalOpen(true);\n\n        // Add a keyUp handler for all key up events once the dialog is open.\n        if (dragOptions) {\n          registerForKeyUp();\n        }\n\n        internalState.hasBeenOpened = true;\n        setIsVisible(true);\n      }\n\n      // Closing the dialog\n      if (!isOpen && isModalOpen) {\n        internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);\n        setIsVisible(false);\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates.\n    }, [isModalOpen, isOpen]);\n\n    useUnmount(() => {\n      internalState.events.dispose();\n    });\n\n    useComponentRef(props, focusTrapZone);\n    useDebugWarnings(props);\n\n    const modalContent = (\n      <FocusTrapZone\n        {...focusTrapZoneProps}\n        id={focusTrapZoneId}\n        ref={focusTrapZoneElm}\n        componentRef={focusTrapZoneRef}\n        className={css(classNames.main, focusTrapZoneProps?.className)}\n        elementToFocusOnDismiss={focusTrapZoneProps?.elementToFocusOnDismiss ?? elementToFocusOnDismiss}\n        isClickableOutsideFocusTrap={\n          focusTrapZoneProps?.isClickableOutsideFocusTrap ?? (isModeless || isClickableOutsideFocusTrap || !isBlocking)\n        }\n        disableRestoreFocus={focusTrapZoneProps?.disableRestoreFocus ?? disableRestoreFocus}\n        forceFocusInsideTrap={(focusTrapZoneProps?.forceFocusInsideTrap ?? forceFocusInsideTrap) && !isModeless}\n        // eslint-disable-next-line deprecation/deprecation\n        firstFocusableSelector={focusTrapZoneProps?.firstFocusableSelector || firstFocusableSelector}\n        focusPreviouslyFocusedInnerElement={focusTrapZoneProps?.focusPreviouslyFocusedInnerElement ?? true}\n        onBlur={internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined}\n        // enableAriaHiddenSiblings is handled by the Popup\n      >\n        {dragOptions && internalState.isInKeyboardMoveMode && (\n          <div className={classNames.keyboardMoveIconContainer}>\n            {dragOptions.keyboardMoveIconProps ? (\n              <Icon {...dragOptions.keyboardMoveIconProps} />\n            ) : (\n              <Icon iconName=\"move\" className={classNames.keyboardMoveIcon} />\n            )}\n          </div>\n        )}\n        <div ref={allowScrollOnModal} className={classNames.scrollableContent} data-is-scrollable>\n          {dragOptions && isModalMenuOpen && (\n            <dragOptions.menu\n              items={[\n                { key: 'move', text: dragOptions.moveMenuItemText, onClick: handleEnterKeyboardMoveMode },\n                { key: 'close', text: dragOptions.closeMenuItemText, onClick: handleModalClose },\n              ]}\n              onDismiss={setModalMenuClose}\n              alignTargetEdge\n              coverTarget\n              directionalHint={DirectionalHint.topLeftEdge}\n              directionalHintFixed\n              shouldFocusOnMount\n              target={internalState.scrollableContent}\n            />\n          )}\n          {children}\n        </div>\n      </FocusTrapZone>\n    );\n\n    return (\n      (isModalOpen && modalResponsiveMode! >= (responsiveMode || ResponsiveMode.small) && (\n        <Layer ref={mergedRef} {...mergedLayerProps}>\n          <Popup\n            role={isAlertRole ? 'alertdialog' : 'dialog'}\n            ariaLabelledBy={titleAriaId}\n            ariaDescribedBy={subtitleAriaId}\n            onDismiss={onDismiss}\n            shouldRestoreFocus={!disableRestoreFocus}\n            // Modeless modals shouldn't hide siblings.\n            // Popup will automatically handle this based on the aria-modal setting.\n            enableAriaHiddenSiblings={enableAriaHiddenSiblings}\n            aria-modal={!isModeless}\n            {...popupProps}\n          >\n            <div className={classNames.root} role={!isModeless ? 'document' : undefined}>\n              {!isModeless && (\n                <Overlay\n                  aria-hidden={true}\n                  isDarkThemed={isDarkOverlay}\n                  onClick={isBlocking ? undefined : onDismiss}\n                  allowTouchBodyScroll={allowTouchBodyScroll}\n                  {...overlay}\n                />\n              )}\n              {dragOptions ? (\n                <DraggableZone\n                  handleSelector={dragOptions.dragHandleSelector || `#${focusTrapZoneId}`}\n                  preventDragSelector=\"button\"\n                  onStart={handleDragStart}\n                  onDragChange={handleDrag}\n                  onStop={handleDragStop}\n                  position={coordinates}\n                >\n                  {modalContent}\n                </DraggableZone>\n              ) : (\n                modalContent\n              )}\n            </div>\n          </Popup>\n        </Layer>\n      )) ||\n      null\n    );\n  },\n);\nModalBase.displayName = 'Modal';\n\nfunction useDebugWarnings(props: IModalProps) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: 'Modal',\n      props,\n      deprecations: { onLayerDidMount: 'layerProps.onLayerDidMount' },\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}