{"ast":null,"code":"/**\n * The helper functions here will make the target element as modal to screen readers, by placing aria-hidden on elements\n * that are siblings to the target element and the target element's ancestors (because aria-hidden gets inherited).\n * That way, all other elements on the page are hidden to the screen reader.\n */\nimport { getDocument } from './dom/getDocument';\n/** Tag names to ignore when modalizing */\nvar tagsToIgnore = ['TEMPLATE', 'STYLE', 'SCRIPT'];\n/**\n * Call this on a target element to make it modal to screen readers.\n * Returns a function that undoes the changes it made.\n */\nexport function modalize(target) {\n  var targetDocument = getDocument(target);\n  if (!targetDocument) {\n    // can't do this in SSR\n    return function () {\n      return undefined;\n    };\n  }\n  var affectedNodes = [];\n  // start at target, then recurse and do the same for parent, until we reach <body>\n  while (target !== targetDocument.body && target.parentElement) {\n    // grab all siblings of current element\n    for (var _i = 0, _a = target.parentElement.children; _i < _a.length; _i++) {\n      var sibling = _a[_i];\n      // but ignore elements that are already aria-hidden\n      var ariaHidden = sibling.getAttribute('aria-hidden');\n      if (sibling !== target && (ariaHidden === null || ariaHidden === void 0 ? void 0 : ariaHidden.toLowerCase()) !== 'true' && tagsToIgnore.indexOf(sibling.tagName) === -1) {\n        affectedNodes.push([sibling, ariaHidden]);\n      }\n    }\n    target = target.parentElement;\n  }\n  // take all those elements and set aria-hidden=true on them\n  affectedNodes.forEach(function (_a) {\n    var node = _a[0];\n    node.setAttribute('aria-hidden', 'true');\n  });\n  return function () {\n    unmodalize(affectedNodes);\n    affectedNodes = []; // dispose\n  };\n}\n/**\n * Undoes the changes that modalize() did.\n */\nfunction unmodalize(affectedNodes) {\n  affectedNodes.forEach(function (_a) {\n    var node = _a[0],\n      originalValue = _a[1];\n    // Restore the original value (false or unset)\n    if (originalValue) {\n      node.setAttribute('aria-hidden', originalValue);\n    } else {\n      node.removeAttribute('aria-hidden');\n    }\n  });\n}","map":{"version":3,"names":["getDocument","tagsToIgnore","modalize","target","targetDocument","undefined","affectedNodes","body","parentElement","_i","_a","children","length","sibling","ariaHidden","getAttribute","toLowerCase","indexOf","tagName","push","forEach","node","setAttribute","unmodalize","originalValue","removeAttribute"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/utilities/src/modalize.ts"],"sourcesContent":["/**\n * The helper functions here will make the target element as modal to screen readers, by placing aria-hidden on elements\n * that are siblings to the target element and the target element's ancestors (because aria-hidden gets inherited).\n * That way, all other elements on the page are hidden to the screen reader.\n */\n\nimport { getDocument } from './dom/getDocument';\n\n/** Tag names to ignore when modalizing */\nconst tagsToIgnore = ['TEMPLATE', 'STYLE', 'SCRIPT'];\n\n/**\n * Call this on a target element to make it modal to screen readers.\n * Returns a function that undoes the changes it made.\n */\nexport function modalize(target: HTMLElement): () => void {\n  const targetDocument = getDocument(target);\n  if (!targetDocument) {\n    // can't do this in SSR\n    return () => undefined;\n  }\n\n  let affectedNodes: [HTMLElement, string | null][] = [];\n\n  // start at target, then recurse and do the same for parent, until we reach <body>\n  while (target !== targetDocument.body && target.parentElement) {\n    // grab all siblings of current element\n    for (const sibling of target.parentElement.children as unknown as HTMLElement[]) {\n      // but ignore elements that are already aria-hidden\n      const ariaHidden = sibling.getAttribute('aria-hidden');\n      if (sibling !== target && ariaHidden?.toLowerCase() !== 'true' && tagsToIgnore.indexOf(sibling.tagName) === -1) {\n        affectedNodes.push([sibling, ariaHidden]);\n      }\n    }\n\n    target = target.parentElement;\n  }\n\n  // take all those elements and set aria-hidden=true on them\n  affectedNodes.forEach(([node]) => {\n    node.setAttribute('aria-hidden', 'true');\n  });\n\n  return () => {\n    unmodalize(affectedNodes);\n    affectedNodes = []; // dispose\n  };\n}\n\n/**\n * Undoes the changes that modalize() did.\n */\nfunction unmodalize(affectedNodes: [HTMLElement, string | null][]) {\n  affectedNodes.forEach(([node, originalValue]) => {\n    // Restore the original value (false or unset)\n    if (originalValue) {\n      node.setAttribute('aria-hidden', originalValue);\n    } else {\n      node.removeAttribute('aria-hidden');\n    }\n  });\n}\n"],"mappings":"AAAA;;;;;AAMA,SAASA,WAAW,QAAQ,mBAAmB;AAE/C;AACA,IAAMC,YAAY,GAAG,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ,CAAC;AAEpD;;;;AAIA,OAAM,SAAUC,QAAQA,CAACC,MAAmB;EAC1C,IAAMC,cAAc,GAAGJ,WAAW,CAACG,MAAM,CAAC;EAC1C,IAAI,CAACC,cAAc,EAAE;IACnB;IACA,OAAO;MAAM,OAAAC,SAAS;IAAT,CAAS;;EAGxB,IAAIC,aAAa,GAAmC,EAAE;EAEtD;EACA,OAAOH,MAAM,KAAKC,cAAc,CAACG,IAAI,IAAIJ,MAAM,CAACK,aAAa,EAAE;IAC7D;IACA,KAAsB,IAAAC,EAAA,IAAyD,EAAzDC,EAAA,GAAAP,MAAM,CAACK,aAAa,CAACG,QAAoC,EAAzDF,EAAA,GAAAC,EAAA,CAAAE,MAAyD,EAAzDH,EAAA,EAAyD,EAAE;MAA5E,IAAMI,OAAO,GAAAH,EAAA,CAAAD,EAAA;MAChB;MACA,IAAMK,UAAU,GAAGD,OAAO,CAACE,YAAY,CAAC,aAAa,CAAC;MACtD,IAAIF,OAAO,KAAKV,MAAM,IAAI,CAAAW,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEE,WAAW,EAAE,MAAK,MAAM,IAAIf,YAAY,CAACgB,OAAO,CAACJ,OAAO,CAACK,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE;QAC9GZ,aAAa,CAACa,IAAI,CAAC,CAACN,OAAO,EAAEC,UAAU,CAAC,CAAC;;;IAI7CX,MAAM,GAAGA,MAAM,CAACK,aAAa;;EAG/B;EACAF,aAAa,CAACc,OAAO,CAAC,UAACV,EAAM;QAALW,IAAI,GAAAX,EAAA;IAC1BW,IAAI,CAACC,YAAY,CAAC,aAAa,EAAE,MAAM,CAAC;EAC1C,CAAC,CAAC;EAEF,OAAO;IACLC,UAAU,CAACjB,aAAa,CAAC;IACzBA,aAAa,GAAG,EAAE,CAAC,CAAC;EACtB,CAAC;AACH;AAEA;;;AAGA,SAASiB,UAAUA,CAACjB,aAA6C;EAC/DA,aAAa,CAACc,OAAO,CAAC,UAACV,EAAqB;QAApBW,IAAI,GAAAX,EAAA;MAAEc,aAAa,GAAAd,EAAA;IACzC;IACA,IAAIc,aAAa,EAAE;MACjBH,IAAI,CAACC,YAAY,CAAC,aAAa,EAAEE,aAAa,CAAC;KAChD,MAAM;MACLH,IAAI,CAACI,eAAe,CAAC,aAAa,CAAC;;EAEvC,CAAC,CAAC;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}