{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, AutoScroll, classNamesFunction, findScrollableParent, getDistanceBetweenPoints, getRTL, initializeComponentRef } from '../../Utilities';\nvar getClassNames = classNamesFunction();\n// We want to make the marquee selection start when the user drags a minimum distance. Otherwise we'd start\n// the drag even if they just click an item without moving.\nvar MIN_DRAG_DISTANCE = 5;\n/**\n * MarqueeSelection component abstracts managing a draggable rectangle which sets items selected/not selected.\n * Elements which have data-selectable-index attributes are queried and measured once to determine if they\n * fall within the bounds of the rectangle. The measure is memoized during the drag as a performance optimization\n * so if the items change sizes while dragging, that could cause incorrect results.\n */\nvar MarqueeSelectionBase = /** @class */function (_super) {\n  __extends(MarqueeSelectionBase, _super);\n  function MarqueeSelectionBase(props) {\n    var _this = _super.call(this, props) || this;\n    _this._root = React.createRef();\n    _this._onMouseDown = function (ev) {\n      var _a = _this.props,\n        isEnabled = _a.isEnabled,\n        onShouldStartSelection = _a.onShouldStartSelection;\n      // Ensure the mousedown is within the boundaries of the target. If not, it may have been a click on a scrollbar.\n      if (_this._isMouseEventOnScrollbar(ev)) {\n        return;\n      }\n      if (_this._isInSelectionToggle(ev)) {\n        return;\n      }\n      if (!_this._isTouch && isEnabled && !_this._isDragStartInSelection(ev) && (!onShouldStartSelection || onShouldStartSelection(ev))) {\n        if (_this._scrollableSurface && ev.button === 0 && _this._root.current) {\n          _this._selectedIndicies = {};\n          _this._preservedIndicies = undefined;\n          _this._events.on(window, 'mousemove', _this._onAsyncMouseMove, true);\n          _this._events.on(_this._scrollableParent, 'scroll', _this._onAsyncMouseMove);\n          _this._events.on(window, 'click', _this._onMouseUp, true);\n          _this._autoScroll = new AutoScroll(_this._root.current);\n          _this._scrollTop = _this._scrollableSurface.scrollTop;\n          _this._scrollLeft = _this._scrollableSurface.scrollLeft;\n          _this._rootRect = _this._root.current.getBoundingClientRect();\n          _this._onMouseMove(ev);\n        }\n      }\n    };\n    _this._onTouchStart = function (ev) {\n      _this._isTouch = true;\n      _this._async.setTimeout(function () {\n        _this._isTouch = false;\n      }, 0);\n    };\n    _this._onPointerDown = function (ev) {\n      if (ev.pointerType === 'touch') {\n        _this._isTouch = true;\n        _this._async.setTimeout(function () {\n          _this._isTouch = false;\n        }, 0);\n      }\n    };\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this.state = {\n      dragRect: undefined\n    };\n    return _this;\n  }\n  MarqueeSelectionBase.prototype.componentDidMount = function () {\n    this._scrollableParent = findScrollableParent(this._root.current);\n    this._scrollableSurface = this._scrollableParent === window ? document.body : this._scrollableParent;\n    // When scroll events come from window, we need to read scrollTop values from the body.\n    var hitTarget = this.props.isDraggingConstrainedToRoot ? this._root.current : this._scrollableSurface;\n    this._events.on(hitTarget, 'mousedown', this._onMouseDown);\n    this._events.on(hitTarget, 'touchstart', this._onTouchStart, true);\n    this._events.on(hitTarget, 'pointerdown', this._onPointerDown, true);\n  };\n  MarqueeSelectionBase.prototype.componentWillUnmount = function () {\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n    delete this._scrollableParent;\n    delete this._scrollableSurface;\n    this._events.dispose();\n    this._async.dispose();\n  };\n  MarqueeSelectionBase.prototype.render = function () {\n    var _a = this.props,\n      rootProps = _a.rootProps,\n      children = _a.children,\n      theme = _a.theme,\n      className = _a.className,\n      styles = _a.styles;\n    var dragRect = this.state.dragRect;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    return React.createElement(\"div\", __assign({}, rootProps, {\n      className: classNames.root,\n      ref: this._root\n    }), children, dragRect && React.createElement(\"div\", {\n      className: classNames.dragMask\n    }), dragRect && React.createElement(\"div\", {\n      className: classNames.box,\n      style: dragRect\n    }, React.createElement(\"div\", {\n      className: classNames.boxFill\n    })));\n  };\n  /** Determine if the mouse event occured on a scrollbar of the target element. */\n  MarqueeSelectionBase.prototype._isMouseEventOnScrollbar = function (ev) {\n    var targetElement = ev.target;\n    var targetScrollbarWidth = targetElement.offsetWidth - targetElement.clientWidth;\n    var targetScrollbarHeight = targetElement.offsetHeight - targetElement.clientHeight;\n    if (targetScrollbarWidth || targetScrollbarHeight) {\n      var targetRect = targetElement.getBoundingClientRect();\n      // Check vertical scroll\n      if (getRTL(this.props.theme)) {\n        if (ev.clientX < targetRect.left + targetScrollbarWidth) {\n          return true;\n        }\n      } else {\n        if (ev.clientX > targetRect.left + targetElement.clientWidth) {\n          return true;\n        }\n      }\n      // Check horizontal scroll\n      if (ev.clientY > targetRect.top + targetElement.clientHeight) {\n        return true;\n      }\n    }\n    return false;\n  };\n  MarqueeSelectionBase.prototype._getRootRect = function () {\n    return {\n      left: this._rootRect.left + (this._scrollableSurface ? this._scrollLeft - this._scrollableSurface.scrollLeft : this._scrollLeft),\n      top: this._rootRect.top + (this._scrollableSurface ? this._scrollTop - this._scrollableSurface.scrollTop : this._scrollTop),\n      width: this._rootRect.width,\n      height: this._rootRect.height\n    };\n  };\n  MarqueeSelectionBase.prototype._onAsyncMouseMove = function (ev) {\n    var _this = this;\n    this._async.requestAnimationFrame(function () {\n      _this._onMouseMove(ev);\n    });\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n  MarqueeSelectionBase.prototype._onMouseMove = function (ev) {\n    if (!this._autoScroll) {\n      return;\n    }\n    if (ev.clientX !== undefined) {\n      this._lastMouseEvent = ev;\n    }\n    var rootRect = this._getRootRect();\n    var currentPoint = {\n      left: ev.clientX - rootRect.left,\n      top: ev.clientY - rootRect.top\n    };\n    if (!this._dragOrigin) {\n      this._dragOrigin = currentPoint;\n    }\n    if (ev.buttons !== undefined && ev.buttons === 0) {\n      this._onMouseUp(ev);\n    } else {\n      if (this.state.dragRect || getDistanceBetweenPoints(this._dragOrigin, currentPoint) > MIN_DRAG_DISTANCE) {\n        if (!this.state.dragRect) {\n          var selection = this.props.selection;\n          if (!ev.shiftKey) {\n            selection.setAllSelected(false);\n          }\n          this._preservedIndicies = selection && selection.getSelectedIndices && selection.getSelectedIndices();\n        }\n        // We need to constrain the current point to the rootRect boundaries.\n        var constrainedPoint = this.props.isDraggingConstrainedToRoot ? {\n          left: Math.max(0, Math.min(rootRect.width, this._lastMouseEvent.clientX - rootRect.left)),\n          top: Math.max(0, Math.min(rootRect.height, this._lastMouseEvent.clientY - rootRect.top))\n        } : {\n          left: this._lastMouseEvent.clientX - rootRect.left,\n          top: this._lastMouseEvent.clientY - rootRect.top\n        };\n        var dragRect = {\n          left: Math.min(this._dragOrigin.left || 0, constrainedPoint.left),\n          top: Math.min(this._dragOrigin.top || 0, constrainedPoint.top),\n          width: Math.abs(constrainedPoint.left - (this._dragOrigin.left || 0)),\n          height: Math.abs(constrainedPoint.top - (this._dragOrigin.top || 0))\n        };\n        this._evaluateSelection(dragRect, rootRect);\n        this.setState({\n          dragRect: dragRect\n        });\n      }\n    }\n    return false;\n  };\n  MarqueeSelectionBase.prototype._onMouseUp = function (ev) {\n    this._events.off(window);\n    this._events.off(this._scrollableParent, 'scroll');\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n    this._autoScroll = this._dragOrigin = this._lastMouseEvent = undefined;\n    this._selectedIndicies = this._itemRectCache = undefined;\n    if (this.state.dragRect) {\n      this.setState({\n        dragRect: undefined\n      });\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n  MarqueeSelectionBase.prototype._isPointInRectangle = function (rectangle, point) {\n    return !!point.top && rectangle.top < point.top && rectangle.bottom > point.top && !!point.left && rectangle.left < point.left && rectangle.right > point.left;\n  };\n  /**\n   * We do not want to start the marquee if we're trying to marquee\n   * from within an existing marquee selection.\n   */\n  MarqueeSelectionBase.prototype._isDragStartInSelection = function (ev) {\n    var selection = this.props.selection;\n    if (!this._root.current || selection && selection.getSelectedCount() === 0) {\n      return false;\n    }\n    var allElements = this._root.current.querySelectorAll('[data-selection-index]');\n    for (var i = 0; i < allElements.length; i++) {\n      var element = allElements[i];\n      var index = Number(element.getAttribute('data-selection-index'));\n      if (selection.isIndexSelected(index)) {\n        var itemRect = element.getBoundingClientRect();\n        if (this._isPointInRectangle(itemRect, {\n          left: ev.clientX,\n          top: ev.clientY\n        })) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  MarqueeSelectionBase.prototype._isInSelectionToggle = function (ev) {\n    var element = ev.target;\n    while (element && element !== this._root.current) {\n      if (element.getAttribute('data-selection-toggle') === 'true') {\n        return true;\n      }\n      element = element.parentElement;\n    }\n    return false;\n  };\n  MarqueeSelectionBase.prototype._evaluateSelection = function (dragRect, rootRect) {\n    // Break early if we don't need to evaluate.\n    if (!dragRect || !this._root.current) {\n      return;\n    }\n    var selection = this.props.selection;\n    var allElements = this._root.current.querySelectorAll('[data-selection-index]');\n    if (!this._itemRectCache) {\n      this._itemRectCache = {};\n    }\n    for (var i = 0; i < allElements.length; i++) {\n      var element = allElements[i];\n      var index = element.getAttribute('data-selection-index');\n      // Pull the memoized rectangle for the item, or the get the rect and memoize.\n      var itemRect = this._itemRectCache[index];\n      if (!itemRect) {\n        itemRect = element.getBoundingClientRect();\n        // Normalize the item rect to the dragRect coordinates.\n        itemRect = {\n          left: itemRect.left - rootRect.left,\n          top: itemRect.top - rootRect.top,\n          width: itemRect.width,\n          height: itemRect.height,\n          right: itemRect.left - rootRect.left + itemRect.width,\n          bottom: itemRect.top - rootRect.top + itemRect.height\n        };\n        if (itemRect.width > 0 && itemRect.height > 0) {\n          this._itemRectCache[index] = itemRect;\n        }\n      }\n      if (itemRect.top < dragRect.top + dragRect.height && itemRect.bottom > dragRect.top && itemRect.left < dragRect.left + dragRect.width && itemRect.right > dragRect.left) {\n        this._selectedIndicies[index] = true;\n      } else {\n        delete this._selectedIndicies[index];\n      }\n    }\n    // set previousSelectedIndices to be all of the selected indices from last time\n    var previousSelectedIndices = this._allSelectedIndices || {};\n    this._allSelectedIndices = {};\n    // set all indices that are supposed to be selected in _allSelectedIndices\n    for (var index in this._selectedIndicies) {\n      if (this._selectedIndicies.hasOwnProperty(index)) {\n        this._allSelectedIndices[index] = true;\n      }\n    }\n    if (this._preservedIndicies) {\n      for (var _i = 0, _a = this._preservedIndicies; _i < _a.length; _i++) {\n        var index = _a[_i];\n        this._allSelectedIndices[index] = true;\n      }\n    }\n    // check if needs to update selection, only when current _allSelectedIndices\n    // is different than previousSelectedIndices\n    var needToUpdate = false;\n    for (var index in this._allSelectedIndices) {\n      if (this._allSelectedIndices[index] !== previousSelectedIndices[index]) {\n        needToUpdate = true;\n        break;\n      }\n    }\n    if (!needToUpdate) {\n      for (var index in previousSelectedIndices) {\n        if (this._allSelectedIndices[index] !== previousSelectedIndices[index]) {\n          needToUpdate = true;\n          break;\n        }\n      }\n    }\n    // only update selection when needed\n    if (needToUpdate) {\n      // Stop change events, clear selection to re-populate.\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n      for (var _b = 0, _c = Object.keys(this._allSelectedIndices); _b < _c.length; _b++) {\n        var index = _c[_b];\n        selection.setIndexSelected(Number(index), true, false);\n      }\n      selection.setChangeEvents(true);\n    }\n  };\n  MarqueeSelectionBase.defaultProps = {\n    rootTagName: 'div',\n    rootProps: {},\n    isEnabled: true\n  };\n  return MarqueeSelectionBase;\n}(React.Component);\nexport { MarqueeSelectionBase };","map":{"version":3,"names":["React","Async","EventGroup","AutoScroll","classNamesFunction","findScrollableParent","getDistanceBetweenPoints","getRTL","initializeComponentRef","getClassNames","MIN_DRAG_DISTANCE","MarqueeSelectionBase","_super","__extends","props","_this","call","_root","createRef","_onMouseDown","ev","_a","isEnabled","onShouldStartSelection","_isMouseEventOnScrollbar","_isInSelectionToggle","_isTouch","_isDragStartInSelection","_scrollableSurface","button","current","_selectedIndicies","_preservedIndicies","undefined","_events","on","window","_onAsyncMouseMove","_scrollableParent","_onMouseUp","_autoScroll","_scrollTop","scrollTop","_scrollLeft","scrollLeft","_rootRect","getBoundingClientRect","_onMouseMove","_onTouchStart","_async","setTimeout","_onPointerDown","pointerType","state","dragRect","prototype","componentDidMount","document","body","hitTarget","isDraggingConstrainedToRoot","componentWillUnmount","dispose","render","rootProps","children","theme","className","styles","classNames","createElement","__assign","root","ref","dragMask","box","style","boxFill","targetElement","target","targetScrollbarWidth","offsetWidth","clientWidth","targetScrollbarHeight","offsetHeight","clientHeight","targetRect","clientX","left","clientY","top","_getRootRect","width","height","requestAnimationFrame","stopPropagation","preventDefault","_lastMouseEvent","rootRect","currentPoint","_dragOrigin","buttons","selection","shiftKey","setAllSelected","getSelectedIndices","constrainedPoint","Math","max","min","abs","_evaluateSelection","setState","off","_itemRectCache","_isPointInRectangle","rectangle","point","bottom","right","getSelectedCount","allElements","querySelectorAll","i","length","element","index","Number","getAttribute","isIndexSelected","itemRect","parentElement","previousSelectedIndices","_allSelectedIndices","hasOwnProperty","_i","needToUpdate","setChangeEvents","_b","_c","Object","keys","setIndexSelected","defaultProps","rootTagName","Component"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/components/src/components/MarqueeSelection/MarqueeSelection.base.tsx"],"sourcesContent":["import * as React from 'react';\n\nimport {\n  Async,\n  EventGroup,\n  AutoScroll,\n  classNamesFunction,\n  findScrollableParent,\n  getDistanceBetweenPoints,\n  getRTL,\n  initializeComponentRef,\n} from '../../Utilities';\nimport type { Point, IRectangle } from '../../Utilities';\nimport type {\n  IMarqueeSelectionProps,\n  IMarqueeSelectionStyleProps,\n  IMarqueeSelectionStyles,\n} from './MarqueeSelection.types';\n\nconst getClassNames = classNamesFunction<IMarqueeSelectionStyleProps, IMarqueeSelectionStyles>();\n\nexport interface IMarqueeSelectionState {\n  dragOrigin?: Point;\n  dragRect?: IRectangle;\n}\n\n// We want to make the marquee selection start when the user drags a minimum distance. Otherwise we'd start\n// the drag even if they just click an item without moving.\nconst MIN_DRAG_DISTANCE = 5;\n\n/**\n * MarqueeSelection component abstracts managing a draggable rectangle which sets items selected/not selected.\n * Elements which have data-selectable-index attributes are queried and measured once to determine if they\n * fall within the bounds of the rectangle. The measure is memoized during the drag as a performance optimization\n * so if the items change sizes while dragging, that could cause incorrect results.\n */\nexport class MarqueeSelectionBase extends React.Component<IMarqueeSelectionProps, IMarqueeSelectionState> {\n  public static defaultProps = {\n    rootTagName: 'div',\n    rootProps: {},\n    isEnabled: true,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _root = React.createRef<HTMLDivElement>();\n  private _dragOrigin: Point | undefined;\n  private _rootRect: IRectangle;\n  private _lastMouseEvent: MouseEvent | undefined;\n  private _autoScroll: AutoScroll | undefined;\n  private _selectedIndicies: { [key: string]: boolean } | undefined;\n  private _preservedIndicies: number[] | undefined;\n  private _itemRectCache: { [key: string]: IRectangle } | undefined;\n  private _allSelectedIndices: { [key: string]: boolean } | undefined;\n  private _scrollableParent?: HTMLElement;\n  private _scrollableSurface?: HTMLElement;\n  private _scrollTop: number;\n  private _scrollLeft: number;\n  private _isTouch: boolean;\n\n  constructor(props: IMarqueeSelectionProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    this.state = {\n      dragRect: undefined,\n    };\n  }\n\n  public componentDidMount(): void {\n    this._scrollableParent = findScrollableParent(this._root.current) as HTMLElement;\n    this._scrollableSurface = this._scrollableParent === (window as any) ? document.body : this._scrollableParent;\n    // When scroll events come from window, we need to read scrollTop values from the body.\n\n    const hitTarget = this.props.isDraggingConstrainedToRoot ? this._root.current : this._scrollableSurface;\n\n    this._events.on(hitTarget, 'mousedown', this._onMouseDown);\n    this._events.on(hitTarget, 'touchstart', this._onTouchStart, true);\n    this._events.on(hitTarget, 'pointerdown', this._onPointerDown, true);\n  }\n\n  public componentWillUnmount(): void {\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n    delete this._scrollableParent;\n    delete this._scrollableSurface;\n\n    this._events.dispose();\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const { rootProps, children, theme, className, styles } = this.props;\n    const { dragRect } = this.state;\n\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n    });\n\n    return (\n      <div {...rootProps} className={classNames.root} ref={this._root}>\n        {children}\n        {dragRect && <div className={classNames.dragMask} />}\n        {dragRect && (\n          <div className={classNames.box} style={dragRect}>\n            <div className={classNames.boxFill} />\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  /** Determine if the mouse event occured on a scrollbar of the target element. */\n  private _isMouseEventOnScrollbar(ev: MouseEvent): boolean {\n    const targetElement = ev.target as HTMLElement;\n    const targetScrollbarWidth = targetElement.offsetWidth - targetElement.clientWidth;\n    const targetScrollbarHeight = targetElement.offsetHeight - targetElement.clientHeight;\n\n    if (targetScrollbarWidth || targetScrollbarHeight) {\n      const targetRect = targetElement.getBoundingClientRect();\n\n      // Check vertical scroll\n      if (getRTL(this.props.theme)) {\n        if (ev.clientX < targetRect.left + targetScrollbarWidth) {\n          return true;\n        }\n      } else {\n        if (ev.clientX > targetRect.left + targetElement.clientWidth) {\n          return true;\n        }\n      }\n\n      // Check horizontal scroll\n      if (ev.clientY > targetRect.top + targetElement.clientHeight) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _onMouseDown = (ev: MouseEvent): void => {\n    const { isEnabled, onShouldStartSelection } = this.props;\n\n    // Ensure the mousedown is within the boundaries of the target. If not, it may have been a click on a scrollbar.\n    if (this._isMouseEventOnScrollbar(ev)) {\n      return;\n    }\n\n    if (this._isInSelectionToggle(ev)) {\n      return;\n    }\n\n    if (\n      !this._isTouch &&\n      isEnabled &&\n      !this._isDragStartInSelection(ev) &&\n      (!onShouldStartSelection || onShouldStartSelection(ev))\n    ) {\n      if (this._scrollableSurface && ev.button === 0 && this._root.current) {\n        this._selectedIndicies = {};\n        this._preservedIndicies = undefined;\n        this._events.on(window, 'mousemove', this._onAsyncMouseMove, true);\n        this._events.on(this._scrollableParent, 'scroll', this._onAsyncMouseMove);\n        this._events.on(window, 'click', this._onMouseUp, true);\n\n        this._autoScroll = new AutoScroll(this._root.current);\n        this._scrollTop = this._scrollableSurface.scrollTop;\n        this._scrollLeft = this._scrollableSurface.scrollLeft;\n        this._rootRect = this._root.current.getBoundingClientRect();\n\n        this._onMouseMove(ev);\n      }\n    }\n  };\n\n  private _onTouchStart = (ev: TouchEvent): void => {\n    this._isTouch = true;\n\n    this._async.setTimeout(() => {\n      this._isTouch = false;\n    }, 0);\n  };\n\n  private _onPointerDown = (ev: PointerEvent): void => {\n    if (ev.pointerType === 'touch') {\n      this._isTouch = true;\n\n      this._async.setTimeout(() => {\n        this._isTouch = false;\n      }, 0);\n    }\n  };\n\n  private _getRootRect(): IRectangle {\n    return {\n      left:\n        this._rootRect.left +\n        (this._scrollableSurface ? this._scrollLeft - this._scrollableSurface.scrollLeft : this._scrollLeft),\n      top:\n        this._rootRect.top +\n        (this._scrollableSurface ? this._scrollTop - this._scrollableSurface.scrollTop : this._scrollTop),\n      width: this._rootRect.width,\n      height: this._rootRect.height,\n    };\n  }\n\n  private _onAsyncMouseMove(ev: MouseEvent): void {\n    this._async.requestAnimationFrame(() => {\n      this._onMouseMove(ev);\n    });\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  }\n\n  private _onMouseMove(ev: MouseEvent): boolean | undefined {\n    if (!this._autoScroll) {\n      return;\n    }\n\n    if (ev.clientX !== undefined) {\n      this._lastMouseEvent = ev;\n    }\n\n    const rootRect = this._getRootRect();\n    const currentPoint = { left: ev.clientX - rootRect.left, top: ev.clientY - rootRect.top };\n\n    if (!this._dragOrigin) {\n      this._dragOrigin = currentPoint;\n    }\n\n    if (ev.buttons !== undefined && ev.buttons === 0) {\n      this._onMouseUp(ev);\n    } else {\n      if (this.state.dragRect || getDistanceBetweenPoints(this._dragOrigin, currentPoint) > MIN_DRAG_DISTANCE) {\n        if (!this.state.dragRect) {\n          const { selection } = this.props;\n\n          if (!ev.shiftKey) {\n            selection.setAllSelected(false);\n          }\n\n          this._preservedIndicies = selection && selection.getSelectedIndices && selection.getSelectedIndices();\n        }\n\n        // We need to constrain the current point to the rootRect boundaries.\n        const constrainedPoint = this.props.isDraggingConstrainedToRoot\n          ? {\n              left: Math.max(0, Math.min(rootRect.width, this._lastMouseEvent!.clientX - rootRect.left)),\n              top: Math.max(0, Math.min(rootRect.height, this._lastMouseEvent!.clientY - rootRect.top)),\n            }\n          : {\n              left: this._lastMouseEvent!.clientX - rootRect.left,\n              top: this._lastMouseEvent!.clientY - rootRect.top,\n            };\n\n        const dragRect = {\n          left: Math.min(this._dragOrigin.left || 0, constrainedPoint.left),\n          top: Math.min(this._dragOrigin.top || 0, constrainedPoint.top),\n          width: Math.abs(constrainedPoint.left - (this._dragOrigin.left || 0)),\n          height: Math.abs(constrainedPoint.top - (this._dragOrigin.top || 0)),\n        };\n\n        this._evaluateSelection(dragRect, rootRect);\n\n        this.setState({ dragRect });\n      }\n    }\n\n    return false;\n  }\n\n  private _onMouseUp(ev: MouseEvent): void {\n    this._events.off(window);\n    this._events.off(this._scrollableParent, 'scroll');\n\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n\n    this._autoScroll = this._dragOrigin = this._lastMouseEvent = undefined;\n    this._selectedIndicies = this._itemRectCache = undefined;\n\n    if (this.state.dragRect) {\n      this.setState({\n        dragRect: undefined,\n      });\n\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  }\n\n  private _isPointInRectangle(rectangle: IRectangle, point: Point): boolean {\n    return (\n      !!point.top &&\n      rectangle.top < point.top &&\n      rectangle.bottom! > point.top &&\n      !!point.left &&\n      rectangle.left < point.left &&\n      rectangle.right! > point.left\n    );\n  }\n\n  /**\n   * We do not want to start the marquee if we're trying to marquee\n   * from within an existing marquee selection.\n   */\n  private _isDragStartInSelection(ev: MouseEvent): boolean {\n    const selection = this.props.selection;\n    if (!this._root.current || (selection && selection.getSelectedCount() === 0)) {\n      return false;\n    }\n\n    const allElements = this._root.current.querySelectorAll('[data-selection-index]');\n    for (let i = 0; i < allElements.length; i++) {\n      const element = allElements[i];\n      const index = Number(element.getAttribute('data-selection-index'));\n      if (selection.isIndexSelected(index)) {\n        const itemRect = element.getBoundingClientRect();\n        if (this._isPointInRectangle(itemRect, { left: ev.clientX, top: ev.clientY })) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  private _isInSelectionToggle(ev: MouseEvent): boolean {\n    let element: HTMLElement | null = ev.target as HTMLElement;\n\n    while (element && element !== this._root.current) {\n      if (element.getAttribute('data-selection-toggle') === 'true') {\n        return true;\n      }\n\n      element = element.parentElement;\n    }\n\n    return false;\n  }\n\n  private _evaluateSelection(dragRect: IRectangle, rootRect: IRectangle): void {\n    // Break early if we don't need to evaluate.\n    if (!dragRect || !this._root.current) {\n      return;\n    }\n\n    const { selection } = this.props;\n    const allElements = this._root.current.querySelectorAll('[data-selection-index]');\n\n    if (!this._itemRectCache) {\n      this._itemRectCache = {};\n    }\n\n    for (let i = 0; i < allElements.length; i++) {\n      const element = allElements[i];\n      const index = element.getAttribute('data-selection-index') as string;\n\n      // Pull the memoized rectangle for the item, or the get the rect and memoize.\n      let itemRect = this._itemRectCache[index];\n\n      if (!itemRect) {\n        itemRect = element.getBoundingClientRect();\n\n        // Normalize the item rect to the dragRect coordinates.\n        itemRect = {\n          left: itemRect.left - rootRect.left,\n          top: itemRect.top - rootRect.top,\n          width: itemRect.width,\n          height: itemRect.height,\n          right: itemRect.left - rootRect.left + itemRect.width,\n          bottom: itemRect.top - rootRect.top + itemRect.height,\n        };\n\n        if (itemRect.width > 0 && itemRect.height > 0) {\n          this._itemRectCache[index] = itemRect;\n        }\n      }\n\n      if (\n        itemRect.top < dragRect.top + dragRect.height &&\n        itemRect.bottom! > dragRect.top &&\n        itemRect.left < dragRect.left + dragRect.width &&\n        itemRect.right! > dragRect.left\n      ) {\n        this._selectedIndicies![index] = true;\n      } else {\n        delete this._selectedIndicies![index];\n      }\n    }\n\n    // set previousSelectedIndices to be all of the selected indices from last time\n    const previousSelectedIndices = this._allSelectedIndices || {};\n    this._allSelectedIndices = {};\n\n    // set all indices that are supposed to be selected in _allSelectedIndices\n    for (const index in this._selectedIndicies!) {\n      if (this._selectedIndicies!.hasOwnProperty(index)) {\n        this._allSelectedIndices![index] = true;\n      }\n    }\n\n    if (this._preservedIndicies) {\n      for (const index of this._preservedIndicies!) {\n        this._allSelectedIndices![index] = true;\n      }\n    }\n\n    // check if needs to update selection, only when current _allSelectedIndices\n    // is different than previousSelectedIndices\n    let needToUpdate = false;\n    for (const index in this._allSelectedIndices!) {\n      if (this._allSelectedIndices![index] !== previousSelectedIndices![index]) {\n        needToUpdate = true;\n        break;\n      }\n    }\n\n    if (!needToUpdate) {\n      for (const index in previousSelectedIndices!) {\n        if (this._allSelectedIndices![index] !== previousSelectedIndices![index]) {\n          needToUpdate = true;\n          break;\n        }\n      }\n    }\n\n    // only update selection when needed\n    if (needToUpdate) {\n      // Stop change events, clear selection to re-populate.\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n\n      for (const index of Object.keys(this._allSelectedIndices!)) {\n        selection.setIndexSelected(Number(index), true, false);\n      }\n\n      selection.setChangeEvents(true);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}