{"ast":null,"code":"export var DEFAULT_MASK_FORMAT_CHARS = {\n  '9': /[0-9]/,\n  a: /[a-zA-Z]/,\n  '*': /[a-zA-Z0-9]/\n};\n/**\n * Takes in the mask string and the formatCharacters and returns an array of MaskValues\n * Example:\n * mask = 'Phone Number: (999) - 9999'\n * return = [\n *    { value: undefined, displayIndex: 16, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 17, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 18, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 22, format: /[0-9]/ },\n * ]\n *\n * @param mask The string use to define the format of the displayed maskedValue.\n * @param formatChars An object defining how certain characters in the mask should accept input.\n */\nexport function parseMask(mask, formatChars) {\n  if (formatChars === void 0) {\n    formatChars = DEFAULT_MASK_FORMAT_CHARS;\n  }\n  if (!mask) {\n    return [];\n  }\n  var maskCharData = [];\n  // Count the escape characters in the mask string.\n  var escapedChars = 0;\n  for (var i = 0; i + escapedChars < mask.length; i++) {\n    var maskChar = mask.charAt(i + escapedChars);\n    if (maskChar === '\\\\') {\n      escapedChars++;\n    } else {\n      // Check if the maskChar is a format character.\n      var maskFormat = formatChars[maskChar];\n      if (maskFormat) {\n        maskCharData.push({\n          /**\n           * Do not add escapedChars to the displayIndex.\n           * The index refers to a position in the mask's displayValue.\n           * Since the backslashes don't appear in the displayValue,\n           * we do not add them to the charData displayIndex.\n           */\n          displayIndex: i,\n          format: maskFormat\n        });\n      }\n    }\n  }\n  return maskCharData;\n}\n/**\n * Takes in the mask string, an array of MaskValues, and the maskCharacter\n * returns the mask string formatted with the input values and maskCharacter.\n * If the maskChar is undefined, the maskDisplay is truncated to the last filled format character.\n * Example:\n * mask = 'Phone Number: (999) 999 - 9999'\n * maskCharData = '12345'\n * maskChar = '_'\n * return = 'Phone Number: (123) 45_ - ___'\n *\n * Example:\n * mask = 'Phone Number: (999) 999 - 9999'\n * value = '12345'\n * maskChar = undefined\n * return = 'Phone Number: (123) 45'\n *\n * @param mask The string use to define the format of the displayed maskedValue.\n * @param maskCharData The input values to insert into the mask string for displaying.\n * @param maskChar? A character to display in place of unfilled mask format characters.\n */\nexport function getMaskDisplay(mask, maskCharData, maskChar) {\n  var maskDisplay = mask;\n  if (!maskDisplay) {\n    return '';\n  }\n  // Remove all backslashes\n  maskDisplay = maskDisplay.replace(/\\\\/g, '');\n  // lastDisplayIndex is is used to truncate the string if necessary.\n  var lastDisplayIndex = 0;\n  if (maskCharData.length > 0) {\n    lastDisplayIndex = maskCharData[0].displayIndex - 1;\n  }\n  /**\n   * For each input value, replace the character in the maskDisplay with the value.\n   * If there is no value set for the format character, use the maskChar.\n   */\n  for (var _i = 0, maskCharData_1 = maskCharData; _i < maskCharData_1.length; _i++) {\n    var charData = maskCharData_1[_i];\n    var nextChar = ' ';\n    if (charData.value) {\n      nextChar = charData.value;\n      if (charData.displayIndex > lastDisplayIndex) {\n        lastDisplayIndex = charData.displayIndex;\n      }\n    } else {\n      if (maskChar) {\n        nextChar = maskChar;\n      }\n    }\n    // Insert the character into the maskdisplay at its corresponding index\n    maskDisplay = maskDisplay.slice(0, charData.displayIndex) + nextChar + maskDisplay.slice(charData.displayIndex + 1);\n  }\n  // Cut off all mask characters after the last filled format value\n  if (!maskChar) {\n    maskDisplay = maskDisplay.slice(0, lastDisplayIndex + 1);\n  }\n  return maskDisplay;\n}\n/**\n * Get the next format index right of or at a specified index.\n * If no index exists, returns the rightmost index.\n * @param maskCharData\n * @param index\n */\nexport function getRightFormatIndex(maskCharData, index) {\n  for (var i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= index) {\n      return maskCharData[i].displayIndex;\n    }\n  }\n  return maskCharData[maskCharData.length - 1].displayIndex;\n}\n/**\n * Get the next format index left of a specified index.\n * If no index exists, returns the leftmost index.\n * @param maskCharData\n * @param index\n */\nexport function getLeftFormatIndex(maskCharData, index) {\n  for (var i = maskCharData.length - 1; i >= 0; i--) {\n    if (maskCharData[i].displayIndex < index) {\n      return maskCharData[i].displayIndex;\n    }\n  }\n  return maskCharData[0].displayIndex;\n}\n/**\n * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n * @param selectionCount\n */\nexport function clearRange(maskCharData, selectionStart, selectionCount) {\n  for (var i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      if (maskCharData[i].displayIndex >= selectionStart + selectionCount) {\n        break;\n      }\n      maskCharData[i].value = undefined;\n    }\n  }\n  return maskCharData;\n}\n/**\n * Deletes the input character at or after a specified index and returns the new array of charData\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n */\nexport function clearNext(maskCharData, selectionStart) {\n  for (var i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      maskCharData[i].value = undefined;\n      break;\n    }\n  }\n  return maskCharData;\n}\n/**\n * Deletes the input character before a specified index and returns the new array of charData\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n */\nexport function clearPrev(maskCharData, selectionStart) {\n  for (var i = maskCharData.length - 1; i >= 0; i--) {\n    if (maskCharData[i].displayIndex < selectionStart) {\n      maskCharData[i].value = undefined;\n      break;\n    }\n  }\n  return maskCharData;\n}\n/**\n * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.\n * Modifies the maskCharData inplace with the passed string and returns the display index of the\n * next format character after the inserted string.\n * @param maskCharData\n * @param selectionStart\n * @param selectionCount\n * @return The displayIndex of the next format character\n */\nexport function insertString(maskCharData, selectionStart, newString) {\n  var stringIndex = 0;\n  var nextIndex = 0;\n  var isStringInserted = false;\n  // Iterate through _maskCharData finding values with a displayIndex after the specified range start\n  for (var i = 0; i < maskCharData.length && stringIndex < newString.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      isStringInserted = true;\n      nextIndex = maskCharData[i].displayIndex;\n      // Find the next character in the newString that matches the format\n      while (stringIndex < newString.length) {\n        // If the character matches the format regexp, set the maskCharData to the new character\n        if (maskCharData[i].format.test(newString.charAt(stringIndex))) {\n          maskCharData[i].value = newString.charAt(stringIndex++);\n          // Set the nextIndex to the display index of the next mask format character.\n          if (i + 1 < maskCharData.length) {\n            nextIndex = maskCharData[i + 1].displayIndex;\n          } else {\n            nextIndex++;\n          }\n          break;\n        }\n        stringIndex++;\n      }\n    }\n  }\n  return isStringInserted ? nextIndex : selectionStart;\n}","map":{"version":3,"names":["DEFAULT_MASK_FORMAT_CHARS","a","parseMask","mask","formatChars","maskCharData","escapedChars","i","length","maskChar","charAt","maskFormat","push","displayIndex","format","getMaskDisplay","maskDisplay","replace","lastDisplayIndex","_i","maskCharData_1","charData","nextChar","value","slice","getRightFormatIndex","index","getLeftFormatIndex","clearRange","selectionStart","selectionCount","undefined","clearNext","clearPrev","insertString","newString","stringIndex","nextIndex","isStringInserted","test"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/components/TextField/src/components/TextField/MaskedTextField/inputMask.ts"],"sourcesContent":["export interface IMaskValue {\n  value?: string;\n  /**\n   * This index refers to the index in the displayMask rather than the inputMask.\n   * This means that any escaped characters do not count toward this index.\n   */\n  displayIndex: number;\n  format: RegExp;\n}\n\nexport const DEFAULT_MASK_FORMAT_CHARS: { [key: string]: RegExp } = {\n  '9': /[0-9]/,\n  a: /[a-zA-Z]/,\n  '*': /[a-zA-Z0-9]/,\n};\n\n/**\n * Takes in the mask string and the formatCharacters and returns an array of MaskValues\n * Example:\n * mask = 'Phone Number: (999) - 9999'\n * return = [\n *    { value: undefined, displayIndex: 16, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 17, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 18, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 22, format: /[0-9]/ },\n * ]\n *\n * @param mask The string use to define the format of the displayed maskedValue.\n * @param formatChars An object defining how certain characters in the mask should accept input.\n */\nexport function parseMask(\n  mask: string | undefined,\n  formatChars: { [key: string]: RegExp } = DEFAULT_MASK_FORMAT_CHARS,\n): IMaskValue[] {\n  if (!mask) {\n    return [];\n  }\n\n  const maskCharData: IMaskValue[] = [];\n  // Count the escape characters in the mask string.\n  let escapedChars = 0;\n  for (let i = 0; i + escapedChars < mask.length; i++) {\n    const maskChar = mask.charAt(i + escapedChars);\n    if (maskChar === '\\\\') {\n      escapedChars++;\n    } else {\n      // Check if the maskChar is a format character.\n      const maskFormat = formatChars[maskChar];\n      if (maskFormat) {\n        maskCharData.push({\n          /**\n           * Do not add escapedChars to the displayIndex.\n           * The index refers to a position in the mask's displayValue.\n           * Since the backslashes don't appear in the displayValue,\n           * we do not add them to the charData displayIndex.\n           */\n          displayIndex: i,\n          format: maskFormat,\n        });\n      }\n    }\n  }\n\n  return maskCharData;\n}\n\n/**\n * Takes in the mask string, an array of MaskValues, and the maskCharacter\n * returns the mask string formatted with the input values and maskCharacter.\n * If the maskChar is undefined, the maskDisplay is truncated to the last filled format character.\n * Example:\n * mask = 'Phone Number: (999) 999 - 9999'\n * maskCharData = '12345'\n * maskChar = '_'\n * return = 'Phone Number: (123) 45_ - ___'\n *\n * Example:\n * mask = 'Phone Number: (999) 999 - 9999'\n * value = '12345'\n * maskChar = undefined\n * return = 'Phone Number: (123) 45'\n *\n * @param mask The string use to define the format of the displayed maskedValue.\n * @param maskCharData The input values to insert into the mask string for displaying.\n * @param maskChar? A character to display in place of unfilled mask format characters.\n */\nexport function getMaskDisplay(mask: string | undefined, maskCharData: IMaskValue[], maskChar?: string): string {\n  let maskDisplay = mask;\n\n  if (!maskDisplay) {\n    return '';\n  }\n\n  // Remove all backslashes\n  maskDisplay = maskDisplay.replace(/\\\\/g, '');\n\n  // lastDisplayIndex is is used to truncate the string if necessary.\n  let lastDisplayIndex = 0;\n  if (maskCharData.length > 0) {\n    lastDisplayIndex = maskCharData[0].displayIndex - 1;\n  }\n\n  /**\n   * For each input value, replace the character in the maskDisplay with the value.\n   * If there is no value set for the format character, use the maskChar.\n   */\n  for (const charData of maskCharData) {\n    let nextChar = ' ';\n    if (charData.value) {\n      nextChar = charData.value;\n      if (charData.displayIndex > lastDisplayIndex) {\n        lastDisplayIndex = charData.displayIndex;\n      }\n    } else {\n      if (maskChar) {\n        nextChar = maskChar;\n      }\n    }\n\n    // Insert the character into the maskdisplay at its corresponding index\n    maskDisplay = maskDisplay.slice(0, charData.displayIndex) + nextChar + maskDisplay.slice(charData.displayIndex + 1);\n  }\n\n  // Cut off all mask characters after the last filled format value\n  if (!maskChar) {\n    maskDisplay = maskDisplay.slice(0, lastDisplayIndex + 1);\n  }\n\n  return maskDisplay;\n}\n\n/**\n * Get the next format index right of or at a specified index.\n * If no index exists, returns the rightmost index.\n * @param maskCharData\n * @param index\n */\nexport function getRightFormatIndex(maskCharData: IMaskValue[], index: number): number {\n  for (let i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= index) {\n      return maskCharData[i].displayIndex;\n    }\n  }\n  return maskCharData[maskCharData.length - 1].displayIndex;\n}\n\n/**\n * Get the next format index left of a specified index.\n * If no index exists, returns the leftmost index.\n * @param maskCharData\n * @param index\n */\nexport function getLeftFormatIndex(maskCharData: IMaskValue[], index: number): number {\n  for (let i = maskCharData.length - 1; i >= 0; i--) {\n    if (maskCharData[i].displayIndex < index) {\n      return maskCharData[i].displayIndex;\n    }\n  }\n  return maskCharData[0].displayIndex;\n}\n\n/**\n * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n * @param selectionCount\n */\nexport function clearRange(maskCharData: IMaskValue[], selectionStart: number, selectionCount: number): IMaskValue[] {\n  for (let i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      if (maskCharData[i].displayIndex >= selectionStart + selectionCount) {\n        break;\n      }\n      maskCharData[i].value = undefined;\n    }\n  }\n  return maskCharData;\n}\n\n/**\n * Deletes the input character at or after a specified index and returns the new array of charData\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n */\nexport function clearNext(maskCharData: IMaskValue[], selectionStart: number): IMaskValue[] {\n  for (let i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      maskCharData[i].value = undefined;\n      break;\n    }\n  }\n  return maskCharData;\n}\n\n/**\n * Deletes the input character before a specified index and returns the new array of charData\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n */\nexport function clearPrev(maskCharData: IMaskValue[], selectionStart: number): IMaskValue[] {\n  for (let i = maskCharData.length - 1; i >= 0; i--) {\n    if (maskCharData[i].displayIndex < selectionStart) {\n      maskCharData[i].value = undefined;\n      break;\n    }\n  }\n  return maskCharData;\n}\n\n/**\n * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.\n * Modifies the maskCharData inplace with the passed string and returns the display index of the\n * next format character after the inserted string.\n * @param maskCharData\n * @param selectionStart\n * @param selectionCount\n * @return The displayIndex of the next format character\n */\nexport function insertString(maskCharData: IMaskValue[], selectionStart: number, newString: string): number {\n  let stringIndex = 0;\n  let nextIndex = 0;\n  let isStringInserted = false;\n\n  // Iterate through _maskCharData finding values with a displayIndex after the specified range start\n  for (let i = 0; i < maskCharData.length && stringIndex < newString.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      isStringInserted = true;\n      nextIndex = maskCharData[i].displayIndex;\n      // Find the next character in the newString that matches the format\n      while (stringIndex < newString.length) {\n        // If the character matches the format regexp, set the maskCharData to the new character\n        if (maskCharData[i].format.test(newString.charAt(stringIndex))) {\n          maskCharData[i].value = newString.charAt(stringIndex++);\n          // Set the nextIndex to the display index of the next mask format character.\n          if (i + 1 < maskCharData.length) {\n            nextIndex = maskCharData[i + 1].displayIndex;\n          } else {\n            nextIndex++;\n          }\n          break;\n        }\n        stringIndex++;\n      }\n    }\n  }\n\n  return isStringInserted ? nextIndex : selectionStart;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}