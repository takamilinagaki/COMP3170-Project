{"ast":null,"code":"/**\n * Determines the distance between two points.\n *\n * @public\n */\n/* eslint-disable deprecation/deprecation */\nexport function getDistanceBetweenPoints(point1, point2) {\n  var left1 = point1.left || point1.x || 0;\n  var top1 = point1.top || point1.y || 0;\n  var left2 = point2.left || point2.x || 0;\n  var top2 = point2.top || point2.y || 0;\n  /* eslint-enable deprecation/deprecation */\n  var distance = Math.sqrt(Math.pow(left1 - left2, 2) + Math.pow(top1 - top2, 2));\n  return distance;\n}\n/**\n * Produces a proportionally-scaled version of an input content size when fit to a bounding size.\n * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally\n * using either `contain` or `cover` fit behaviors.\n * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.\n * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.\n * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.\n * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.\n *\n * @param options - the options for the bounds fit operation\n */\nexport function fitContentToBounds(options) {\n  var contentSize = options.contentSize,\n    boundsSize = options.boundsSize,\n    _a = options.mode,\n    mode = _a === void 0 ? 'contain' : _a,\n    _b = options.maxScale,\n    maxScale = _b === void 0 ? 1 : _b;\n  var contentAspectRatio = contentSize.width / contentSize.height;\n  var boundsAspectRatio = boundsSize.width / boundsSize.height;\n  var scale;\n  if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {\n    scale = boundsSize.width / contentSize.width;\n  } else {\n    scale = boundsSize.height / contentSize.height;\n  }\n  var finalScale = Math.min(maxScale, scale);\n  return {\n    width: contentSize.width * finalScale,\n    height: contentSize.height * finalScale\n  };\n}\n/**\n * Calculates a number's precision based on the number of trailing\n * zeros if the number does not have a decimal indicated by a negative\n * precision. Otherwise, it calculates the number of digits after\n * the decimal point indicated by a positive precision.\n * @param value - the value to determine the precision of\n */\nexport function calculatePrecision(value) {\n  /**\n   * Group 1:\n   * [1-9]([0]+$) matches trailing zeros\n   * Group 2:\n   * \\.([0-9]*) matches all digits after a decimal point.\n   */\n  var groups = /[1-9]([0]+$)|\\.([0-9]*)/.exec(String(value));\n  if (!groups) {\n    return 0;\n  }\n  if (groups[1]) {\n    return -groups[1].length;\n  }\n  if (groups[2]) {\n    return groups[2].length;\n  }\n  return 0;\n}\n/**\n * Rounds a number to a certain level of precision. Accepts negative precision.\n * @param value - The value that is being rounded.\n * @param precision - The number of decimal places to round the number to\n */\nexport function precisionRound(value, precision, base) {\n  if (base === void 0) {\n    base = 10;\n  }\n  var exp = Math.pow(base, precision);\n  return Math.round(value * exp) / exp;\n}","map":{"version":3,"names":["getDistanceBetweenPoints","point1","point2","left1","left","x","top1","top","y","left2","top2","distance","Math","sqrt","pow","fitContentToBounds","options","contentSize","boundsSize","_a","mode","_b","maxScale","contentAspectRatio","width","height","boundsAspectRatio","scale","finalScale","min","calculatePrecision","value","groups","exec","String","length","precisionRound","precision","base","exp","round"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/utilities/src/math.ts"],"sourcesContent":["import type { Point } from './Point';\nimport type { ISize } from './ISize';\n\n/**\n * Determines the distance between two points.\n *\n * @public\n */\n/* eslint-disable deprecation/deprecation */\nexport function getDistanceBetweenPoints(point1: Point, point2: Point): number {\n  const left1 = point1.left || point1.x || 0;\n  const top1 = point1.top || point1.y || 0;\n  const left2 = point2.left || point2.x || 0;\n  const top2 = point2.top || point2.y || 0;\n  /* eslint-enable deprecation/deprecation */\n\n  let distance = Math.sqrt(Math.pow(left1 - left2, 2) + Math.pow(top1 - top2, 2));\n\n  return distance;\n}\n\n/**\n * The available fit modes. These should match the fit modes for CSS.\n */\nexport type FitMode = 'contain' | 'cover';\n\n/**\n * Options for fitting content sizes into bounding sizes.\n */\nexport interface IFitContentToBoundsOptions {\n  /**\n   * The size of the content to fit to the bounds.\n   * The output will be proportional to this value.\n   */\n  contentSize: ISize;\n  /**\n   * The size of the bounds.\n   */\n  boundsSize: ISize;\n  /**\n   * The fit mode to apply, either 'contain' or 'cover'.\n   */\n  mode: FitMode;\n  /**\n   * An optional maximum scale factor to apply. The default is 1.\n   * Use Infinity for an unbounded resize.\n   */\n  maxScale?: number;\n}\n\n/**\n * Produces a proportionally-scaled version of an input content size when fit to a bounding size.\n * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally\n * using either `contain` or `cover` fit behaviors.\n * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.\n * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.\n * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.\n * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.\n *\n * @param options - the options for the bounds fit operation\n */\nexport function fitContentToBounds(options: IFitContentToBoundsOptions): ISize {\n  const { contentSize, boundsSize, mode = 'contain', maxScale = 1 } = options;\n\n  const contentAspectRatio = contentSize.width / contentSize.height;\n  const boundsAspectRatio = boundsSize.width / boundsSize.height;\n\n  let scale: number;\n\n  if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {\n    scale = boundsSize.width / contentSize.width;\n  } else {\n    scale = boundsSize.height / contentSize.height;\n  }\n\n  const finalScale = Math.min(maxScale, scale);\n\n  return {\n    width: contentSize.width * finalScale,\n    height: contentSize.height * finalScale,\n  };\n}\n\n/**\n * Calculates a number's precision based on the number of trailing\n * zeros if the number does not have a decimal indicated by a negative\n * precision. Otherwise, it calculates the number of digits after\n * the decimal point indicated by a positive precision.\n * @param value - the value to determine the precision of\n */\nexport function calculatePrecision(value: number | string): number {\n  /**\n   * Group 1:\n   * [1-9]([0]+$) matches trailing zeros\n   * Group 2:\n   * \\.([0-9]*) matches all digits after a decimal point.\n   */\n  const groups = /[1-9]([0]+$)|\\.([0-9]*)/.exec(String(value));\n  if (!groups) {\n    return 0;\n  }\n  if (groups[1]) {\n    return -groups[1].length;\n  }\n  if (groups[2]) {\n    return groups[2].length;\n  }\n  return 0;\n}\n\n/**\n * Rounds a number to a certain level of precision. Accepts negative precision.\n * @param value - The value that is being rounded.\n * @param precision - The number of decimal places to round the number to\n */\nexport function precisionRound(value: number, precision: number, base: number = 10): number {\n  const exp = Math.pow(base, precision);\n  return Math.round(value * exp) / exp;\n}\n"],"mappings":"AAGA;;;;;AAKA;AACA,OAAM,SAAUA,wBAAwBA,CAACC,MAAa,EAAEC,MAAa;EACnE,IAAMC,KAAK,GAAGF,MAAM,CAACG,IAAI,IAAIH,MAAM,CAACI,CAAC,IAAI,CAAC;EAC1C,IAAMC,IAAI,GAAGL,MAAM,CAACM,GAAG,IAAIN,MAAM,CAACO,CAAC,IAAI,CAAC;EACxC,IAAMC,KAAK,GAAGP,MAAM,CAACE,IAAI,IAAIF,MAAM,CAACG,CAAC,IAAI,CAAC;EAC1C,IAAMK,IAAI,GAAGR,MAAM,CAACK,GAAG,IAAIL,MAAM,CAACM,CAAC,IAAI,CAAC;EACxC;EAEA,IAAIG,QAAQ,GAAGC,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAACX,KAAK,GAAGM,KAAK,EAAE,CAAC,CAAC,GAAGG,IAAI,CAACE,GAAG,CAACR,IAAI,GAAGI,IAAI,EAAE,CAAC,CAAC,CAAC;EAE/E,OAAOC,QAAQ;AACjB;AA+BA;;;;;;;;;;;AAWA,OAAM,SAAUI,kBAAkBA,CAACC,OAAmC;EAC5D,IAAAC,WAAW,GAAiDD,OAAO,CAAAC,WAAxD;IAAEC,UAAU,GAAqCF,OAAO,CAAAE,UAA5C;IAAEC,EAAA,GAAmCH,OAAO,CAAAI,IAA1B;IAAhBA,IAAI,GAAAD,EAAA,cAAG,SAAS,GAAAA,EAAA;IAAEE,EAAA,GAAiBL,OAAO,CAAAM,QAAZ;IAAZA,QAAQ,GAAAD,EAAA,cAAG,CAAC,GAAAA,EAAA;EAE/D,IAAME,kBAAkB,GAAGN,WAAW,CAACO,KAAK,GAAGP,WAAW,CAACQ,MAAM;EACjE,IAAMC,iBAAiB,GAAGR,UAAU,CAACM,KAAK,GAAGN,UAAU,CAACO,MAAM;EAE9D,IAAIE,KAAa;EAEjB,IAAIP,IAAI,KAAK,SAAS,GAAGG,kBAAkB,GAAGG,iBAAiB,GAAGH,kBAAkB,GAAGG,iBAAiB,EAAE;IACxGC,KAAK,GAAGT,UAAU,CAACM,KAAK,GAAGP,WAAW,CAACO,KAAK;GAC7C,MAAM;IACLG,KAAK,GAAGT,UAAU,CAACO,MAAM,GAAGR,WAAW,CAACQ,MAAM;;EAGhD,IAAMG,UAAU,GAAGhB,IAAI,CAACiB,GAAG,CAACP,QAAQ,EAAEK,KAAK,CAAC;EAE5C,OAAO;IACLH,KAAK,EAAEP,WAAW,CAACO,KAAK,GAAGI,UAAU;IACrCH,MAAM,EAAER,WAAW,CAACQ,MAAM,GAAGG;GAC9B;AACH;AAEA;;;;;;;AAOA,OAAM,SAAUE,kBAAkBA,CAACC,KAAsB;EACvD;;;;;;EAMA,IAAMC,MAAM,GAAG,yBAAyB,CAACC,IAAI,CAACC,MAAM,CAACH,KAAK,CAAC,CAAC;EAC5D,IAAI,CAACC,MAAM,EAAE;IACX,OAAO,CAAC;;EAEV,IAAIA,MAAM,CAAC,CAAC,CAAC,EAAE;IACb,OAAO,CAACA,MAAM,CAAC,CAAC,CAAC,CAACG,MAAM;;EAE1B,IAAIH,MAAM,CAAC,CAAC,CAAC,EAAE;IACb,OAAOA,MAAM,CAAC,CAAC,CAAC,CAACG,MAAM;;EAEzB,OAAO,CAAC;AACV;AAEA;;;;;AAKA,OAAM,SAAUC,cAAcA,CAACL,KAAa,EAAEM,SAAiB,EAAEC,IAAiB;EAAjB,IAAAA,IAAA;IAAAA,IAAA,KAAiB;EAAA;EAChF,IAAMC,GAAG,GAAG3B,IAAI,CAACE,GAAG,CAACwB,IAAI,EAAED,SAAS,CAAC;EACrC,OAAOzB,IAAI,CAAC4B,KAAK,CAACT,KAAK,GAAGQ,GAAG,CAAC,GAAGA,GAAG;AACtC"},"metadata":{},"sourceType":"module","externalDependencies":[]}