{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport { find, isElementVisibleAndNotHidden, values } from '../../Utilities';\nimport { ktpTargetFromSequences, mergeOverflows, sequencesToID } from '../../utilities/keytips/KeytipUtils';\nimport { KTP_LAYER_ID } from '../../utilities/keytips/KeytipConstants';\n/**\n * This class is responsible for handling the parent/child relationships between keytips\n */\nvar KeytipTree = /** @class */function () {\n  /**\n   * KeytipTree constructor\n   */\n  function KeytipTree() {\n    this.nodeMap = {};\n    // Root has no keytipSequence\n    this.root = {\n      id: KTP_LAYER_ID,\n      children: [],\n      parent: '',\n      keySequences: []\n    };\n    this.nodeMap[this.root.id] = this.root;\n  }\n  /**\n   * Add a keytip node to this KeytipTree\n   *\n   * @param keytipProps - Keytip to add to the Tree\n   * @param uniqueID - Unique ID for this keytip\n   * @param persisted - T/F if this keytip should be marked as persisted\n   */\n  KeytipTree.prototype.addNode = function (keytipProps, uniqueID, persisted) {\n    var fullSequence = this._getFullSequence(keytipProps);\n    var nodeID = sequencesToID(fullSequence);\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    var parentID = this._getParentID(fullSequence);\n    // Create node and add to map\n    var node = this._createNode(nodeID, parentID, [], keytipProps, persisted);\n    this.nodeMap[uniqueID] = node;\n    // Try to add self to parents children\n    var parents = this.getNodes([parentID]);\n    parents.forEach(function (parent) {\n      return parent.children.push(nodeID);\n    });\n  };\n  /**\n   * Updates a node in the tree\n   *\n   * @param keytipProps - Keytip props to update\n   * @param uniqueID - Unique ID for this keytip\n   */\n  KeytipTree.prototype.updateNode = function (keytipProps, uniqueID) {\n    var fullSequence = this._getFullSequence(keytipProps);\n    var nodeID = sequencesToID(fullSequence);\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    var parentID = this._getParentID(fullSequence);\n    var node = this.nodeMap[uniqueID];\n    var prevParent = node.parent;\n    if (node) {\n      // Fix parent nodes if needed\n      if (prevParent !== parentID) {\n        // If parent has changed, remove child from old parent\n        this._removeChildFromParents(prevParent, node.id);\n      }\n      if (node.id !== nodeID) {\n        // If the ID of the node has changed, update node's parent's array of children with new ID\n        var parents = this.getNodes([parentID]);\n        parents.forEach(function (parent) {\n          var index = parent.children.indexOf(node.id);\n          index >= 0 ? parent.children[index] = nodeID : parent.children.push(nodeID);\n        });\n      }\n      // Update values\n      node.id = nodeID;\n      node.keySequences = keytipProps.keySequences;\n      node.overflowSetSequence = keytipProps.overflowSetSequence;\n      node.onExecute = keytipProps.onExecute;\n      node.onReturn = keytipProps.onReturn;\n      node.hasDynamicChildren = keytipProps.hasDynamicChildren;\n      node.hasMenu = keytipProps.hasMenu;\n      node.parent = parentID;\n      node.disabled = keytipProps.disabled;\n    }\n  };\n  /**\n   * Removes a node from the KeytipTree\n   *\n   * @param sequence - full string of the node to remove\n   */\n  KeytipTree.prototype.removeNode = function (keytipProps, uniqueID) {\n    var fullSequence = this._getFullSequence(keytipProps);\n    var nodeID = sequencesToID(fullSequence);\n    // Take off the last sequence to calculate the parent ID\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    this._removeChildFromParents(this._getParentID(fullSequence), nodeID);\n    if (this.nodeMap[uniqueID]) {\n      // Remove the node from the nodeMap\n      delete this.nodeMap[uniqueID];\n    }\n  };\n  /**\n   * Searches the currentKeytip's children to exactly match a sequence. Will not match disabled nodes but\n   * will match persisted nodes\n   *\n   * @param keySequence - string to match\n   * @param currentKeytip - The keytip whose children will try to match\n   * @returns The node that exactly matched the keySequence, or undefined if none matched\n   */\n  KeytipTree.prototype.getExactMatchedNode = function (keySequence, currentKeytip) {\n    var _this = this;\n    var possibleNodes = this.getNodes(currentKeytip.children);\n    var matchingNodes = possibleNodes.filter(function (node) {\n      return _this._getNodeSequence(node) === keySequence && !node.disabled;\n    });\n    // If we found no nodes, we are done\n    if (matchingNodes.length === 0) {\n      return undefined;\n    }\n    // Since the matching nodes all have the same key sequence,\n    // Grab the first one build the correct selector\n    var node = matchingNodes[0];\n    // If we have exactly one node, return it\n    if (matchingNodes.length === 1) {\n      return node;\n    }\n    // Get the potential target elements based on a selector from the sequences\n    var keySequences = node.keySequences;\n    var overflowSetSequence = node.overflowSetSequence;\n    var fullKeySequences = overflowSetSequence ? mergeOverflows(keySequences, overflowSetSequence) : keySequences;\n    var keytipTargetSelector = ktpTargetFromSequences(fullKeySequences);\n    var potentialTargetElements = document.querySelectorAll(keytipTargetSelector);\n    // If we have less nodes than the potential target elements,\n    // we won't be able to map element to node, return the first node.\n    // Note, the number of nodes could be more than the number of potential\n    // target elements, if an OverflowSet is involved\n    if (matchingNodes.length < potentialTargetElements.length) {\n      return node;\n    }\n    // Attempt to find the node that corresponds to the first visible/non-hidden element\n    var matchingIndex = Array.from(potentialTargetElements).findIndex(function (element) {\n      return isElementVisibleAndNotHidden(element);\n    });\n    if (matchingIndex !== -1) {\n      return matchingNodes[matchingIndex];\n    }\n    // We did not find any visible elements associated with any of the nodes.\n    // We may be dealing with a keytip that is a submenu in an OverflowSet.\n    // Worst case, fall back to the first node returned\n    var overflowNode = matchingNodes.find(function (matchingNode) {\n      return matchingNode.hasOverflowSubMenu;\n    });\n    return overflowNode || node;\n  };\n  /**\n   * Searches the currentKeytip's children to find nodes that start with the given sequence. Will not match\n   * disabled nodes but will match persisted nodes\n   *\n   * @param keySequence - string to partially match\n   * @param currentKeytip - The keytip whose children will try to partially match\n   * @returns List of tree nodes that partially match the given sequence\n   */\n  KeytipTree.prototype.getPartiallyMatchedNodes = function (keySequence, currentKeytip) {\n    var _this = this;\n    // Get children that are persisted\n    var possibleNodes = this.getNodes(currentKeytip.children);\n    return possibleNodes.filter(function (node) {\n      return _this._getNodeSequence(node).indexOf(keySequence) === 0 && !node.disabled;\n    });\n  };\n  /**\n   * Get the non-persisted children of the give node\n   * If no node is given, will use the 'currentKeytip'\n   *\n   * @param node - Node to get the children for\n   * @returns List of node IDs that are the children of the node\n   */\n  KeytipTree.prototype.getChildren = function (node) {\n    var _this = this;\n    if (!node) {\n      node = this.currentKeytip;\n      if (!node) {\n        return [];\n      }\n    }\n    var children = node.children;\n    return Object.keys(this.nodeMap).reduce(function (nodes, key) {\n      if (children.indexOf(_this.nodeMap[key].id) >= 0 && !_this.nodeMap[key].persisted) {\n        nodes.push(_this.nodeMap[key].id);\n      }\n      return nodes;\n    }, []);\n  };\n  /**\n   * Gets all nodes from their IDs\n   *\n   * @param ids - List of keytip IDs\n   * @returns Array of nodes that match the given IDs, can be empty\n   */\n  KeytipTree.prototype.getNodes = function (ids) {\n    var _this = this;\n    return Object.keys(this.nodeMap).reduce(function (nodes, key) {\n      if (ids.indexOf(_this.nodeMap[key].id) >= 0) {\n        nodes.push(_this.nodeMap[key]);\n      }\n      return nodes;\n    }, []);\n  };\n  /**\n   * Gets a single node from its ID\n   *\n   * @param id - ID of the node to get\n   * @returns Node with the given ID, if found\n   */\n  KeytipTree.prototype.getNode = function (id) {\n    var nodeMapValues = values(this.nodeMap);\n    return find(nodeMapValues, function (node) {\n      return node.id === id;\n    });\n  };\n  /**\n   * Tests if the currentKeytip in this.keytipTree is the parent of 'keytipProps'\n   *\n   * @param keytipProps - Keytip to test the parent for\n   * @returns T/F if the currentKeytip is this keytipProps' parent\n   */\n  KeytipTree.prototype.isCurrentKeytipParent = function (keytipProps) {\n    if (this.currentKeytip) {\n      var fullSequence = __spreadArray([], keytipProps.keySequences, true);\n      if (keytipProps.overflowSetSequence) {\n        fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n      }\n      // Take off the last sequence to calculate the parent ID\n      fullSequence.pop();\n      // Parent ID is the root if there aren't any more sequences\n      var parentID = fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n      var matchesCurrWithoutOverflow = false;\n      if (this.currentKeytip.overflowSetSequence) {\n        var currKeytipIdWithoutOverflow = sequencesToID(this.currentKeytip.keySequences);\n        matchesCurrWithoutOverflow = currKeytipIdWithoutOverflow === parentID;\n      }\n      return matchesCurrWithoutOverflow || this.currentKeytip.id === parentID;\n    }\n    return false;\n  };\n  KeytipTree.prototype._getParentID = function (fullSequence) {\n    return fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n  };\n  KeytipTree.prototype._getFullSequence = function (keytipProps) {\n    var fullSequence = __spreadArray([], keytipProps.keySequences, true);\n    if (keytipProps.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n    }\n    return fullSequence;\n  };\n  KeytipTree.prototype._getNodeSequence = function (node) {\n    var fullSequence = __spreadArray([], node.keySequences, true);\n    if (node.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, node.overflowSetSequence);\n    }\n    return fullSequence[fullSequence.length - 1];\n  };\n  KeytipTree.prototype._createNode = function (id, parentId, children, keytipProps, persisted) {\n    var _this = this;\n    var keySequences = keytipProps.keySequences,\n      hasDynamicChildren = keytipProps.hasDynamicChildren,\n      overflowSetSequence = keytipProps.overflowSetSequence,\n      hasMenu = keytipProps.hasMenu,\n      onExecute = keytipProps.onExecute,\n      onReturn = keytipProps.onReturn,\n      disabled = keytipProps.disabled,\n      hasOverflowSubMenu = keytipProps.hasOverflowSubMenu;\n    var node = {\n      id: id,\n      keySequences: keySequences,\n      overflowSetSequence: overflowSetSequence,\n      parent: parentId,\n      children: children,\n      onExecute: onExecute,\n      onReturn: onReturn,\n      hasDynamicChildren: hasDynamicChildren,\n      hasMenu: hasMenu,\n      disabled: disabled,\n      persisted: persisted,\n      hasOverflowSubMenu: hasOverflowSubMenu\n    };\n    node.children = Object.keys(this.nodeMap).reduce(function (array, nodeMapKey) {\n      if (_this.nodeMap[nodeMapKey].parent === id) {\n        array.push(_this.nodeMap[nodeMapKey].id);\n      }\n      return array;\n    }, []);\n    return node;\n  };\n  KeytipTree.prototype._removeChildFromParents = function (parentID, childID) {\n    var parents = this.getNodes([parentID]);\n    parents.forEach(function (parent) {\n      var childIndex = parent.children.indexOf(childID);\n      if (childIndex >= 0) {\n        parent.children.splice(childIndex, 1);\n      }\n    });\n  };\n  return KeytipTree;\n}();\nexport { KeytipTree };","map":{"version":3,"names":["find","isElementVisibleAndNotHidden","values","ktpTargetFromSequences","mergeOverflows","sequencesToID","KTP_LAYER_ID","KeytipTree","nodeMap","root","id","children","parent","keySequences","prototype","addNode","keytipProps","uniqueID","persisted","fullSequence","_getFullSequence","nodeID","pop","parentID","_getParentID","node","_createNode","parents","getNodes","forEach","push","updateNode","prevParent","_removeChildFromParents","index","indexOf","overflowSetSequence","onExecute","onReturn","hasDynamicChildren","hasMenu","disabled","removeNode","getExactMatchedNode","keySequence","currentKeytip","_this","possibleNodes","matchingNodes","filter","_getNodeSequence","length","undefined","fullKeySequences","keytipTargetSelector","potentialTargetElements","document","querySelectorAll","matchingIndex","Array","from","findIndex","element","overflowNode","matchingNode","hasOverflowSubMenu","getPartiallyMatchedNodes","getChildren","Object","keys","reduce","nodes","key","ids","getNode","nodeMapValues","isCurrentKeytipParent","__spreadArray","matchesCurrWithoutOverflow","currKeytipIdWithoutOverflow","parentId","array","nodeMapKey","childID","childIndex","splice"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/components/src/components/KeytipLayer/KeytipTree.ts"],"sourcesContent":["import { find, isElementVisibleAndNotHidden, values } from '../../Utilities';\nimport { ktpTargetFromSequences, mergeOverflows, sequencesToID } from '../../utilities/keytips/KeytipUtils';\nimport { KTP_LAYER_ID } from '../../utilities/keytips/KeytipConstants';\nimport type { IKeytipProps } from '../../Keytip';\nimport type { IKeytipTreeNode } from './IKeytipTreeNode';\n\n/**\n * This class is responsible for handling the parent/child relationships between keytips\n */\nexport class KeytipTree {\n  public currentKeytip?: IKeytipTreeNode;\n  public root: IKeytipTreeNode;\n  public nodeMap: { [nodeId: string]: IKeytipTreeNode } = {};\n\n  /**\n   * KeytipTree constructor\n   */\n  constructor() {\n    // Root has no keytipSequence\n    this.root = {\n      id: KTP_LAYER_ID,\n      children: [],\n      parent: '',\n      keySequences: [],\n    };\n    this.nodeMap[this.root.id] = this.root;\n  }\n\n  /**\n   * Add a keytip node to this KeytipTree\n   *\n   * @param keytipProps - Keytip to add to the Tree\n   * @param uniqueID - Unique ID for this keytip\n   * @param persisted - T/F if this keytip should be marked as persisted\n   */\n  public addNode(keytipProps: IKeytipProps, uniqueID: string, persisted?: boolean): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    const parentID = this._getParentID(fullSequence);\n\n    // Create node and add to map\n    const node = this._createNode(nodeID, parentID, [], keytipProps, persisted);\n    this.nodeMap[uniqueID] = node;\n\n    // Try to add self to parents children\n    const parents = this.getNodes([parentID]);\n    parents.forEach(parent => parent.children.push(nodeID));\n  }\n\n  /**\n   * Updates a node in the tree\n   *\n   * @param keytipProps - Keytip props to update\n   * @param uniqueID - Unique ID for this keytip\n   */\n  public updateNode(keytipProps: IKeytipProps, uniqueID: string): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    const parentID = this._getParentID(fullSequence);\n    const node = this.nodeMap[uniqueID];\n    const prevParent = node.parent;\n    if (node) {\n      // Fix parent nodes if needed\n      if (prevParent !== parentID) {\n        // If parent has changed, remove child from old parent\n        this._removeChildFromParents(prevParent, node.id);\n      }\n      if (node.id !== nodeID) {\n        // If the ID of the node has changed, update node's parent's array of children with new ID\n        const parents = this.getNodes([parentID]);\n        parents.forEach(parent => {\n          const index = parent.children.indexOf(node.id);\n          index >= 0 ? (parent.children[index] = nodeID) : parent.children.push(nodeID);\n        });\n      }\n\n      // Update values\n      node.id = nodeID;\n      node.keySequences = keytipProps.keySequences;\n      node.overflowSetSequence = keytipProps.overflowSetSequence;\n      node.onExecute = keytipProps.onExecute;\n      node.onReturn = keytipProps.onReturn;\n      node.hasDynamicChildren = keytipProps.hasDynamicChildren;\n      node.hasMenu = keytipProps.hasMenu;\n      node.parent = parentID;\n      node.disabled = keytipProps.disabled;\n    }\n  }\n\n  /**\n   * Removes a node from the KeytipTree\n   *\n   * @param sequence - full string of the node to remove\n   */\n  public removeNode(keytipProps: IKeytipProps, uniqueID: string): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last sequence to calculate the parent ID\n    fullSequence.pop();\n\n    // Parent ID is the root if there aren't any more sequences\n    this._removeChildFromParents(this._getParentID(fullSequence), nodeID);\n\n    if (this.nodeMap[uniqueID]) {\n      // Remove the node from the nodeMap\n      delete this.nodeMap[uniqueID];\n    }\n  }\n\n  /**\n   * Searches the currentKeytip's children to exactly match a sequence. Will not match disabled nodes but\n   * will match persisted nodes\n   *\n   * @param keySequence - string to match\n   * @param currentKeytip - The keytip whose children will try to match\n   * @returns The node that exactly matched the keySequence, or undefined if none matched\n   */\n  public getExactMatchedNode(keySequence: string, currentKeytip: IKeytipTreeNode): IKeytipTreeNode | undefined {\n    const possibleNodes = this.getNodes(currentKeytip.children);\n    const matchingNodes = possibleNodes.filter((node: IKeytipTreeNode) => {\n      return this._getNodeSequence(node) === keySequence && !node.disabled;\n    });\n\n    // If we found no nodes, we are done\n    if (matchingNodes.length === 0) {\n      return undefined;\n    }\n\n    // Since the matching nodes all have the same key sequence,\n    // Grab the first one build the correct selector\n    const node = matchingNodes[0];\n\n    // If we have exactly one node, return it\n    if (matchingNodes.length === 1) {\n      return node;\n    }\n\n    // Get the potential target elements based on a selector from the sequences\n    const keySequences = node.keySequences;\n    const overflowSetSequence = node.overflowSetSequence;\n    const fullKeySequences = overflowSetSequence ? mergeOverflows(keySequences, overflowSetSequence) : keySequences;\n    const keytipTargetSelector = ktpTargetFromSequences(fullKeySequences);\n    const potentialTargetElements = document.querySelectorAll(keytipTargetSelector);\n\n    // If we have less nodes than the potential target elements,\n    // we won't be able to map element to node, return the first node.\n    // Note, the number of nodes could be more than the number of potential\n    // target elements, if an OverflowSet is involved\n    if (matchingNodes.length < potentialTargetElements.length) {\n      return node;\n    }\n\n    // Attempt to find the node that corresponds to the first visible/non-hidden element\n    const matchingIndex = Array.from(potentialTargetElements).findIndex((element: HTMLElement) =>\n      isElementVisibleAndNotHidden(element),\n    );\n    if (matchingIndex !== -1) {\n      return matchingNodes[matchingIndex];\n    }\n\n    // We did not find any visible elements associated with any of the nodes.\n    // We may be dealing with a keytip that is a submenu in an OverflowSet.\n    // Worst case, fall back to the first node returned\n    const overflowNode = matchingNodes.find(matchingNode => matchingNode.hasOverflowSubMenu);\n    return overflowNode || node;\n  }\n\n  /**\n   * Searches the currentKeytip's children to find nodes that start with the given sequence. Will not match\n   * disabled nodes but will match persisted nodes\n   *\n   * @param keySequence - string to partially match\n   * @param currentKeytip - The keytip whose children will try to partially match\n   * @returns List of tree nodes that partially match the given sequence\n   */\n  public getPartiallyMatchedNodes(keySequence: string, currentKeytip: IKeytipTreeNode): IKeytipTreeNode[] {\n    // Get children that are persisted\n    const possibleNodes = this.getNodes(currentKeytip.children);\n    return possibleNodes.filter((node: IKeytipTreeNode) => {\n      return this._getNodeSequence(node).indexOf(keySequence) === 0 && !node.disabled;\n    });\n  }\n\n  /**\n   * Get the non-persisted children of the give node\n   * If no node is given, will use the 'currentKeytip'\n   *\n   * @param node - Node to get the children for\n   * @returns List of node IDs that are the children of the node\n   */\n  public getChildren(node?: IKeytipTreeNode): string[] {\n    if (!node) {\n      node = this.currentKeytip;\n      if (!node) {\n        return [];\n      }\n    }\n    const children = node.children;\n    return Object.keys(this.nodeMap).reduce((nodes: string[], key: string): string[] => {\n      if (children.indexOf(this.nodeMap[key].id) >= 0 && !this.nodeMap[key].persisted) {\n        nodes.push(this.nodeMap[key].id);\n      }\n      return nodes;\n    }, []);\n  }\n\n  /**\n   * Gets all nodes from their IDs\n   *\n   * @param ids - List of keytip IDs\n   * @returns Array of nodes that match the given IDs, can be empty\n   */\n  public getNodes(ids: string[]): IKeytipTreeNode[] {\n    return Object.keys(this.nodeMap).reduce((nodes: IKeytipTreeNode[], key: string): IKeytipTreeNode[] => {\n      if (ids.indexOf(this.nodeMap[key].id) >= 0) {\n        nodes.push(this.nodeMap[key]);\n      }\n      return nodes;\n    }, []);\n  }\n\n  /**\n   * Gets a single node from its ID\n   *\n   * @param id - ID of the node to get\n   * @returns Node with the given ID, if found\n   */\n  public getNode(id: string): IKeytipTreeNode | undefined {\n    const nodeMapValues = values<IKeytipTreeNode>(this.nodeMap);\n    return find(nodeMapValues, (node: IKeytipTreeNode): boolean => {\n      return node.id === id;\n    });\n  }\n\n  /**\n   * Tests if the currentKeytip in this.keytipTree is the parent of 'keytipProps'\n   *\n   * @param keytipProps - Keytip to test the parent for\n   * @returns T/F if the currentKeytip is this keytipProps' parent\n   */\n  public isCurrentKeytipParent(keytipProps: IKeytipProps): boolean {\n    if (this.currentKeytip) {\n      let fullSequence = [...keytipProps.keySequences];\n      if (keytipProps.overflowSetSequence) {\n        fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n      }\n      // Take off the last sequence to calculate the parent ID\n      fullSequence.pop();\n      // Parent ID is the root if there aren't any more sequences\n      const parentID = fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n      let matchesCurrWithoutOverflow = false;\n      if (this.currentKeytip.overflowSetSequence) {\n        const currKeytipIdWithoutOverflow = sequencesToID(this.currentKeytip.keySequences);\n        matchesCurrWithoutOverflow = currKeytipIdWithoutOverflow === parentID;\n      }\n      return matchesCurrWithoutOverflow || this.currentKeytip.id === parentID;\n    }\n    return false;\n  }\n\n  private _getParentID(fullSequence: string[]): string {\n    return fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n  }\n\n  private _getFullSequence(keytipProps: IKeytipProps): string[] {\n    let fullSequence = [...keytipProps.keySequences];\n    if (keytipProps.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n    }\n    return fullSequence;\n  }\n\n  private _getNodeSequence(node: IKeytipTreeNode): string {\n    let fullSequence = [...node.keySequences];\n    if (node.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, node.overflowSetSequence);\n    }\n    return fullSequence[fullSequence.length - 1];\n  }\n\n  private _createNode(\n    id: string,\n    parentId: string,\n    children: string[],\n    keytipProps: IKeytipProps,\n    persisted?: boolean,\n  ): IKeytipTreeNode {\n    const {\n      keySequences,\n      hasDynamicChildren,\n      overflowSetSequence,\n      hasMenu,\n      onExecute,\n      onReturn,\n      disabled,\n      hasOverflowSubMenu,\n    } = keytipProps;\n    const node = {\n      id,\n      keySequences,\n      overflowSetSequence,\n      parent: parentId,\n      children,\n      onExecute,\n      onReturn,\n      hasDynamicChildren,\n      hasMenu,\n      disabled,\n      persisted,\n      hasOverflowSubMenu,\n    };\n    node.children = Object.keys(this.nodeMap).reduce((array: string[], nodeMapKey: string): string[] => {\n      if (this.nodeMap[nodeMapKey].parent === id) {\n        array.push(this.nodeMap[nodeMapKey].id);\n      }\n      return array;\n    }, []);\n    return node;\n  }\n\n  private _removeChildFromParents(parentID: string, childID: string): void {\n    const parents = this.getNodes([parentID]);\n    parents.forEach(parent => {\n      const childIndex = parent.children.indexOf(childID);\n      if (childIndex >= 0) {\n        parent.children.splice(childIndex, 1);\n      }\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}