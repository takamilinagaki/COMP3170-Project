{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { KeyCodes, divProperties, doesElementContainFocus, getDocument, getNativeProps, getPropsWithDefaults, getWindow, modalize } from '../../Utilities';\nimport { useMergedRefs, useAsync, useOnEvent } from '@fluentui/react-hooks';\nimport { useWindow } from '@fluentui/react-window-provider';\nfunction useScrollbarAsync(props, root) {\n  var async = useAsync();\n  var _a = React.useState(false),\n    needsVerticalScrollBarState = _a[0],\n    setNeedsVerticalScrollBar = _a[1];\n  React.useEffect(function () {\n    async.requestAnimationFrame(function () {\n      var _a;\n      // If overflowY is overridden, don't waste time calculating whether the scrollbar is necessary.\n      if (props.style && props.style.overflowY) {\n        return;\n      }\n      var needsVerticalScrollBar = false;\n      if (root && root.current && ((_a = root.current) === null || _a === void 0 ? void 0 : _a.firstElementChild)) {\n        // ClientHeight returns the client height of an element rounded to an\n        // integer. On some browsers at different zoom levels this rounding\n        // can generate different results for the root container and child even\n        // though they are the same height. This causes us to show a scroll bar\n        // when not needed. Ideally we would use BoundingClientRect().height\n        // instead however seems that the API is 90% slower than using ClientHeight.\n        // Therefore instead we will calculate the difference between heights and\n        // allow for a 1px difference to still be considered ok and not show the\n        // scroll bar.\n        var rootHeight = root.current.clientHeight;\n        var firstChildHeight = root.current.firstElementChild.clientHeight;\n        if (rootHeight > 0 && firstChildHeight > rootHeight) {\n          needsVerticalScrollBar = firstChildHeight - rootHeight > 1;\n        }\n      }\n      if (needsVerticalScrollBarState !== needsVerticalScrollBar) {\n        setNeedsVerticalScrollBar(needsVerticalScrollBar);\n      }\n    });\n    return function () {\n      return async.dispose();\n    };\n  });\n  return needsVerticalScrollBarState;\n}\nfunction defaultFocusRestorer(options) {\n  var originalElement = options.originalElement,\n    containsFocus = options.containsFocus;\n  if (originalElement && containsFocus && originalElement !== getWindow()) {\n    // Make sure that the focus method actually exists\n    // In some cases the object might exist but not be a real element.\n    // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n    // This is wrapped in a setTimeout because of a React 16 bug that is resolved in 17.\n    // Once we move to 17, the setTimeout should be removed (ref: https://github.com/facebook/react/issues/17894#issuecomment-656094405)\n    setTimeout(function () {\n      var _a;\n      (_a = originalElement.focus) === null || _a === void 0 ? void 0 : _a.call(originalElement);\n    }, 0);\n  }\n}\nfunction useRestoreFocus(props, root) {\n  var _a = props.onRestoreFocus,\n    onRestoreFocus = _a === void 0 ? defaultFocusRestorer : _a;\n  var originalFocusedElement = React.useRef();\n  var containsFocus = React.useRef(false);\n  React.useEffect(function () {\n    originalFocusedElement.current = getDocument().activeElement;\n    if (doesElementContainFocus(root.current)) {\n      containsFocus.current = true;\n    }\n    return function () {\n      var _a;\n      onRestoreFocus === null || onRestoreFocus === void 0 ? void 0 : onRestoreFocus({\n        originalElement: originalFocusedElement.current,\n        containsFocus: containsFocus.current,\n        documentContainsFocus: ((_a = getDocument()) === null || _a === void 0 ? void 0 : _a.hasFocus()) || false\n      });\n      // De-reference DOM Node to avoid retainment via transpiled closure of _onKeyDown\n      originalFocusedElement.current = undefined;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on first render\n  }, []);\n  useOnEvent(root, 'focus', React.useCallback(function () {\n    containsFocus.current = true;\n  }, []), true);\n  useOnEvent(root, 'blur', React.useCallback(function (ev) {\n    /** The popup should update this._containsFocus when:\n     * relatedTarget exists AND\n     * the relatedTarget is not contained within the popup.\n     * If the relatedTarget is within the popup, that means the popup still has focus\n     * and focused moved from one element to another within the popup.\n     * If relatedTarget is undefined or null that usually means that a\n     * keyboard event occurred and focus didn't change\n     */\n    if (root.current && ev.relatedTarget && !root.current.contains(ev.relatedTarget)) {\n      containsFocus.current = false;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on first render\n  }, []), true);\n}\nfunction useHideSiblingNodes(props, root) {\n  // eslint-disable-next-line deprecation/deprecation\n  var shouldHideSiblings = String(props['aria-modal']).toLowerCase() === 'true' && props.enableAriaHiddenSiblings;\n  React.useEffect(function () {\n    if (!(shouldHideSiblings && root.current)) {\n      return;\n    }\n    var unmodalize = modalize(root.current);\n    return unmodalize;\n  }, [root, shouldHideSiblings]);\n}\n/**\n * This adds accessibility to Dialog and Panel controls\n */\nexport var Popup = React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var props = getPropsWithDefaults({\n    shouldRestoreFocus: true,\n    enableAriaHiddenSiblings: true\n  }, propsWithoutDefaults);\n  var root = React.useRef();\n  var mergedRootRef = useMergedRefs(root, forwardedRef);\n  useHideSiblingNodes(props, root);\n  useRestoreFocus(props, root);\n  var role = props.role,\n    className = props.className,\n    ariaLabel = props.ariaLabel,\n    ariaLabelledBy = props.ariaLabelledBy,\n    ariaDescribedBy = props.ariaDescribedBy,\n    style = props.style,\n    children = props.children,\n    onDismiss = props.onDismiss;\n  var needsVerticalScrollBar = useScrollbarAsync(props, root);\n  var onKeyDown = React.useCallback(function (ev) {\n    // eslint-disable-next-line deprecation/deprecation\n    switch (ev.which) {\n      case KeyCodes.escape:\n        if (onDismiss) {\n          onDismiss(ev);\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n        break;\n    }\n  }, [onDismiss]);\n  var win = useWindow();\n  useOnEvent(win, 'keydown', onKeyDown);\n  return React.createElement(\"div\", __assign({\n    ref: mergedRootRef\n  }, getNativeProps(props, divProperties), {\n    className: className,\n    role: role,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-describedby\": ariaDescribedBy,\n    onKeyDown: onKeyDown,\n    style: __assign({\n      overflowY: needsVerticalScrollBar ? 'scroll' : undefined,\n      outline: 'none'\n    }, style)\n  }), children);\n});\nPopup.displayName = 'Popup';","map":{"version":3,"names":["React","KeyCodes","divProperties","doesElementContainFocus","getDocument","getNativeProps","getPropsWithDefaults","getWindow","modalize","useMergedRefs","useAsync","useOnEvent","useWindow","useScrollbarAsync","props","root","async","_a","useState","needsVerticalScrollBarState","setNeedsVerticalScrollBar","useEffect","requestAnimationFrame","style","overflowY","needsVerticalScrollBar","current","firstElementChild","rootHeight","clientHeight","firstChildHeight","dispose","defaultFocusRestorer","options","originalElement","containsFocus","setTimeout","focus","call","useRestoreFocus","onRestoreFocus","originalFocusedElement","useRef","activeElement","documentContainsFocus","hasFocus","undefined","useCallback","ev","relatedTarget","contains","useHideSiblingNodes","shouldHideSiblings","String","toLowerCase","enableAriaHiddenSiblings","unmodalize","Popup","forwardRef","propsWithoutDefaults","forwardedRef","shouldRestoreFocus","mergedRootRef","role","className","ariaLabel","ariaLabelledBy","ariaDescribedBy","children","onDismiss","onKeyDown","which","escape","preventDefault","stopPropagation","win","createElement","__assign","ref","outline","displayName"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/components/src/components/Popup/Popup.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  KeyCodes,\n  divProperties,\n  doesElementContainFocus,\n  getDocument,\n  getNativeProps,\n  getPropsWithDefaults,\n  getWindow,\n  modalize,\n} from '../../Utilities';\nimport { useMergedRefs, useAsync, useOnEvent } from '@fluentui/react-hooks';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport type { IPopupProps, IPopupRestoreFocusParams } from './Popup.types';\n\nfunction useScrollbarAsync(props: IPopupProps, root: React.RefObject<HTMLDivElement | undefined>) {\n  const async = useAsync();\n  const [needsVerticalScrollBarState, setNeedsVerticalScrollBar] = React.useState(false);\n  React.useEffect(() => {\n    async.requestAnimationFrame(() => {\n      // If overflowY is overridden, don't waste time calculating whether the scrollbar is necessary.\n      if (props.style && props.style.overflowY) {\n        return;\n      }\n\n      let needsVerticalScrollBar = false;\n      if (root && root.current && root.current?.firstElementChild) {\n        // ClientHeight returns the client height of an element rounded to an\n        // integer. On some browsers at different zoom levels this rounding\n        // can generate different results for the root container and child even\n        // though they are the same height. This causes us to show a scroll bar\n        // when not needed. Ideally we would use BoundingClientRect().height\n        // instead however seems that the API is 90% slower than using ClientHeight.\n        // Therefore instead we will calculate the difference between heights and\n        // allow for a 1px difference to still be considered ok and not show the\n        // scroll bar.\n        const rootHeight = root.current.clientHeight;\n        const firstChildHeight = root.current.firstElementChild.clientHeight;\n        if (rootHeight > 0 && firstChildHeight > rootHeight) {\n          needsVerticalScrollBar = firstChildHeight - rootHeight > 1;\n        }\n      }\n      if (needsVerticalScrollBarState !== needsVerticalScrollBar) {\n        setNeedsVerticalScrollBar(needsVerticalScrollBar);\n      }\n    });\n\n    return () => async.dispose();\n  });\n\n  return needsVerticalScrollBarState;\n}\n\nfunction defaultFocusRestorer(options: IPopupRestoreFocusParams) {\n  const { originalElement, containsFocus } = options;\n\n  if (originalElement && containsFocus && originalElement !== getWindow()) {\n    // Make sure that the focus method actually exists\n    // In some cases the object might exist but not be a real element.\n    // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n    // This is wrapped in a setTimeout because of a React 16 bug that is resolved in 17.\n    // Once we move to 17, the setTimeout should be removed (ref: https://github.com/facebook/react/issues/17894#issuecomment-656094405)\n    setTimeout(() => {\n      originalElement.focus?.();\n    }, 0);\n  }\n}\n\nfunction useRestoreFocus(props: IPopupProps, root: React.RefObject<HTMLDivElement | undefined>) {\n  const { onRestoreFocus = defaultFocusRestorer } = props;\n  const originalFocusedElement = React.useRef<HTMLElement>();\n  const containsFocus = React.useRef(false);\n\n  React.useEffect(() => {\n    originalFocusedElement.current = getDocument()!.activeElement as HTMLElement;\n\n    if (doesElementContainFocus(root.current!)) {\n      containsFocus.current = true;\n    }\n\n    return () => {\n      onRestoreFocus?.({\n        originalElement: originalFocusedElement.current,\n        containsFocus: containsFocus.current,\n        documentContainsFocus: getDocument()?.hasFocus() || false,\n      });\n\n      // De-reference DOM Node to avoid retainment via transpiled closure of _onKeyDown\n      originalFocusedElement.current = undefined;\n    };\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on first render\n  }, []);\n\n  useOnEvent(\n    root,\n    'focus',\n    React.useCallback((): void => {\n      containsFocus.current = true;\n    }, []),\n    true,\n  );\n\n  useOnEvent(\n    root,\n    'blur',\n    React.useCallback((ev: FocusEvent): void => {\n      /** The popup should update this._containsFocus when:\n       * relatedTarget exists AND\n       * the relatedTarget is not contained within the popup.\n       * If the relatedTarget is within the popup, that means the popup still has focus\n       * and focused moved from one element to another within the popup.\n       * If relatedTarget is undefined or null that usually means that a\n       * keyboard event occurred and focus didn't change\n       */\n      if (root.current && ev.relatedTarget && !root.current.contains(ev.relatedTarget as HTMLElement)) {\n        containsFocus.current = false;\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on first render\n    }, []),\n    true,\n  );\n}\n\nfunction useHideSiblingNodes(props: IPopupProps, root: React.RefObject<HTMLDivElement | undefined>) {\n  // eslint-disable-next-line deprecation/deprecation\n  const shouldHideSiblings = String(props['aria-modal']).toLowerCase() === 'true' && props.enableAriaHiddenSiblings;\n\n  React.useEffect(() => {\n    if (!(shouldHideSiblings && root.current)) {\n      return;\n    }\n\n    const unmodalize = modalize(root.current);\n    return unmodalize;\n  }, [root, shouldHideSiblings]);\n}\n\n/**\n * This adds accessibility to Dialog and Panel controls\n */\nexport const Popup: React.FunctionComponent<IPopupProps> = React.forwardRef<HTMLDivElement, IPopupProps>(\n  (propsWithoutDefaults, forwardedRef) => {\n    const props = getPropsWithDefaults(\n      { shouldRestoreFocus: true, enableAriaHiddenSiblings: true },\n      propsWithoutDefaults,\n    );\n\n    const root = React.useRef<HTMLDivElement>();\n    const mergedRootRef = useMergedRefs(root, forwardedRef) as React.Ref<HTMLDivElement>;\n\n    useHideSiblingNodes(props, root);\n    useRestoreFocus(props, root);\n\n    const { role, className, ariaLabel, ariaLabelledBy, ariaDescribedBy, style, children, onDismiss } = props;\n    const needsVerticalScrollBar = useScrollbarAsync(props, root);\n\n    const onKeyDown = React.useCallback(\n      (ev: React.KeyboardEvent<HTMLElement> | KeyboardEvent): void => {\n        // eslint-disable-next-line deprecation/deprecation\n        switch (ev.which) {\n          case KeyCodes.escape:\n            if (onDismiss) {\n              onDismiss(ev);\n\n              ev.preventDefault();\n              ev.stopPropagation();\n            }\n\n            break;\n        }\n      },\n      [onDismiss],\n    );\n\n    const win = useWindow();\n    useOnEvent(win, 'keydown', onKeyDown as (ev: Event) => void);\n\n    return (\n      <div\n        ref={mergedRootRef}\n        {...getNativeProps(props, divProperties)}\n        className={className}\n        role={role}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        aria-describedby={ariaDescribedBy}\n        onKeyDown={onKeyDown}\n        style={{ overflowY: needsVerticalScrollBar ? 'scroll' : undefined, outline: 'none', ...style }}\n      >\n        {children}\n      </div>\n    );\n  },\n);\nPopup.displayName = 'Popup';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}