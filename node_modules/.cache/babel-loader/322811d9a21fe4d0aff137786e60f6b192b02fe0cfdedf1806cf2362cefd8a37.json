{"ast":null,"code":"import { EventGroup, getDocument } from '../../Utilities';\nvar MOUSEDOWN_PRIMARY_BUTTON = 0; // for mouse down event we are using ev.button property, 0 means left button\nvar MOUSEMOVE_PRIMARY_BUTTON = 1; // for mouse move event we are using ev.buttons property, 1 means left button\nvar DragDropHelper = /** @class */function () {\n  function DragDropHelper(params) {\n    this._selection = params.selection;\n    this._dragEnterCounts = {};\n    this._activeTargets = {};\n    this._lastId = 0;\n    // To make this class cheap to create, which allows simplifying some logic elsewhere,\n    // only initialize the event group and global event handlers as needed.\n    this._initialized = false;\n  }\n  DragDropHelper.prototype.dispose = function () {\n    if (this._events) {\n      this._events.dispose();\n    }\n  };\n  DragDropHelper.prototype.subscribe = function (root, events, dragDropOptions) {\n    var _this = this;\n    if (!this._initialized) {\n      this._events = new EventGroup(this);\n      var doc = getDocument();\n      // clear drag data when mouse up, use capture event to ensure it will be run\n      if (doc) {\n        this._events.on(doc.body, 'mouseup', this._onMouseUp.bind(this), true);\n        this._events.on(doc, 'mouseup', this._onDocumentMouseUp.bind(this), true);\n      }\n      this._initialized = true;\n    }\n    var _a = dragDropOptions.key,\n      key = _a === void 0 ? \"\".concat(++this._lastId) : _a;\n    var handlers = [];\n    var onDragStart;\n    var onDragLeave;\n    var onDragEnter;\n    var onDragEnd;\n    var onDrop;\n    var onDragOver;\n    var onMouseDown;\n    var isDraggable;\n    var isDroppable;\n    var activeTarget;\n    if (dragDropOptions && root) {\n      var eventMap = dragDropOptions.eventMap,\n        context = dragDropOptions.context,\n        updateDropState_1 = dragDropOptions.updateDropState;\n      var dragDropTarget = {\n        root: root,\n        options: dragDropOptions,\n        key: key\n      };\n      isDraggable = this._isDraggable(dragDropTarget);\n      isDroppable = this._isDroppable(dragDropTarget);\n      if (isDraggable || isDroppable) {\n        if (eventMap) {\n          for (var _i = 0, eventMap_1 = eventMap; _i < eventMap_1.length; _i++) {\n            var event_1 = eventMap_1[_i];\n            var handler = {\n              callback: event_1.callback.bind(null, context),\n              eventName: event_1.eventName\n            };\n            handlers.push(handler);\n            this._events.on(root, handler.eventName, handler.callback);\n          }\n        }\n      }\n      if (isDroppable) {\n        // If the target is droppable, wire up global event listeners to track drop-related events.\n        onDragLeave = function (event) {\n          if (!event.isHandled) {\n            event.isHandled = true;\n            _this._dragEnterCounts[key]--;\n            if (_this._dragEnterCounts[key] === 0) {\n              updateDropState_1(false /* isDropping */, event);\n            }\n          }\n        };\n        onDragEnter = function (event) {\n          event.preventDefault(); // needed for IE\n          if (!event.isHandled) {\n            event.isHandled = true;\n            _this._dragEnterCounts[key]++;\n            if (_this._dragEnterCounts[key] === 1) {\n              updateDropState_1(true /* isDropping */, event);\n            }\n          }\n        };\n        onDragEnd = function (event) {\n          _this._dragEnterCounts[key] = 0;\n          updateDropState_1(false /* isDropping */, event);\n        };\n        onDrop = function (event) {\n          _this._dragEnterCounts[key] = 0;\n          updateDropState_1(false /* isDropping */, event);\n          if (dragDropOptions.onDrop) {\n            dragDropOptions.onDrop(dragDropOptions.context.data, event);\n          }\n        };\n        onDragOver = function (event) {\n          event.preventDefault();\n          if (dragDropOptions.onDragOver) {\n            dragDropOptions.onDragOver(dragDropOptions.context.data, event);\n          }\n        };\n        this._dragEnterCounts[key] = 0;\n        // dragenter and dragleave will be fired when hover to the child element\n        // but we only want to change state when enter or leave the current element\n        // use the count to ensure it.\n        events.on(root, 'dragenter', onDragEnter);\n        events.on(root, 'dragleave', onDragLeave);\n        events.on(root, 'dragend', onDragEnd);\n        events.on(root, 'drop', onDrop);\n        events.on(root, 'dragover', onDragOver);\n      }\n      if (isDraggable) {\n        // If the target is draggable, wire up local event listeners for mouse events.\n        onMouseDown = this._onMouseDown.bind(this, dragDropTarget);\n        onDragEnd = this._onDragEnd.bind(this, dragDropTarget);\n        // We need to add in data so that on Firefox we show the ghost element when dragging\n        onDragStart = function (event) {\n          var options = dragDropOptions;\n          if (options && options.onDragStart) {\n            options.onDragStart(options.context.data, options.context.index, _this._selection.getSelection(), event);\n          }\n          _this._isDragging = true;\n          if (event.dataTransfer) {\n            event.dataTransfer.setData('id', root.id);\n          }\n        };\n        events.on(root, 'dragstart', onDragStart);\n        events.on(root, 'mousedown', onMouseDown);\n        events.on(root, 'dragend', onDragEnd);\n      }\n      activeTarget = {\n        target: dragDropTarget,\n        dispose: function () {\n          if (_this._activeTargets[key] === activeTarget) {\n            delete _this._activeTargets[key];\n          }\n          if (root) {\n            for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {\n              var handler = handlers_1[_i];\n              _this._events.off(root, handler.eventName, handler.callback);\n            }\n            if (isDroppable) {\n              events.off(root, 'dragenter', onDragEnter);\n              events.off(root, 'dragleave', onDragLeave);\n              events.off(root, 'dragend', onDragEnd);\n              events.off(root, 'dragover', onDragOver);\n              events.off(root, 'drop', onDrop);\n            }\n            if (isDraggable) {\n              events.off(root, 'dragstart', onDragStart);\n              events.off(root, 'mousedown', onMouseDown);\n              events.off(root, 'dragend', onDragEnd);\n            }\n          }\n        }\n      };\n      this._activeTargets[key] = activeTarget;\n    }\n    return {\n      key: key,\n      dispose: function () {\n        if (activeTarget) {\n          activeTarget.dispose();\n        }\n      }\n    };\n  };\n  DragDropHelper.prototype.unsubscribe = function (root, key) {\n    var activeTarget = this._activeTargets[key];\n    if (activeTarget) {\n      activeTarget.dispose();\n    }\n  };\n  DragDropHelper.prototype._onDragEnd = function (target, event) {\n    var options = target.options;\n    if (options.onDragEnd) {\n      options.onDragEnd(options.context.data, event);\n    }\n  };\n  /**\n   * clear drag data when mouse up on body\n   */\n  DragDropHelper.prototype._onMouseUp = function (event) {\n    this._isDragging = false;\n    if (this._dragData) {\n      for (var _i = 0, _a = Object.keys(this._activeTargets); _i < _a.length; _i++) {\n        var key = _a[_i];\n        var activeTarget = this._activeTargets[key];\n        if (activeTarget.target.root) {\n          this._events.off(activeTarget.target.root, 'mousemove');\n          this._events.off(activeTarget.target.root, 'mouseleave');\n        }\n      }\n      if (this._dragData.dropTarget) {\n        // raise dragleave event to let dropTarget know it need to remove dropping style\n        EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n        EventGroup.raise(this._dragData.dropTarget.root, 'drop');\n      }\n    }\n    this._dragData = null;\n  };\n  /**\n   * clear drag data when mouse up outside of the document\n   */\n  DragDropHelper.prototype._onDocumentMouseUp = function (event) {\n    var doc = getDocument();\n    if (doc && event.target === doc.documentElement) {\n      this._onMouseUp(event);\n    }\n  };\n  /**\n   * when mouse move over a new drop target while dragging some items,\n   * fire dragleave on the old target and fire dragenter to the new target\n   * The target will handle style change on dragenter and dragleave events.\n   */\n  DragDropHelper.prototype._onMouseMove = function (target, event) {\n    var\n      // use buttons property here since ev.button in some edge case is not updating well during the move.\n      // but firefox doesn't support it, so we set the default value when it is not defined.\n      _a = event.buttons,\n      // use buttons property here since ev.button in some edge case is not updating well during the move.\n      // but firefox doesn't support it, so we set the default value when it is not defined.\n      buttons = _a === void 0 ? MOUSEMOVE_PRIMARY_BUTTON : _a;\n    if (this._dragData && buttons !== MOUSEMOVE_PRIMARY_BUTTON) {\n      // cancel mouse down event and return early when the primary button is not pressed\n      this._onMouseUp(event);\n      return;\n    }\n    var root = target.root,\n      key = target.key;\n    if (this._isDragging) {\n      if (this._isDroppable(target)) {\n        // we can have nested drop targets in the DOM, like a folder inside a group. In that case, when we drag into\n        // the inner target (folder), we first set dropTarget to the inner element. But the same event is bubbled to the\n        // outer target too, and we need to prevent the outer one from taking over.\n        // So, check if the last dropTarget is not a child of the current.\n        if (this._dragData) {\n          if (this._dragData.dropTarget && this._dragData.dropTarget.key !== key && !this._isChild(root, this._dragData.dropTarget.root)) {\n            if (this._dragEnterCounts[this._dragData.dropTarget.key] > 0) {\n              EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n              EventGroup.raise(root, 'dragenter');\n              this._dragData.dropTarget = target;\n            }\n          }\n        }\n      }\n    }\n  };\n  /**\n   * when mouse leave a target while dragging some items, fire dragleave to the target\n   */\n  DragDropHelper.prototype._onMouseLeave = function (target, event) {\n    if (this._isDragging) {\n      if (this._dragData && this._dragData.dropTarget && this._dragData.dropTarget.key === target.key) {\n        EventGroup.raise(target.root, 'dragleave');\n        this._dragData.dropTarget = undefined;\n      }\n    }\n  };\n  /**\n   * when mouse down on a draggable item, we start to track dragdata.\n   */\n  DragDropHelper.prototype._onMouseDown = function (target, event) {\n    if (event.button !== MOUSEDOWN_PRIMARY_BUTTON) {\n      // Ignore anything except the primary button.\n      return;\n    }\n    if (this._isDraggable(target)) {\n      this._dragData = {\n        clientX: event.clientX,\n        clientY: event.clientY,\n        eventTarget: event.target,\n        dragTarget: target\n      };\n      for (var _i = 0, _a = Object.keys(this._activeTargets); _i < _a.length; _i++) {\n        var key = _a[_i];\n        var activeTarget = this._activeTargets[key];\n        if (activeTarget.target.root) {\n          this._events.on(activeTarget.target.root, 'mousemove', this._onMouseMove.bind(this, activeTarget.target));\n          this._events.on(activeTarget.target.root, 'mouseleave', this._onMouseLeave.bind(this, activeTarget.target));\n        }\n      }\n    } else {\n      this._dragData = null;\n    }\n  };\n  /**\n   * determine whether the child target is a descendant of the parent\n   */\n  DragDropHelper.prototype._isChild = function (parentElement, childElement) {\n    while (childElement && childElement.parentElement) {\n      if (childElement.parentElement === parentElement) {\n        return true;\n      }\n      childElement = childElement.parentElement;\n    }\n    return false;\n  };\n  DragDropHelper.prototype._isDraggable = function (target) {\n    var options = target.options;\n    return !!(options.canDrag && options.canDrag(options.context.data));\n  };\n  DragDropHelper.prototype._isDroppable = function (target) {\n    // TODO: take the drag item into consideration to prevent dragging an item into the same group\n    var options = target.options;\n    var dragContext = this._dragData && this._dragData.dragTarget ? this._dragData.dragTarget.options.context : undefined;\n    return !!(options.canDrop && options.canDrop(options.context, dragContext));\n  };\n  return DragDropHelper;\n}();\nexport { DragDropHelper };","map":{"version":3,"names":["EventGroup","getDocument","MOUSEDOWN_PRIMARY_BUTTON","MOUSEMOVE_PRIMARY_BUTTON","DragDropHelper","params","_selection","selection","_dragEnterCounts","_activeTargets","_lastId","_initialized","prototype","dispose","_events","subscribe","root","events","dragDropOptions","_this","doc","on","body","_onMouseUp","bind","_onDocumentMouseUp","_a","key","concat","handlers","onDragStart","onDragLeave","onDragEnter","onDragEnd","onDrop","onDragOver","onMouseDown","isDraggable","isDroppable","activeTarget","eventMap","context","updateDropState_1","updateDropState","dragDropTarget","options","_isDraggable","_isDroppable","_i","eventMap_1","length","event_1","handler","callback","eventName","push","event","isHandled","preventDefault","data","_onMouseDown","_onDragEnd","index","getSelection","_isDragging","dataTransfer","setData","id","target","handlers_1","off","unsubscribe","_dragData","Object","keys","dropTarget","raise","documentElement","_onMouseMove","buttons","_isChild","_onMouseLeave","undefined","button","clientX","clientY","eventTarget","dragTarget","parentElement","childElement","canDrag","dragContext","canDrop"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/react/lib/utilities/src/utilities/dragdrop/DragDropHelper.tsx"],"sourcesContent":["import { EventGroup, getDocument } from '../../Utilities';\nimport type {\n  IDragDropHelper,\n  IDragDropTarget,\n  IDragDropOptions,\n  IDragDropEvent,\n  IDragDropContext,\n} from './interfaces';\nimport type { ISelection } from '../../utilities/selection/interfaces';\n\nconst MOUSEDOWN_PRIMARY_BUTTON = 0; // for mouse down event we are using ev.button property, 0 means left button\nconst MOUSEMOVE_PRIMARY_BUTTON = 1; // for mouse move event we are using ev.buttons property, 1 means left button\n\nexport interface IDragDropHelperParams {\n  selection: ISelection;\n  minimumPixelsForDrag?: number;\n}\n\nexport class DragDropHelper implements IDragDropHelper {\n  private _dragEnterCounts: { [key: string]: number };\n  private _isDragging: boolean;\n  private _dragData: {\n    eventTarget: EventTarget | null;\n    clientX: number;\n    clientY: number;\n    dataTransfer?: DataTransfer;\n    dropTarget?: IDragDropTarget;\n    dragTarget?: IDragDropTarget;\n  } | null;\n  private _selection: ISelection;\n  private _activeTargets: {\n    [key: string]: {\n      target: IDragDropTarget;\n      dispose: () => void;\n    };\n  };\n  private _events: EventGroup;\n  private _lastId: number;\n  private _initialized: boolean;\n\n  constructor(params: IDragDropHelperParams) {\n    this._selection = params.selection;\n    this._dragEnterCounts = {};\n    this._activeTargets = {};\n    this._lastId = 0;\n    // To make this class cheap to create, which allows simplifying some logic elsewhere,\n    // only initialize the event group and global event handlers as needed.\n    this._initialized = false;\n  }\n\n  public dispose(): void {\n    if (this._events) {\n      this._events.dispose();\n    }\n  }\n\n  public subscribe(\n    root: HTMLElement,\n    events: EventGroup,\n    dragDropOptions: IDragDropOptions,\n  ): {\n    key: string;\n    dispose(): void;\n  } {\n    if (!this._initialized) {\n      this._events = new EventGroup(this);\n\n      const doc = getDocument();\n\n      // clear drag data when mouse up, use capture event to ensure it will be run\n      if (doc) {\n        this._events.on(doc.body, 'mouseup', this._onMouseUp.bind(this), true);\n        this._events.on(doc, 'mouseup', this._onDocumentMouseUp.bind(this), true);\n      }\n\n      this._initialized = true;\n    }\n\n    const { key = `${++this._lastId}` } = dragDropOptions;\n\n    const handlers: {\n      callback: (context: IDragDropContext, event?: any) => void;\n      eventName: string;\n    }[] = [];\n\n    let onDragStart: (event: DragEvent) => void;\n    let onDragLeave: (event: DragEvent) => void;\n    let onDragEnter: (event: DragEvent) => void;\n    let onDragEnd: (event: DragEvent) => void;\n    let onDrop: (event: DragEvent) => void;\n    let onDragOver: (event: DragEvent) => void;\n    let onMouseDown: (event: MouseEvent) => void;\n\n    let isDraggable: boolean;\n    let isDroppable: boolean;\n\n    let activeTarget: {\n      target: IDragDropTarget;\n      dispose: () => void;\n    };\n\n    if (dragDropOptions && root) {\n      const { eventMap, context, updateDropState } = dragDropOptions;\n\n      const dragDropTarget: IDragDropTarget = {\n        root,\n        options: dragDropOptions,\n        key,\n      };\n\n      isDraggable = this._isDraggable(dragDropTarget);\n      isDroppable = this._isDroppable(dragDropTarget);\n\n      if (isDraggable || isDroppable) {\n        if (eventMap) {\n          for (const event of eventMap) {\n            const handler = {\n              callback: event.callback.bind(null, context),\n              eventName: event.eventName,\n            };\n\n            handlers.push(handler);\n\n            this._events.on(root, handler.eventName, handler.callback);\n          }\n        }\n      }\n\n      if (isDroppable) {\n        // If the target is droppable, wire up global event listeners to track drop-related events.\n        onDragLeave = (event: DragEvent) => {\n          if (!(event as IDragDropEvent).isHandled) {\n            (event as IDragDropEvent).isHandled = true;\n            this._dragEnterCounts[key]--;\n            if (this._dragEnterCounts[key] === 0) {\n              updateDropState(false /* isDropping */, event);\n            }\n          }\n        };\n\n        onDragEnter = (event: DragEvent) => {\n          event.preventDefault(); // needed for IE\n          if (!(event as IDragDropEvent).isHandled) {\n            (event as IDragDropEvent).isHandled = true;\n            this._dragEnterCounts[key]++;\n            if (this._dragEnterCounts[key] === 1) {\n              updateDropState(true /* isDropping */, event);\n            }\n          }\n        };\n\n        onDragEnd = (event: DragEvent) => {\n          this._dragEnterCounts[key] = 0;\n          updateDropState(false /* isDropping */, event);\n        };\n\n        onDrop = (event: DragEvent) => {\n          this._dragEnterCounts[key] = 0;\n          updateDropState(false /* isDropping */, event);\n\n          if (dragDropOptions.onDrop) {\n            dragDropOptions.onDrop(dragDropOptions.context.data, event);\n          }\n        };\n\n        onDragOver = (event: DragEvent) => {\n          event.preventDefault();\n          if (dragDropOptions.onDragOver) {\n            dragDropOptions.onDragOver(dragDropOptions.context.data, event);\n          }\n        };\n\n        this._dragEnterCounts[key] = 0;\n\n        // dragenter and dragleave will be fired when hover to the child element\n        // but we only want to change state when enter or leave the current element\n        // use the count to ensure it.\n        events.on(root, 'dragenter', onDragEnter);\n        events.on(root, 'dragleave', onDragLeave);\n        events.on(root, 'dragend', onDragEnd);\n        events.on(root, 'drop', onDrop);\n        events.on(root, 'dragover', onDragOver);\n      }\n\n      if (isDraggable) {\n        // If the target is draggable, wire up local event listeners for mouse events.\n        onMouseDown = this._onMouseDown.bind(this, dragDropTarget);\n        onDragEnd = this._onDragEnd.bind(this, dragDropTarget);\n\n        // We need to add in data so that on Firefox we show the ghost element when dragging\n        onDragStart = (event: DragEvent) => {\n          const options = dragDropOptions;\n          if (options && options.onDragStart) {\n            options.onDragStart(options.context.data, options.context.index, this._selection.getSelection(), event);\n          }\n          this._isDragging = true;\n          if (event.dataTransfer) {\n            event.dataTransfer.setData('id', root.id);\n          }\n        };\n\n        events.on(root, 'dragstart', onDragStart);\n        events.on(root, 'mousedown', onMouseDown);\n        events.on(root, 'dragend', onDragEnd);\n      }\n\n      activeTarget = {\n        target: dragDropTarget,\n        dispose: () => {\n          if (this._activeTargets[key] === activeTarget) {\n            delete this._activeTargets[key];\n          }\n\n          if (root) {\n            for (const handler of handlers) {\n              this._events.off(root, handler.eventName, handler.callback);\n            }\n\n            if (isDroppable) {\n              events.off(root, 'dragenter', onDragEnter);\n              events.off(root, 'dragleave', onDragLeave);\n              events.off(root, 'dragend', onDragEnd);\n              events.off(root, 'dragover', onDragOver);\n              events.off(root, 'drop', onDrop);\n            }\n\n            if (isDraggable) {\n              events.off(root, 'dragstart', onDragStart);\n              events.off(root, 'mousedown', onMouseDown);\n              events.off(root, 'dragend', onDragEnd);\n            }\n          }\n        },\n      };\n\n      this._activeTargets[key] = activeTarget;\n    }\n\n    return {\n      key,\n      dispose: () => {\n        if (activeTarget) {\n          activeTarget.dispose();\n        }\n      },\n    };\n  }\n\n  public unsubscribe(root: HTMLElement, key: string): void {\n    const activeTarget = this._activeTargets[key];\n\n    if (activeTarget) {\n      activeTarget.dispose();\n    }\n  }\n\n  private _onDragEnd(target: IDragDropTarget, event: DragEvent): void {\n    const { options } = target;\n    if (options.onDragEnd) {\n      options.onDragEnd(options.context.data, event);\n    }\n  }\n\n  /**\n   * clear drag data when mouse up on body\n   */\n  private _onMouseUp(event: MouseEvent): void {\n    this._isDragging = false;\n    if (this._dragData) {\n      for (const key of Object.keys(this._activeTargets)) {\n        const activeTarget = this._activeTargets[key];\n\n        if (activeTarget.target.root) {\n          this._events.off(activeTarget.target.root, 'mousemove');\n          this._events.off(activeTarget.target.root, 'mouseleave');\n        }\n      }\n\n      if (this._dragData.dropTarget) {\n        // raise dragleave event to let dropTarget know it need to remove dropping style\n        EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n        EventGroup.raise(this._dragData.dropTarget.root, 'drop');\n      }\n    }\n    this._dragData = null;\n  }\n\n  /**\n   * clear drag data when mouse up outside of the document\n   */\n  private _onDocumentMouseUp(event: MouseEvent): void {\n    const doc = getDocument();\n\n    if (doc && event.target === doc.documentElement) {\n      this._onMouseUp(event);\n    }\n  }\n\n  /**\n   * when mouse move over a new drop target while dragging some items,\n   * fire dragleave on the old target and fire dragenter to the new target\n   * The target will handle style change on dragenter and dragleave events.\n   */\n  private _onMouseMove(target: IDragDropTarget, event: MouseEvent): void {\n    const {\n      // use buttons property here since ev.button in some edge case is not updating well during the move.\n      // but firefox doesn't support it, so we set the default value when it is not defined.\n      buttons = MOUSEMOVE_PRIMARY_BUTTON,\n    } = event;\n\n    if (this._dragData && buttons !== MOUSEMOVE_PRIMARY_BUTTON) {\n      // cancel mouse down event and return early when the primary button is not pressed\n      this._onMouseUp(event);\n      return;\n    }\n\n    const { root, key } = target;\n    if (this._isDragging) {\n      if (this._isDroppable(target)) {\n        // we can have nested drop targets in the DOM, like a folder inside a group. In that case, when we drag into\n        // the inner target (folder), we first set dropTarget to the inner element. But the same event is bubbled to the\n        // outer target too, and we need to prevent the outer one from taking over.\n        // So, check if the last dropTarget is not a child of the current.\n\n        if (this._dragData) {\n          if (\n            this._dragData.dropTarget &&\n            this._dragData.dropTarget.key !== key &&\n            !this._isChild(root, this._dragData.dropTarget.root)\n          ) {\n            if (this._dragEnterCounts[this._dragData.dropTarget.key] > 0) {\n              EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n              EventGroup.raise(root, 'dragenter');\n              this._dragData.dropTarget = target;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * when mouse leave a target while dragging some items, fire dragleave to the target\n   */\n  private _onMouseLeave(target: IDragDropTarget, event: MouseEvent): void {\n    if (this._isDragging) {\n      if (this._dragData && this._dragData.dropTarget && this._dragData.dropTarget.key === target.key) {\n        EventGroup.raise(target.root, 'dragleave');\n        this._dragData.dropTarget = undefined;\n      }\n    }\n  }\n\n  /**\n   * when mouse down on a draggable item, we start to track dragdata.\n   */\n  private _onMouseDown(target: IDragDropTarget, event: MouseEvent): void {\n    if (event.button !== MOUSEDOWN_PRIMARY_BUTTON) {\n      // Ignore anything except the primary button.\n      return;\n    }\n\n    if (this._isDraggable(target)) {\n      this._dragData = {\n        clientX: event.clientX,\n        clientY: event.clientY,\n        eventTarget: event.target,\n        dragTarget: target,\n      };\n\n      for (const key of Object.keys(this._activeTargets)) {\n        const activeTarget = this._activeTargets[key];\n        if (activeTarget.target.root) {\n          this._events.on(activeTarget.target.root, 'mousemove', this._onMouseMove.bind(this, activeTarget.target));\n          this._events.on(activeTarget.target.root, 'mouseleave', this._onMouseLeave.bind(this, activeTarget.target));\n        }\n      }\n    } else {\n      this._dragData = null;\n    }\n  }\n\n  /**\n   * determine whether the child target is a descendant of the parent\n   */\n  private _isChild(parentElement: HTMLElement, childElement: HTMLElement): boolean {\n    while (childElement && childElement.parentElement) {\n      if (childElement.parentElement === parentElement) {\n        return true;\n      }\n      childElement = childElement.parentElement;\n    }\n    return false;\n  }\n\n  private _isDraggable(target: IDragDropTarget): boolean {\n    const { options } = target;\n    return !!(options.canDrag && options.canDrag(options.context.data));\n  }\n\n  private _isDroppable(target: IDragDropTarget): boolean {\n    // TODO: take the drag item into consideration to prevent dragging an item into the same group\n    const { options } = target;\n    const dragContext =\n      this._dragData && this._dragData.dragTarget ? this._dragData.dragTarget.options.context : undefined;\n    return !!(options.canDrop && options.canDrop(options.context, dragContext));\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}