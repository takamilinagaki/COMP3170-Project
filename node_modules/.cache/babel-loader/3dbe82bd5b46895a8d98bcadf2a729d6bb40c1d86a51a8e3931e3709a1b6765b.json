{"ast":null,"code":"import { getWindow } from './dom/getWindow';\n/**\n * Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled.\n * This Async helper class solves these issues by tying async code to the lifetime of a disposable object.\n *\n * Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a\n * new instance of the class and remember to call dispose() during your code's dispose handler.\n *\n * @public\n */\nvar Async = /** @class */function () {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function Async(parent, onError) {\n    this._timeoutIds = null;\n    this._immediateIds = null;\n    this._intervalIds = null;\n    this._animationFrameIds = null;\n    this._isDisposed = false;\n    this._parent = parent || null;\n    this._onErrorHandler = onError;\n    this._noop = function () {\n      /* do nothing */\n    };\n  }\n  /**\n   * Dispose function, clears all async operations.\n   */\n  Async.prototype.dispose = function () {\n    var id;\n    this._isDisposed = true;\n    this._parent = null;\n    // Clear timeouts.\n    if (this._timeoutIds) {\n      for (id in this._timeoutIds) {\n        if (this._timeoutIds.hasOwnProperty(id)) {\n          this.clearTimeout(parseInt(id, 10));\n        }\n      }\n      this._timeoutIds = null;\n    }\n    // Clear immediates.\n    if (this._immediateIds) {\n      for (id in this._immediateIds) {\n        if (this._immediateIds.hasOwnProperty(id)) {\n          this.clearImmediate(parseInt(id, 10));\n        }\n      }\n      this._immediateIds = null;\n    }\n    // Clear intervals.\n    if (this._intervalIds) {\n      for (id in this._intervalIds) {\n        if (this._intervalIds.hasOwnProperty(id)) {\n          this.clearInterval(parseInt(id, 10));\n        }\n      }\n      this._intervalIds = null;\n    }\n    // Clear animation frames.\n    if (this._animationFrameIds) {\n      for (id in this._animationFrameIds) {\n        if (this._animationFrameIds.hasOwnProperty(id)) {\n          this.cancelAnimationFrame(parseInt(id, 10));\n        }\n      }\n      this._animationFrameIds = null;\n    }\n  };\n  /**\n   * SetTimeout override, which will auto cancel the timeout during dispose.\n   * @param callback - Callback to execute.\n   * @param duration - Duration in milliseconds.\n   * @returns The setTimeout id.\n   */\n  Async.prototype.setTimeout = function (callback, duration) {\n    var _this = this;\n    var timeoutId = 0;\n    if (!this._isDisposed) {\n      if (!this._timeoutIds) {\n        this._timeoutIds = {};\n      }\n      timeoutId = setTimeout(function () {\n        // Time to execute the timeout, enqueue it as a foreground task to be executed.\n        try {\n          // Now delete the record and call the callback.\n          if (_this._timeoutIds) {\n            delete _this._timeoutIds[timeoutId];\n          }\n          callback.apply(_this._parent);\n        } catch (e) {\n          _this._logError(e);\n        }\n      }, duration);\n      this._timeoutIds[timeoutId] = true;\n    }\n    return timeoutId;\n  };\n  /**\n   * Clears the timeout.\n   * @param id - Id to cancel.\n   */\n  Async.prototype.clearTimeout = function (id) {\n    if (this._timeoutIds && this._timeoutIds[id]) {\n      clearTimeout(id);\n      delete this._timeoutIds[id];\n    }\n  };\n  /**\n   * SetImmediate override, which will auto cancel the immediate during dispose.\n   * @param callback - Callback to execute.\n   * @param targetElement - Optional target element to use for identifying the correct window.\n   * @returns The setTimeout id.\n   */\n  Async.prototype.setImmediate = function (callback, targetElement) {\n    var _this = this;\n    var immediateId = 0;\n    var win = getWindow(targetElement);\n    if (!this._isDisposed) {\n      if (!this._immediateIds) {\n        this._immediateIds = {};\n      }\n      var setImmediateCallback = function () {\n        // Time to execute the timeout, enqueue it as a foreground task to be executed.\n        try {\n          // Now delete the record and call the callback.\n          if (_this._immediateIds) {\n            delete _this._immediateIds[immediateId];\n          }\n          callback.apply(_this._parent);\n        } catch (e) {\n          _this._logError(e);\n        }\n      };\n      immediateId = win.setTimeout(setImmediateCallback, 0);\n      this._immediateIds[immediateId] = true;\n    }\n    return immediateId;\n  };\n  /**\n   * Clears the immediate.\n   * @param id - Id to cancel.\n   * @param targetElement - Optional target element to use for identifying the correct window.\n   */\n  Async.prototype.clearImmediate = function (id, targetElement) {\n    var win = getWindow(targetElement);\n    if (this._immediateIds && this._immediateIds[id]) {\n      win.clearTimeout(id);\n      delete this._immediateIds[id];\n    }\n  };\n  /**\n   * SetInterval override, which will auto cancel the timeout during dispose.\n   * @param callback - Callback to execute.\n   * @param duration - Duration in milliseconds.\n   * @returns The setTimeout id.\n   */\n  Async.prototype.setInterval = function (callback, duration) {\n    var _this = this;\n    var intervalId = 0;\n    if (!this._isDisposed) {\n      if (!this._intervalIds) {\n        this._intervalIds = {};\n      }\n      intervalId = setInterval(function () {\n        // Time to execute the interval callback, enqueue it as a foreground task to be executed.\n        try {\n          callback.apply(_this._parent);\n        } catch (e) {\n          _this._logError(e);\n        }\n      }, duration);\n      this._intervalIds[intervalId] = true;\n    }\n    return intervalId;\n  };\n  /**\n   * Clears the interval.\n   * @param id - Id to cancel.\n   */\n  Async.prototype.clearInterval = function (id) {\n    if (this._intervalIds && this._intervalIds[id]) {\n      clearInterval(id);\n      delete this._intervalIds[id];\n    }\n  };\n  /**\n   * Creates a function that, when executed, will only call the func function at most once per\n   * every wait milliseconds. Provide an options object to indicate that func should be invoked\n   * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled\n   * function will return the result of the last func call.\n   *\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\n   * the timeout only if the throttled function is invoked more than once during the wait timeout.\n   *\n   * @param func - The function to throttle.\n   * @param wait - The number of milliseconds to throttle executions to. Defaults to 0.\n   * @param options - The options object.\n   * @returns The new throttled function.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Async.prototype.throttle = function (func, wait, options) {\n    var _this = this;\n    if (this._isDisposed) {\n      return this._noop;\n    }\n    var waitMS = wait || 0;\n    var leading = true;\n    var trailing = true;\n    var lastExecuteTime = 0;\n    var lastResult;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var lastArgs;\n    var timeoutId = null;\n    if (options && typeof options.leading === 'boolean') {\n      leading = options.leading;\n    }\n    if (options && typeof options.trailing === 'boolean') {\n      trailing = options.trailing;\n    }\n    var callback = function (userCall) {\n      var now = Date.now();\n      var delta = now - lastExecuteTime;\n      var waitLength = leading ? waitMS - delta : waitMS;\n      if (delta >= waitMS && (!userCall || leading)) {\n        lastExecuteTime = now;\n        if (timeoutId) {\n          _this.clearTimeout(timeoutId);\n          timeoutId = null;\n        }\n        lastResult = func.apply(_this._parent, lastArgs);\n      } else if (timeoutId === null && trailing) {\n        timeoutId = _this.setTimeout(callback, waitLength);\n      }\n      return lastResult;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var resultFunction = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      lastArgs = args;\n      return callback(true);\n    };\n    return resultFunction;\n  };\n  /**\n   * Creates a function that will delay the execution of func until after wait milliseconds have\n   * elapsed since the last time it was invoked. Provide an options object to indicate that func\n   * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls\n   * to the debounced function will return the result of the last func call.\n   *\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\n   * the timeout only if the debounced function is invoked more than once during the wait\n   * timeout.\n   *\n   * @param func - The function to debounce.\n   * @param wait - The number of milliseconds to delay.\n   * @param options - The options object.\n   * @returns The new debounced function.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Async.prototype.debounce = function (func, wait, options) {\n    var _this = this;\n    if (this._isDisposed) {\n      var noOpFunction = function () {\n        /** Do nothing */\n      };\n      noOpFunction.cancel = function () {\n        return;\n      };\n      noOpFunction.flush = function () {\n        return null;\n      };\n      noOpFunction.pending = function () {\n        return false;\n      };\n      return noOpFunction;\n    }\n    var waitMS = wait || 0;\n    var leading = false;\n    var trailing = true;\n    var maxWait = null;\n    var lastCallTime = 0;\n    var lastExecuteTime = Date.now();\n    var lastResult;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var lastArgs;\n    var timeoutId = null;\n    if (options && typeof options.leading === 'boolean') {\n      leading = options.leading;\n    }\n    if (options && typeof options.trailing === 'boolean') {\n      trailing = options.trailing;\n    }\n    if (options && typeof options.maxWait === 'number' && !isNaN(options.maxWait)) {\n      maxWait = options.maxWait;\n    }\n    var markExecuted = function (time) {\n      if (timeoutId) {\n        _this.clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n      lastExecuteTime = time;\n    };\n    var invokeFunction = function (time) {\n      markExecuted(time);\n      lastResult = func.apply(_this._parent, lastArgs);\n    };\n    var callback = function (userCall) {\n      var now = Date.now();\n      var executeImmediately = false;\n      if (userCall) {\n        if (leading && now - lastCallTime >= waitMS) {\n          executeImmediately = true;\n        }\n        lastCallTime = now;\n      }\n      var delta = now - lastCallTime;\n      var waitLength = waitMS - delta;\n      var maxWaitDelta = now - lastExecuteTime;\n      var maxWaitExpired = false;\n      if (maxWait !== null) {\n        // maxWait only matters when there is a pending callback\n        if (maxWaitDelta >= maxWait && timeoutId) {\n          maxWaitExpired = true;\n        } else {\n          waitLength = Math.min(waitLength, maxWait - maxWaitDelta);\n        }\n      }\n      if (delta >= waitMS || maxWaitExpired || executeImmediately) {\n        invokeFunction(now);\n      } else if ((timeoutId === null || !userCall) && trailing) {\n        timeoutId = _this.setTimeout(callback, waitLength);\n      }\n      return lastResult;\n    };\n    var pending = function () {\n      return !!timeoutId;\n    };\n    var cancel = function () {\n      if (pending()) {\n        // Mark the debounced function as having executed\n        markExecuted(Date.now());\n      }\n    };\n    var flush = function () {\n      if (pending()) {\n        invokeFunction(Date.now());\n      }\n      return lastResult;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var resultFunction = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      lastArgs = args;\n      return callback(true);\n    };\n    resultFunction.cancel = cancel;\n    resultFunction.flush = flush;\n    resultFunction.pending = pending;\n    return resultFunction;\n  };\n  Async.prototype.requestAnimationFrame = function (callback, targetElement) {\n    var _this = this;\n    var animationFrameId = 0;\n    var win = getWindow(targetElement);\n    if (!this._isDisposed) {\n      if (!this._animationFrameIds) {\n        this._animationFrameIds = {};\n      }\n      var animationFrameCallback = function () {\n        try {\n          // Now delete the record and call the callback.\n          if (_this._animationFrameIds) {\n            delete _this._animationFrameIds[animationFrameId];\n          }\n          callback.apply(_this._parent);\n        } catch (e) {\n          _this._logError(e);\n        }\n      };\n      animationFrameId = win.requestAnimationFrame ? win.requestAnimationFrame(animationFrameCallback) : win.setTimeout(animationFrameCallback, 0);\n      this._animationFrameIds[animationFrameId] = true;\n    }\n    return animationFrameId;\n  };\n  Async.prototype.cancelAnimationFrame = function (id, targetElement) {\n    var win = getWindow(targetElement);\n    if (this._animationFrameIds && this._animationFrameIds[id]) {\n      win.cancelAnimationFrame ? win.cancelAnimationFrame(id) : win.clearTimeout(id);\n      delete this._animationFrameIds[id];\n    }\n  };\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Async.prototype._logError = function (e) {\n    if (this._onErrorHandler) {\n      this._onErrorHandler(e);\n    }\n  };\n  return Async;\n}();\nexport { Async };","map":{"version":3,"names":["getWindow","Async","parent","onError","_timeoutIds","_immediateIds","_intervalIds","_animationFrameIds","_isDisposed","_parent","_onErrorHandler","_noop","prototype","dispose","id","hasOwnProperty","clearTimeout","parseInt","clearImmediate","clearInterval","cancelAnimationFrame","setTimeout","callback","duration","_this","timeoutId","apply","e","_logError","setImmediate","targetElement","immediateId","win","setImmediateCallback","setInterval","intervalId","throttle","func","wait","options","waitMS","leading","trailing","lastExecuteTime","lastResult","lastArgs","userCall","now","Date","delta","waitLength","resultFunction","args","_i","arguments","length","debounce","noOpFunction","cancel","flush","pending","maxWait","lastCallTime","isNaN","markExecuted","time","invokeFunction","executeImmediately","maxWaitDelta","maxWaitExpired","Math","min","requestAnimationFrame","animationFrameId","animationFrameCallback"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/utilities/src/Async.ts"],"sourcesContent":["import { getWindow } from './dom/getWindow';\n\ndeclare function setTimeout(cb: Function, delay: number): number;\ndeclare function setInterval(cb: Function, delay: number): number;\n\n/**\n * Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled.\n * This Async helper class solves these issues by tying async code to the lifetime of a disposable object.\n *\n * Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a\n * new instance of the class and remember to call dispose() during your code's dispose handler.\n *\n * @public\n */\nexport class Async {\n  private _timeoutIds: { [id: number]: boolean } | null = null;\n  private _immediateIds: { [id: number]: boolean } | null = null;\n  private _intervalIds: { [id: number]: boolean } | null = null;\n  private _animationFrameIds: { [id: number]: boolean } | null = null;\n  private _isDisposed: boolean;\n  private _parent: object | null;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _onErrorHandler: ((e: any) => void) | undefined;\n  private _noop: () => void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(parent?: object, onError?: (e: any) => void) {\n    this._isDisposed = false;\n    this._parent = parent || null;\n    this._onErrorHandler = onError;\n    this._noop = () => {\n      /* do nothing */\n    };\n  }\n\n  /**\n   * Dispose function, clears all async operations.\n   */\n  public dispose(): void {\n    let id;\n\n    this._isDisposed = true;\n    this._parent = null;\n\n    // Clear timeouts.\n    if (this._timeoutIds) {\n      for (id in this._timeoutIds) {\n        if (this._timeoutIds.hasOwnProperty(id)) {\n          this.clearTimeout(parseInt(id, 10));\n        }\n      }\n\n      this._timeoutIds = null;\n    }\n\n    // Clear immediates.\n    if (this._immediateIds) {\n      for (id in this._immediateIds) {\n        if (this._immediateIds.hasOwnProperty(id)) {\n          this.clearImmediate(parseInt(id, 10));\n        }\n      }\n\n      this._immediateIds = null;\n    }\n\n    // Clear intervals.\n    if (this._intervalIds) {\n      for (id in this._intervalIds) {\n        if (this._intervalIds.hasOwnProperty(id)) {\n          this.clearInterval(parseInt(id, 10));\n        }\n      }\n      this._intervalIds = null;\n    }\n\n    // Clear animation frames.\n    if (this._animationFrameIds) {\n      for (id in this._animationFrameIds) {\n        if (this._animationFrameIds.hasOwnProperty(id)) {\n          this.cancelAnimationFrame(parseInt(id, 10));\n        }\n      }\n\n      this._animationFrameIds = null;\n    }\n  }\n\n  /**\n   * SetTimeout override, which will auto cancel the timeout during dispose.\n   * @param callback - Callback to execute.\n   * @param duration - Duration in milliseconds.\n   * @returns The setTimeout id.\n   */\n  public setTimeout(callback: () => void, duration: number): number {\n    let timeoutId = 0;\n\n    if (!this._isDisposed) {\n      if (!this._timeoutIds) {\n        this._timeoutIds = {};\n      }\n\n      timeoutId = setTimeout(() => {\n        // Time to execute the timeout, enqueue it as a foreground task to be executed.\n\n        try {\n          // Now delete the record and call the callback.\n          if (this._timeoutIds) {\n            delete this._timeoutIds[timeoutId];\n          }\n          callback.apply(this._parent);\n        } catch (e) {\n          this._logError(e);\n        }\n      }, duration);\n\n      this._timeoutIds[timeoutId] = true;\n    }\n\n    return timeoutId;\n  }\n\n  /**\n   * Clears the timeout.\n   * @param id - Id to cancel.\n   */\n  public clearTimeout(id: number): void {\n    if (this._timeoutIds && this._timeoutIds[id]) {\n      clearTimeout(id);\n      delete this._timeoutIds[id];\n    }\n  }\n\n  /**\n   * SetImmediate override, which will auto cancel the immediate during dispose.\n   * @param callback - Callback to execute.\n   * @param targetElement - Optional target element to use for identifying the correct window.\n   * @returns The setTimeout id.\n   */\n  public setImmediate(callback: () => void, targetElement?: Element | null): number {\n    let immediateId = 0;\n    const win = getWindow(targetElement)!;\n\n    if (!this._isDisposed) {\n      if (!this._immediateIds) {\n        this._immediateIds = {};\n      }\n\n      let setImmediateCallback = () => {\n        // Time to execute the timeout, enqueue it as a foreground task to be executed.\n\n        try {\n          // Now delete the record and call the callback.\n          if (this._immediateIds) {\n            delete this._immediateIds[immediateId];\n          }\n          callback.apply(this._parent);\n        } catch (e) {\n          this._logError(e);\n        }\n      };\n\n      immediateId = win.setTimeout(setImmediateCallback, 0);\n\n      this._immediateIds[immediateId] = true;\n    }\n\n    return immediateId;\n  }\n\n  /**\n   * Clears the immediate.\n   * @param id - Id to cancel.\n   * @param targetElement - Optional target element to use for identifying the correct window.\n   */\n  public clearImmediate(id: number, targetElement?: Element | null): void {\n    const win = getWindow(targetElement)!;\n\n    if (this._immediateIds && this._immediateIds[id]) {\n      win.clearTimeout(id);\n      delete this._immediateIds[id];\n    }\n  }\n\n  /**\n   * SetInterval override, which will auto cancel the timeout during dispose.\n   * @param callback - Callback to execute.\n   * @param duration - Duration in milliseconds.\n   * @returns The setTimeout id.\n   */\n  public setInterval(callback: () => void, duration: number): number {\n    let intervalId = 0;\n\n    if (!this._isDisposed) {\n      if (!this._intervalIds) {\n        this._intervalIds = {};\n      }\n\n      intervalId = setInterval(() => {\n        // Time to execute the interval callback, enqueue it as a foreground task to be executed.\n        try {\n          callback.apply(this._parent);\n        } catch (e) {\n          this._logError(e);\n        }\n      }, duration);\n\n      this._intervalIds[intervalId] = true;\n    }\n\n    return intervalId;\n  }\n\n  /**\n   * Clears the interval.\n   * @param id - Id to cancel.\n   */\n  public clearInterval(id: number): void {\n    if (this._intervalIds && this._intervalIds[id]) {\n      clearInterval(id);\n      delete this._intervalIds[id];\n    }\n  }\n\n  /**\n   * Creates a function that, when executed, will only call the func function at most once per\n   * every wait milliseconds. Provide an options object to indicate that func should be invoked\n   * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled\n   * function will return the result of the last func call.\n   *\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\n   * the timeout only if the throttled function is invoked more than once during the wait timeout.\n   *\n   * @param func - The function to throttle.\n   * @param wait - The number of milliseconds to throttle executions to. Defaults to 0.\n   * @param options - The options object.\n   * @returns The new throttled function.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public throttle<T extends (...args: any[]) => any>(\n    func: T,\n    wait?: number,\n    options?: {\n      leading?: boolean;\n      trailing?: boolean;\n    },\n  ): T {\n    if (this._isDisposed) {\n      return this._noop as T;\n    }\n\n    let waitMS = wait || 0;\n    let leading = true;\n    let trailing = true;\n    let lastExecuteTime = 0;\n    let lastResult: T;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let lastArgs: any[];\n    let timeoutId: number | null = null;\n\n    if (options && typeof options.leading === 'boolean') {\n      leading = options.leading;\n    }\n\n    if (options && typeof options.trailing === 'boolean') {\n      trailing = options.trailing;\n    }\n\n    let callback = (userCall?: boolean) => {\n      let now = Date.now();\n      let delta = now - lastExecuteTime;\n      let waitLength = leading ? waitMS - delta : waitMS;\n      if (delta >= waitMS && (!userCall || leading)) {\n        lastExecuteTime = now;\n        if (timeoutId) {\n          this.clearTimeout(timeoutId);\n          timeoutId = null;\n        }\n        lastResult = func.apply(this._parent, lastArgs);\n      } else if (timeoutId === null && trailing) {\n        timeoutId = this.setTimeout(callback, waitLength);\n      }\n\n      return lastResult;\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let resultFunction = ((...args: any[]): any => {\n      lastArgs = args;\n      return callback(true);\n    }) as T;\n\n    return resultFunction;\n  }\n\n  /**\n   * Creates a function that will delay the execution of func until after wait milliseconds have\n   * elapsed since the last time it was invoked. Provide an options object to indicate that func\n   * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls\n   * to the debounced function will return the result of the last func call.\n   *\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\n   * the timeout only if the debounced function is invoked more than once during the wait\n   * timeout.\n   *\n   * @param func - The function to debounce.\n   * @param wait - The number of milliseconds to delay.\n   * @param options - The options object.\n   * @returns The new debounced function.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public debounce<T extends (...args: any[]) => any>(\n    func: T,\n    wait?: number,\n    options?: {\n      leading?: boolean;\n      maxWait?: number;\n      trailing?: boolean;\n    },\n  ): ICancelable<T> & T {\n    if (this._isDisposed) {\n      let noOpFunction = (() => {\n        /** Do nothing */\n      }) as ICancelable<T> & T;\n\n      noOpFunction.cancel = () => {\n        return;\n      };\n      noOpFunction.flush = (() => null) as unknown as () => ReturnType<T>;\n      noOpFunction.pending = () => false;\n\n      return noOpFunction;\n    }\n\n    let waitMS = wait || 0;\n    let leading = false;\n    let trailing = true;\n    let maxWait: number | null = null;\n    let lastCallTime = 0;\n    let lastExecuteTime = Date.now();\n    let lastResult: ReturnType<T>;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let lastArgs: any[];\n    let timeoutId: number | null = null;\n\n    if (options && typeof options.leading === 'boolean') {\n      leading = options.leading;\n    }\n\n    if (options && typeof options.trailing === 'boolean') {\n      trailing = options.trailing;\n    }\n\n    if (options && typeof options.maxWait === 'number' && !isNaN(options.maxWait)) {\n      maxWait = options.maxWait;\n    }\n\n    let markExecuted = (time: number) => {\n      if (timeoutId) {\n        this.clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n      lastExecuteTime = time;\n    };\n\n    let invokeFunction = (time: number) => {\n      markExecuted(time);\n      lastResult = func.apply(this._parent, lastArgs);\n    };\n\n    let callback = (userCall?: boolean) => {\n      let now = Date.now();\n      let executeImmediately = false;\n      if (userCall) {\n        if (leading && now - lastCallTime >= waitMS) {\n          executeImmediately = true;\n        }\n        lastCallTime = now;\n      }\n      let delta = now - lastCallTime;\n      let waitLength = waitMS - delta;\n      let maxWaitDelta = now - lastExecuteTime;\n      let maxWaitExpired = false;\n\n      if (maxWait !== null) {\n        // maxWait only matters when there is a pending callback\n        if (maxWaitDelta >= maxWait && timeoutId) {\n          maxWaitExpired = true;\n        } else {\n          waitLength = Math.min(waitLength, maxWait - maxWaitDelta);\n        }\n      }\n\n      if (delta >= waitMS || maxWaitExpired || executeImmediately) {\n        invokeFunction(now);\n      } else if ((timeoutId === null || !userCall) && trailing) {\n        timeoutId = this.setTimeout(callback, waitLength);\n      }\n\n      return lastResult;\n    };\n\n    let pending = (): boolean => {\n      return !!timeoutId;\n    };\n\n    let cancel = (): void => {\n      if (pending()) {\n        // Mark the debounced function as having executed\n        markExecuted(Date.now());\n      }\n    };\n\n    let flush = () => {\n      if (pending()) {\n        invokeFunction(Date.now());\n      }\n\n      return lastResult;\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let resultFunction = ((...args: any[]) => {\n      lastArgs = args;\n      return callback(true);\n    }) as ICancelable<T> & T;\n\n    resultFunction.cancel = cancel;\n    resultFunction.flush = flush;\n    resultFunction.pending = pending;\n\n    return resultFunction;\n  }\n\n  public requestAnimationFrame(callback: () => void, targetElement?: Element | null): number {\n    let animationFrameId = 0;\n    const win = getWindow(targetElement)!;\n\n    if (!this._isDisposed) {\n      if (!this._animationFrameIds) {\n        this._animationFrameIds = {};\n      }\n\n      let animationFrameCallback = () => {\n        try {\n          // Now delete the record and call the callback.\n          if (this._animationFrameIds) {\n            delete this._animationFrameIds[animationFrameId];\n          }\n\n          callback.apply(this._parent);\n        } catch (e) {\n          this._logError(e);\n        }\n      };\n\n      animationFrameId = win.requestAnimationFrame\n        ? win.requestAnimationFrame(animationFrameCallback)\n        : win.setTimeout(animationFrameCallback, 0);\n\n      this._animationFrameIds[animationFrameId] = true;\n    }\n\n    return animationFrameId;\n  }\n\n  public cancelAnimationFrame(id: number, targetElement?: Element | null): void {\n    const win = getWindow(targetElement)!;\n\n    if (this._animationFrameIds && this._animationFrameIds[id]) {\n      win.cancelAnimationFrame ? win.cancelAnimationFrame(id) : win.clearTimeout(id);\n      delete this._animationFrameIds[id];\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected _logError(e: any): void {\n    if (this._onErrorHandler) {\n      this._onErrorHandler(e);\n    }\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ICancelable<T extends (...args: any[]) => any> = {\n  flush: () => ReturnType<T>;\n  cancel: () => void;\n  pending: () => boolean;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}