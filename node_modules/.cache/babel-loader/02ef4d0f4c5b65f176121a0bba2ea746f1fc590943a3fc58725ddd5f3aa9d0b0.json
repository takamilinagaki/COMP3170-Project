{"ast":null,"code":"import { arraysEqual } from './array';\n/**\n * Set up a ref resolver function given internal state managed for the ref.\n * @param local Set\n */\nvar createResolver = function (local) {\n  return function (newValue) {\n    for (var _i = 0, _a = local.refs; _i < _a.length; _i++) {\n      var ref = _a[_i];\n      if (typeof ref === 'function') {\n        ref(newValue);\n      } else if (ref) {\n        // work around the immutability of the React.Ref type\n        ref.current = newValue;\n      }\n    }\n  };\n};\n/**\n * Helper to merge refs from within class components.\n */\nexport var createMergedRef = function (value) {\n  var local = {\n    refs: []\n  };\n  return function () {\n    var newRefs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      newRefs[_i] = arguments[_i];\n    }\n    if (!local.resolver || !arraysEqual(local.refs, newRefs)) {\n      local.resolver = createResolver(local);\n    }\n    local.refs = newRefs;\n    return local.resolver;\n  };\n};","map":{"version":3,"names":["arraysEqual","createResolver","local","newValue","_i","_a","refs","length","ref","current","createMergedRef","value","newRefs","arguments","resolver"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/utilities/src/createMergedRef.ts"],"sourcesContent":["import * as React from 'react';\nimport { arraysEqual } from './array';\n\n/**\n * Internal state type for the ref.\n */\ntype LocalState<TType, TValue> = {\n  refs: (React.Ref<TType | null | TValue> | undefined)[];\n  resolver?: (newValue: TType | TValue | null) => void;\n};\n\n/**\n * Set up a ref resolver function given internal state managed for the ref.\n * @param local Set\n */\nconst createResolver =\n  <TType, TValue>(local: LocalState<TType, TValue>) =>\n  (newValue: TType | TValue | null) => {\n    for (const ref of local.refs) {\n      if (typeof ref === 'function') {\n        ref(newValue);\n      } else if (ref) {\n        // work around the immutability of the React.Ref type\n        (ref as unknown as React.MutableRefObject<TType | TValue | null | undefined>).current = newValue;\n      }\n    }\n  };\n\n/**\n * Helper to merge refs from within class components.\n */\nexport const createMergedRef = <TType, TValue = null>(value?: TValue) => {\n  const local: LocalState<TType, TValue> = {\n    refs: [] as LocalState<TType, TValue>['refs'],\n  };\n\n  return (\n    ...newRefs: (React.Ref<TType | null | TValue> | undefined)[]\n  ): ((newValue: TType | TValue | null) => void) => {\n    if (!local.resolver || !arraysEqual(local.refs, newRefs)) {\n      local.resolver = createResolver<TType, TValue>(local);\n    }\n\n    local.refs = newRefs;\n\n    return local.resolver!;\n  };\n};\n"],"mappings":"AACA,SAASA,WAAW,QAAQ,SAAS;AAUrC;;;;AAIA,IAAMC,cAAc,GAClB,SAAAA,CAAgBC,KAAgC;EAChD,iBAACC,QAA+B;IAC9B,KAAkB,IAAAC,EAAA,IAAU,EAAVC,EAAA,GAAAH,KAAK,CAACI,IAAI,EAAVF,EAAA,GAAAC,EAAA,CAAAE,MAAU,EAAVH,EAAA,EAAU,EAAE;MAAzB,IAAMI,GAAG,GAAAH,EAAA,CAAAD,EAAA;MACZ,IAAI,OAAOI,GAAG,KAAK,UAAU,EAAE;QAC7BA,GAAG,CAACL,QAAQ,CAAC;OACd,MAAM,IAAIK,GAAG,EAAE;QACd;QACCA,GAA4E,CAACC,OAAO,GAAGN,QAAQ;;;EAGtG,CAAC;AATD,CASC;AAEH;;;AAGA,OAAO,IAAMO,eAAe,GAAG,SAAAA,CAAuBC,KAAc;EAClE,IAAMT,KAAK,GAA8B;IACvCI,IAAI,EAAE;GACP;EAED,OAAO;IACL,IAAAM,OAAA;SAAA,IAAAR,EAAA,IAA4D,EAA5DA,EAAA,GAAAS,SAAA,CAAAN,MAA4D,EAA5DH,EAAA,EAA4D;MAA5DQ,OAAA,CAAAR,EAAA,IAAAS,SAAA,CAAAT,EAAA;;IAEA,IAAI,CAACF,KAAK,CAACY,QAAQ,IAAI,CAACd,WAAW,CAACE,KAAK,CAACI,IAAI,EAAEM,OAAO,CAAC,EAAE;MACxDV,KAAK,CAACY,QAAQ,GAAGb,cAAc,CAAgBC,KAAK,CAAC;;IAGvDA,KAAK,CAACI,IAAI,GAAGM,OAAO;IAEpB,OAAOV,KAAK,CAACY,QAAS;EACxB,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}