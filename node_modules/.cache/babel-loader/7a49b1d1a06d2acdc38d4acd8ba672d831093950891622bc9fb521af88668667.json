{"ast":null,"code":"/**\n * Compares a to b and b to a.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function shallowCompare(a, b) {\n  if (!a || !b) {\n    // only return true if both a and b are falsy\n    return !a && !b;\n  }\n  for (var propName in a) {\n    if (a.hasOwnProperty(propName)) {\n      if (!b.hasOwnProperty(propName) || b[propName] !== a[propName]) {\n        return false;\n      }\n    }\n  }\n  for (var propName in b) {\n    if (b.hasOwnProperty(propName)) {\n      if (!a.hasOwnProperty(propName)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n/**\n * Makes a resulting merge of a bunch of objects. Pass in the target object followed by 1 or more\n * objects as arguments and they will be merged sequentially into the target. Note that this will\n * shallow merge; it will not create new cloned values for target members.\n *\n * @public\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function assign(target) {\n  var args = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n  return filteredAssign.apply(this, [null, target].concat(args));\n}\n/**\n * Makes a resulting merge of a bunch of objects, but allows a filter function to be passed in to filter\n * the resulting merges. This allows for scenarios where you want to merge \"everything except that one thing\"\n * or \"properties that start with data-\". Note that this will shallow merge; it will not create new cloned\n * values for target members.\n *\n * @public\n * @param isAllowed - Callback to determine if the given propName is allowed in the result.\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function filteredAssign(isAllowed, target) {\n  var args = [];\n  for (var _i = 2; _i < arguments.length; _i++) {\n    args[_i - 2] = arguments[_i];\n  }\n  target = target || {};\n  for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n    var sourceObject = args_1[_a];\n    if (sourceObject) {\n      for (var propName in sourceObject) {\n        if (sourceObject.hasOwnProperty(propName) && (!isAllowed || isAllowed(propName))) {\n          target[propName] = sourceObject[propName];\n        }\n      }\n    }\n  }\n  return target;\n}\n/**\n * Takes an enum and iterates over each value of the enum (as a string), running the callback on each,\n * returning a mapped array.\n * @param theEnum - Enum to iterate over\n * @param callback - The first parameter the name of the entry, and the second parameter is the value\n * of that entry, which is the value you'd normally use when using the enum (usually a number).\n */\nexport function mapEnumByName(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntheEnum, callback) {\n  // map<any> to satisfy compiler since it doesn't realize we strip out undefineds in the .filter() call\n  return Object.keys(theEnum).map(function (p) {\n    // map on each property name as a string\n    if (String(Number(p)) !== p) {\n      // if the property is not just a number (because enums in TypeScript will map both ways)\n      return callback(p, theEnum[p]);\n    }\n    return undefined;\n  }).filter(function (v) {\n    return !!v;\n  }); // only return elements with values\n}\n/**\n * Get all values in an object dictionary\n *\n * @param obj - The dictionary to get values for\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function values(obj) {\n  return Object.keys(obj).reduce(function (arr, key) {\n    arr.push(obj[key]);\n    return arr;\n  }, []);\n}\n/**\n * Tiny helper to do the minimal amount of work in duplicating an object but omitting some\n * props. This ends up faster than using object ...rest or reduce to filter.\n *\n * This behaves very much like filteredAssign, but does not merge many objects together,\n * uses an exclusion object map, and avoids spreads all for optimal performance.\n *\n * See perf test for background:\n * https://jsperf.com/omit-vs-rest-vs-reduce/1\n *\n * @param obj - The object to clone\n * @param exclusions - The array of keys to exclude\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function omit(obj, exclusions) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  var result = {};\n  for (var key in obj) {\n    if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["shallowCompare","a","b","propName","hasOwnProperty","assign","target","args","_i","arguments","length","filteredAssign","apply","concat","isAllowed","_a","args_1","sourceObject","mapEnumByName","theEnum","callback","Object","keys","map","p","String","Number","undefined","filter","v","values","obj","reduce","arr","key","push","omit","exclusions","result","indexOf"],"sources":["/Users/jerrywuyongon/node_modules/@fluentui/utilities/src/object.ts"],"sourcesContent":["/**\n * Compares a to b and b to a.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function shallowCompare<TA extends any, TB extends any>(a: TA, b: TB): boolean {\n  if (!a || !b) {\n    // only return true if both a and b are falsy\n    return !a && !b;\n  }\n\n  for (let propName in a) {\n    if ((a as Object).hasOwnProperty(propName)) {\n      if (!(b as Object).hasOwnProperty(propName) || (b as { [key: string]: unknown })[propName] !== a[propName]) {\n        return false;\n      }\n    }\n  }\n  for (let propName in b) {\n    if ((b as Object).hasOwnProperty(propName)) {\n      if (!(a as Object).hasOwnProperty(propName)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Makes a resulting merge of a bunch of objects. Pass in the target object followed by 1 or more\n * objects as arguments and they will be merged sequentially into the target. Note that this will\n * shallow merge; it will not create new cloned values for target members.\n *\n * @public\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function assign(this: any, target: any, ...args: any[]): any {\n  return filteredAssign.apply(this, [null, target].concat(args));\n}\n\n/**\n * Makes a resulting merge of a bunch of objects, but allows a filter function to be passed in to filter\n * the resulting merges. This allows for scenarios where you want to merge \"everything except that one thing\"\n * or \"properties that start with data-\". Note that this will shallow merge; it will not create new cloned\n * values for target members.\n *\n * @public\n * @param isAllowed - Callback to determine if the given propName is allowed in the result.\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function filteredAssign(isAllowed: (propName: string) => boolean, target: any, ...args: any[]): any {\n  target = target || {};\n\n  for (let sourceObject of args) {\n    if (sourceObject) {\n      for (let propName in sourceObject) {\n        if (sourceObject.hasOwnProperty(propName) && (!isAllowed || isAllowed(propName))) {\n          target[propName] = sourceObject[propName];\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\n/**\n * Takes an enum and iterates over each value of the enum (as a string), running the callback on each,\n * returning a mapped array.\n * @param theEnum - Enum to iterate over\n * @param callback - The first parameter the name of the entry, and the second parameter is the value\n * of that entry, which is the value you'd normally use when using the enum (usually a number).\n */\nexport function mapEnumByName<T>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  theEnum: any,\n  callback: (name?: string, value?: string | number) => T | undefined,\n): (T | undefined)[] | undefined {\n  // map<any> to satisfy compiler since it doesn't realize we strip out undefineds in the .filter() call\n  return Object.keys(theEnum)\n    .map<T | undefined>((p: string | number) => {\n      // map on each property name as a string\n      if (String(Number(p)) !== p) {\n        // if the property is not just a number (because enums in TypeScript will map both ways)\n        return callback(p as string, theEnum[p]);\n      }\n      return undefined;\n    })\n    .filter((v: T | undefined) => !!v); // only return elements with values\n}\n\n/**\n * Get all values in an object dictionary\n *\n * @param obj - The dictionary to get values for\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function values<T>(obj: any): T[] {\n  return Object.keys(obj).reduce((arr: T[], key: string): T[] => {\n    arr.push(obj[key]);\n    return arr;\n  }, []);\n}\n\n/**\n * Tiny helper to do the minimal amount of work in duplicating an object but omitting some\n * props. This ends up faster than using object ...rest or reduce to filter.\n *\n * This behaves very much like filteredAssign, but does not merge many objects together,\n * uses an exclusion object map, and avoids spreads all for optimal performance.\n *\n * See perf test for background:\n * https://jsperf.com/omit-vs-rest-vs-reduce/1\n *\n * @param obj - The object to clone\n * @param exclusions - The array of keys to exclude\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function omit<TObj extends Record<string, any>>(obj: TObj, exclusions: (keyof TObj)[]): TObj {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const result: Record<string, any> = {};\n\n  for (const key in obj) {\n    if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) {\n      result[key] = obj[key];\n    }\n  }\n\n  return result as TObj;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}